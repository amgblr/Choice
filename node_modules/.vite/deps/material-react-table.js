import {
  TableFooter_default
} from "./chunk-ILYPU7VU.js";
import {
  useMediaQuery
} from "./chunk-WWIGTEWD.js";
import {
  TableSortLabel_default
} from "./chunk-7F4753EH.js";
import {
  TextField_default
} from "./chunk-UNOIGA3F.js";
import {
  TableContainer_default
} from "./chunk-SZVXHF6C.js";
import {
  TableHead_default
} from "./chunk-BLD5MNUQ.js";
import {
  TablePagination_default
} from "./chunk-MNMU4PWG.js";
import {
  Toolbar_default
} from "./chunk-75AYAC6V.js";
import {
  TableCell_default
} from "./chunk-4Q5I66LT.js";
import {
  TableBody_default
} from "./chunk-7ZDNUR4Z.js";
import {
  TableRow_default
} from "./chunk-7CDTBMYI.js";
import "./chunk-ZQEP4OHC.js";
import "./chunk-7HE6IVYK.js";
import {
  Tooltip_default
} from "./chunk-4FR4IBQO.js";
import {
  Switch_default
} from "./chunk-STEQFBAC.js";
import {
  Table_default
} from "./chunk-ENTBMOVT.js";
import "./chunk-ICVSQHOT.js";
import {
  Slider_default
} from "./chunk-B4SAX3EK.js";
import {
  Skeleton_default
} from "./chunk-7JMNDCIB.js";
import {
  Stack_default
} from "./chunk-HLSCU4II.js";
import {
  Radio_default
} from "./chunk-KW2C564Z.js";
import "./chunk-6VBMUVOQ.js";
import "./chunk-53YOMEWK.js";
import "./chunk-HEHZQNTC.js";
import {
  MenuItem_default
} from "./chunk-DRPARXEQ.js";
import {
  ListItemIcon_default
} from "./chunk-M6EFIZSO.js";
import "./chunk-33MYK2RE.js";
import {
  Menu_default
} from "./chunk-L4DFHAL6.js";
import "./chunk-M7KT2KOG.js";
import "./chunk-T7NY46GG.js";
import {
  Grow_default
} from "./chunk-JIOKIN6Y.js";
import "./chunk-PICDEFIY.js";
import {
  LinearProgress_default
} from "./chunk-M7JZ4EMR.js";
import "./chunk-B7Z6IZXJ.js";
import "./chunk-QU5CLVXZ.js";
import "./chunk-OYW3GWTT.js";
import "./chunk-PHNMT3NR.js";
import {
  FormHelperText_default
} from "./chunk-CKX3BX6W.js";
import {
  FormControlLabel_default
} from "./chunk-XXWFJLCO.js";
import "./chunk-DRC3BVBB.js";
import "./chunk-RMMHIUZ3.js";
import {
  InputAdornment_default
} from "./chunk-HCPCOBH4.js";
import {
  Divider_default
} from "./chunk-QSE4EDO6.js";
import {
  DialogTitle_default
} from "./chunk-BOT4AVRR.js";
import "./chunk-AVAGZCNP.js";
import "./chunk-3RET3YIL.js";
import {
  DialogActions_default
} from "./chunk-XOV5MNKJ.js";
import {
  DialogContent_default
} from "./chunk-Q6QNGMTW.js";
import "./chunk-DMKQXWVI.js";
import {
  Dialog_default
} from "./chunk-WFYKMTTO.js";
import "./chunk-SUDMMGFC.js";
import "./chunk-GKPWN6ZT.js";
import {
  Checkbox_default
} from "./chunk-UYMZX3HQ.js";
import "./chunk-7ANJ56RJ.js";
import {
  Badge_default
} from "./chunk-E5RLO6VU.js";
import "./chunk-RO3X5GAA.js";
import {
  Fade_default
} from "./chunk-V4DVPHOK.js";
import "./chunk-PECZXRDV.js";
import "./chunk-XXUPADJX.js";
import "./chunk-FDZ6RLQN.js";
import "./chunk-YHADIXUF.js";
import "./chunk-4Z52ENKG.js";
import "./chunk-IFBBWHCQ.js";
import "./chunk-PR6ZCO7G.js";
import "./chunk-AKKANAVW.js";
import "./chunk-4L76K3VW.js";
import "./chunk-YYXNYR7E.js";
import {
  Chip_default
} from "./chunk-L73H6NY6.js";
import {
  Box_default
} from "./chunk-NR7KYHTE.js";
import {
  Collapse_default
} from "./chunk-NPAICY4Q.js";
import "./chunk-TJ4WWSAQ.js";
import {
  Alert_default
} from "./chunk-IIQVJ77K.js";
import "./chunk-2E2OW3PT.js";
import {
  IconButton_default
} from "./chunk-XV4CIBSX.js";
import {
  AlertTitle_default
} from "./chunk-FKYOHFXW.js";
import {
  Paper_default
} from "./chunk-XBPMAEQN.js";
import {
  Typography_default
} from "./chunk-CFOQ2THW.js";
import {
  require_createSvgIcon,
  require_interopRequireDefault
} from "./chunk-3H4OFIE2.js";
import {
  Button_default
} from "./chunk-ZBPYLC6T.js";
import "./chunk-D25ADEQS.js";
import "./chunk-RPCV76H6.js";
import "./chunk-TU4SCASD.js";
import "./chunk-T2RGT4ZC.js";
import "./chunk-KPCKTKIM.js";
import {
  init_utils
} from "./chunk-2JFW4W2U.js";
import "./chunk-CQT3HM33.js";
import "./chunk-CLBO5QBH.js";
import {
  debounce_default
} from "./chunk-PJ34N24D.js";
import "./chunk-7R7VUSYV.js";
import "./chunk-Y4HSIQUH.js";
import "./chunk-W7WE2RJW.js";
import "./chunk-WAMLAQ76.js";
import "./chunk-6B5WPRYI.js";
import "./chunk-B4NP4KPM.js";
import "./chunk-RGL2J7LO.js";
import "./chunk-FVWB57TK.js";
import "./chunk-UYYMBUGX.js";
import "./chunk-QSF5M6MG.js";
import "./chunk-WBEJ64CX.js";
import "./chunk-FMFFUJ5P.js";
import {
  useTheme
} from "./chunk-3TW4MT3C.js";
import "./chunk-UAIHK6XU.js";
import "./chunk-PNJYQXZZ.js";
import "./chunk-SJUYZQ7Y.js";
import "./chunk-DEJKJ5PH.js";
import "./chunk-BI3I73UF.js";
import "./chunk-HVTZFXGY.js";
import "./chunk-VWTAT46Z.js";
import {
  alpha,
  darken,
  lighten
} from "./chunk-IKNVR6L3.js";
import "./chunk-FFQKQ7UO.js";
import "./chunk-DKFUNVSZ.js";
import "./chunk-PPLKJ7N6.js";
import {
  require_jsx_runtime
} from "./chunk-IXNBSIST.js";
import "./chunk-V66CRQXE.js";
import "./chunk-KWUZEEQS.js";
import "./chunk-AT3RVNMG.js";
import "./chunk-WAFQIO3T.js";
import "./chunk-NGURHOVW.js";
import "./chunk-ABW2PW2F.js";
import "./chunk-VV5DYCQJ.js";
import "./chunk-WGLPVN3I.js";
import {
  require_react
} from "./chunk-6CE3F7YD.js";
import {
  __commonJS,
  __toESM
} from "./chunk-TFWDKVI3.js";

// node_modules/@mui/icons-material/ArrowDownward.js
var require_ArrowDownward = __commonJS({
  "node_modules/@mui/icons-material/ArrowDownward.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "m20 12-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
    }), "ArrowDownward");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/ArrowRight.js
var require_ArrowRight = __commonJS({
  "node_modules/@mui/icons-material/ArrowRight.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "m10 17 5-5-5-5v10z"
    }), "ArrowRight");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/@mui/icons-material/Cancel.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
    }), "Cancel");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/ClearAll.js
var require_ClearAll = __commonJS({
  "node_modules/@mui/icons-material/ClearAll.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M5 13h14v-2H5v2zm-2 4h14v-2H3v2zM7 7v2h14V7H7z"
    }), "ClearAll");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/Close.js
var require_Close = __commonJS({
  "node_modules/@mui/icons-material/Close.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
    }), "Close");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/DensityLarge.js
var require_DensityLarge = __commonJS({
  "node_modules/@mui/icons-material/DensityLarge.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M3 3h18v2H3zm0 16h18v2H3z"
    }), "DensityLarge");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/DensityMedium.js
var require_DensityMedium = __commonJS({
  "node_modules/@mui/icons-material/DensityMedium.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M3 3h18v2H3zm0 16h18v2H3zm0-8h18v2H3z"
    }), "DensityMedium");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/DensitySmall.js
var require_DensitySmall = __commonJS({
  "node_modules/@mui/icons-material/DensitySmall.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M3 2h18v2H3zm0 18h18v2H3zm0-6h18v2H3zm0-6h18v2H3z"
    }), "DensitySmall");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/DragHandle.js
var require_DragHandle = __commonJS({
  "node_modules/@mui/icons-material/DragHandle.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M20 9H4v2h16V9zM4 15h16v-2H4v2z"
    }), "DragHandle");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/DynamicFeed.js
var require_DynamicFeed = __commonJS({
  "node_modules/@mui/icons-material/DynamicFeed.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)([(0, _jsxRuntime.jsx)("path", {
      d: "M8 8H6v7c0 1.1.9 2 2 2h9v-2H8V8z"
    }, "0"), (0, _jsxRuntime.jsx)("path", {
      d: "M20 3h-8c-1.1 0-2 .9-2 2v6c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 8h-8V7h8v4zM4 12H2v7c0 1.1.9 2 2 2h9v-2H4v-7z"
    }, "1")], "DynamicFeed");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/Edit.js
var require_Edit = __commonJS({
  "node_modules/@mui/icons-material/Edit.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.9959.9959 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"
    }), "Edit");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/ExpandMore.js
var require_ExpandMore = __commonJS({
  "node_modules/@mui/icons-material/ExpandMore.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"
    }), "ExpandMore");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/FilterAlt.js
var require_FilterAlt = __commonJS({
  "node_modules/@mui/icons-material/FilterAlt.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M4.25 5.61C6.27 8.2 10 13 10 13v6c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-6s3.72-4.8 5.74-7.39c.51-.66.04-1.61-.79-1.61H5.04c-.83 0-1.3.95-.79 1.61z"
    }), "FilterAlt");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/FilterList.js
var require_FilterList = __commonJS({
  "node_modules/@mui/icons-material/FilterList.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z"
    }), "FilterList");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/FilterListOff.js
var require_FilterListOff = __commonJS({
  "node_modules/@mui/icons-material/FilterListOff.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M10.83 8H21V6H8.83l2 2zm5 5H18v-2h-4.17l2 2zM14 16.83V18h-4v-2h3.17l-3-3H6v-2h2.17l-3-3H3V6h.17L1.39 4.22 2.8 2.81l18.38 18.38-1.41 1.41L14 16.83z"
    }), "FilterListOff");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/FullscreenExit.js
var require_FullscreenExit = __commonJS({
  "node_modules/@mui/icons-material/FullscreenExit.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"
    }), "FullscreenExit");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/Fullscreen.js
var require_Fullscreen = __commonJS({
  "node_modules/@mui/icons-material/Fullscreen.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"
    }), "Fullscreen");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/KeyboardDoubleArrowDown.js
var require_KeyboardDoubleArrowDown = __commonJS({
  "node_modules/@mui/icons-material/KeyboardDoubleArrowDown.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)([(0, _jsxRuntime.jsx)("path", {
      d: "M18 6.41 16.59 5 12 9.58 7.41 5 6 6.41l6 6z"
    }, "0"), (0, _jsxRuntime.jsx)("path", {
      d: "m18 13-1.41-1.41L12 16.17l-4.59-4.58L6 13l6 6z"
    }, "1")], "KeyboardDoubleArrowDown");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/MoreHoriz.js
var require_MoreHoriz = __commonJS({
  "node_modules/@mui/icons-material/MoreHoriz.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
    }), "MoreHoriz");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/MoreVert.js
var require_MoreVert = __commonJS({
  "node_modules/@mui/icons-material/MoreVert.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
    }), "MoreVert");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/PushPin.js
var require_PushPin = __commonJS({
  "node_modules/@mui/icons-material/PushPin.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      fillRule: "evenodd",
      d: "M16 9V4h1c.55 0 1-.45 1-1s-.45-1-1-1H7c-.55 0-1 .45-1 1s.45 1 1 1h1v5c0 1.66-1.34 3-3 3v2h5.97v7l1 1 1-1v-7H19v-2c-1.66 0-3-1.34-3-3z"
    }), "PushPin");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/RestartAlt.js
var require_RestartAlt = __commonJS({
  "node_modules/@mui/icons-material/RestartAlt.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M12 5V2L8 6l4 4V7c3.31 0 6 2.69 6 6 0 2.97-2.17 5.43-5 5.91v2.02c3.95-.49 7-3.85 7-7.93 0-4.42-3.58-8-8-8zm-6 8c0-1.65.67-3.15 1.76-4.24L6.34 7.34C4.9 8.79 4 10.79 4 13c0 4.08 3.05 7.44 7 7.93v-2.02c-2.83-.48-5-2.94-5-5.91z"
    }), "RestartAlt");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/Save.js
var require_Save = __commonJS({
  "node_modules/@mui/icons-material/Save.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"
    }), "Save");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/Search.js
var require_Search = __commonJS({
  "node_modules/@mui/icons-material/Search.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"
    }), "Search");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/SearchOff.js
var require_SearchOff = __commonJS({
  "node_modules/@mui/icons-material/SearchOff.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)([(0, _jsxRuntime.jsx)("path", {
      d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3 6.08 3 3.28 5.64 3.03 9h2.02C5.3 6.75 7.18 5 9.5 5 11.99 5 14 7.01 14 9.5S11.99 14 9.5 14c-.17 0-.33-.03-.5-.05v2.02c.17.02.33.03.5.03 1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5z"
    }, "0"), (0, _jsxRuntime.jsx)("path", {
      d: "M6.47 10.82 4 13.29l-2.47-2.47-.71.71L3.29 14 .82 16.47l.71.71L4 14.71l2.47 2.47.71-.71L4.71 14l2.47-2.47z"
    }, "1")], "SearchOff");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/Sort.js
var require_Sort = __commonJS({
  "node_modules/@mui/icons-material/Sort.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M3 18h6v-2H3v2zM3 6v2h18V6H3zm0 7h12v-2H3v2z"
    }), "Sort");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/ViewColumn.js
var require_ViewColumn = __commonJS({
  "node_modules/@mui/icons-material/ViewColumn.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M14.67 5v14H9.33V5h5.34zm1 14H21V5h-5.33v14zm-7.34 0V5H3v14h5.33z"
    }), "ViewColumn");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/VisibilityOff.js
var require_VisibilityOff = __commonJS({
  "node_modules/@mui/icons-material/VisibilityOff.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78 3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"
    }), "VisibilityOff");
    exports.default = _default;
  }
});

// node_modules/material-react-table/dist/esm/material-react-table.esm.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());

// node_modules/@tanstack/react-table/build/lib/index.mjs
var React = __toESM(require_react(), 1);

// node_modules/@tanstack/table-core/build/lib/index.mjs
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function makeStateUpdater(key, instance) {
  return (updater) => {
    instance.setState((old) => {
      return {
        ...old,
        [key]: functionalUpdate(updater, old[key])
      };
    });
  };
}
function isFunction(d) {
  return d instanceof Function;
}
function isNumberArray(d) {
  return Array.isArray(d) && d.every((val) => typeof val === "number");
}
function flattenBy(arr, getChildren) {
  const flat = [];
  const recurse = (subArr) => {
    subArr.forEach((item) => {
      flat.push(item);
      const children = getChildren(item);
      if (children != null && children.length) {
        recurse(children);
      }
    });
  };
  recurse(arr);
  return flat;
}
function memo(getDeps, fn, opts) {
  let deps = [];
  let result;
  return () => {
    let depTime;
    if (opts.key && opts.debug)
      depTime = Date.now();
    const newDeps = getDeps();
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    let resultTime;
    if (opts.key && opts.debug)
      resultTime = Date.now();
    result = fn(...newDeps);
    opts == null ? void 0 : opts.onChange == null ? void 0 : opts.onChange(result);
    if (opts.key && opts.debug) {
      if (opts != null && opts.debug()) {
        const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
        const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
        const resultFpsPercentage = resultEndTime / 16;
        const pad = (str, num) => {
          str = String(str);
          while (str.length < num) {
            str = " " + str;
          }
          return str;
        };
        console.info(`%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);
      }
    }
    return result;
  };
}
function createColumn(table, columnDef, depth, parent) {
  var _ref, _resolvedColumnDef$id;
  const defaultColumn = table._getDefaultColumnDef();
  const resolvedColumnDef = {
    ...defaultColumn,
    ...columnDef
  };
  const accessorKey = resolvedColumnDef.accessorKey;
  let id = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? accessorKey.replace(".", "_") : void 0) != null ? _ref : typeof resolvedColumnDef.header === "string" ? resolvedColumnDef.header : void 0;
  let accessorFn;
  if (resolvedColumnDef.accessorFn) {
    accessorFn = resolvedColumnDef.accessorFn;
  } else if (accessorKey) {
    if (accessorKey.includes(".")) {
      accessorFn = (originalRow) => {
        let result = originalRow;
        for (const key of accessorKey.split(".")) {
          var _result;
          result = (_result = result) == null ? void 0 : _result[key];
          if (result === void 0) {
            console.warn(`"${key}" in deeply nested key "${accessorKey}" returned undefined.`);
          }
        }
        return result;
      };
    } else {
      accessorFn = (originalRow) => originalRow[resolvedColumnDef.accessorKey];
    }
  }
  if (!id) {
    if (true) {
      throw new Error(resolvedColumnDef.accessorFn ? `Columns require an id when using an accessorFn` : `Columns require an id when using a non-string header`);
    }
    throw new Error();
  }
  let column = {
    id: `${String(id)}`,
    accessorFn,
    parent,
    depth,
    columnDef: resolvedColumnDef,
    columns: [],
    getFlatColumns: memo(() => [true], () => {
      var _column$columns;
      return [column, ...(_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap((d) => d.getFlatColumns())];
    }, {
      key: false,
      debug: () => {
        var _table$options$debugA;
        return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugColumns;
      }
    }),
    getLeafColumns: memo(() => [table._getOrderColumnsFn()], (orderColumns2) => {
      var _column$columns2;
      if ((_column$columns2 = column.columns) != null && _column$columns2.length) {
        let leafColumns = column.columns.flatMap((column2) => column2.getLeafColumns());
        return orderColumns2(leafColumns);
      }
      return [column];
    }, {
      key: false,
      debug: () => {
        var _table$options$debugA2;
        return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugColumns;
      }
    })
  };
  column = table._features.reduce((obj, feature) => {
    return Object.assign(obj, feature.createColumn == null ? void 0 : feature.createColumn(column, table));
  }, column);
  return column;
}
function createHeader(table, column, options) {
  var _options$id;
  const id = (_options$id = options.id) != null ? _options$id : column.id;
  let header = {
    id,
    column,
    index: options.index,
    isPlaceholder: !!options.isPlaceholder,
    placeholderId: options.placeholderId,
    depth: options.depth,
    subHeaders: [],
    colSpan: 0,
    rowSpan: 0,
    headerGroup: null,
    getLeafHeaders: () => {
      const leafHeaders = [];
      const recurseHeader = (h) => {
        if (h.subHeaders && h.subHeaders.length) {
          h.subHeaders.map(recurseHeader);
        }
        leafHeaders.push(h);
      };
      recurseHeader(header);
      return leafHeaders;
    },
    getContext: () => ({
      table,
      header,
      column
    })
  };
  table._features.forEach((feature) => {
    Object.assign(header, feature.createHeader == null ? void 0 : feature.createHeader(header, table));
  });
  return header;
}
var Headers = {
  createTable: (table) => {
    return {
      // Header Groups
      getHeaderGroups: memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
        var _left$map$filter, _right$map$filter;
        const leftColumns = (_left$map$filter = left == null ? void 0 : left.map((columnId) => leafColumns.find((d) => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];
        const rightColumns = (_right$map$filter = right == null ? void 0 : right.map((columnId) => leafColumns.find((d) => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];
        const centerColumns = leafColumns.filter((column) => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
        const headerGroups = buildHeaderGroups(allColumns, [...leftColumns, ...centerColumns, ...rightColumns], table);
        return headerGroups;
      }, {
        key: "getHeaderGroups",
        debug: () => {
          var _table$options$debugA;
          return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugHeaders;
        }
      }),
      getCenterHeaderGroups: memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
        leafColumns = leafColumns.filter((column) => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
        return buildHeaderGroups(allColumns, leafColumns, table, "center");
      }, {
        key: "getCenterHeaderGroups",
        debug: () => {
          var _table$options$debugA2;
          return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugHeaders;
        }
      }),
      getLeftHeaderGroups: memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left], (allColumns, leafColumns, left) => {
        var _left$map$filter2;
        const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map((columnId) => leafColumns.find((d) => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];
        return buildHeaderGroups(allColumns, orderedLeafColumns, table, "left");
      }, {
        key: "getLeftHeaderGroups",
        debug: () => {
          var _table$options$debugA3;
          return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugHeaders;
        }
      }),
      getRightHeaderGroups: memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.right], (allColumns, leafColumns, right) => {
        var _right$map$filter2;
        const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map((columnId) => leafColumns.find((d) => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];
        return buildHeaderGroups(allColumns, orderedLeafColumns, table, "right");
      }, {
        key: "getRightHeaderGroups",
        debug: () => {
          var _table$options$debugA4;
          return (_table$options$debugA4 = table.options.debugAll) != null ? _table$options$debugA4 : table.options.debugHeaders;
        }
      }),
      // Footer Groups
      getFooterGroups: memo(() => [table.getHeaderGroups()], (headerGroups) => {
        return [...headerGroups].reverse();
      }, {
        key: "getFooterGroups",
        debug: () => {
          var _table$options$debugA5;
          return (_table$options$debugA5 = table.options.debugAll) != null ? _table$options$debugA5 : table.options.debugHeaders;
        }
      }),
      getLeftFooterGroups: memo(() => [table.getLeftHeaderGroups()], (headerGroups) => {
        return [...headerGroups].reverse();
      }, {
        key: "getLeftFooterGroups",
        debug: () => {
          var _table$options$debugA6;
          return (_table$options$debugA6 = table.options.debugAll) != null ? _table$options$debugA6 : table.options.debugHeaders;
        }
      }),
      getCenterFooterGroups: memo(() => [table.getCenterHeaderGroups()], (headerGroups) => {
        return [...headerGroups].reverse();
      }, {
        key: "getCenterFooterGroups",
        debug: () => {
          var _table$options$debugA7;
          return (_table$options$debugA7 = table.options.debugAll) != null ? _table$options$debugA7 : table.options.debugHeaders;
        }
      }),
      getRightFooterGroups: memo(() => [table.getRightHeaderGroups()], (headerGroups) => {
        return [...headerGroups].reverse();
      }, {
        key: "getRightFooterGroups",
        debug: () => {
          var _table$options$debugA8;
          return (_table$options$debugA8 = table.options.debugAll) != null ? _table$options$debugA8 : table.options.debugHeaders;
        }
      }),
      // Flat Headers
      getFlatHeaders: memo(() => [table.getHeaderGroups()], (headerGroups) => {
        return headerGroups.map((headerGroup) => {
          return headerGroup.headers;
        }).flat();
      }, {
        key: "getFlatHeaders",
        debug: () => {
          var _table$options$debugA9;
          return (_table$options$debugA9 = table.options.debugAll) != null ? _table$options$debugA9 : table.options.debugHeaders;
        }
      }),
      getLeftFlatHeaders: memo(() => [table.getLeftHeaderGroups()], (left) => {
        return left.map((headerGroup) => {
          return headerGroup.headers;
        }).flat();
      }, {
        key: "getLeftFlatHeaders",
        debug: () => {
          var _table$options$debugA10;
          return (_table$options$debugA10 = table.options.debugAll) != null ? _table$options$debugA10 : table.options.debugHeaders;
        }
      }),
      getCenterFlatHeaders: memo(() => [table.getCenterHeaderGroups()], (left) => {
        return left.map((headerGroup) => {
          return headerGroup.headers;
        }).flat();
      }, {
        key: "getCenterFlatHeaders",
        debug: () => {
          var _table$options$debugA11;
          return (_table$options$debugA11 = table.options.debugAll) != null ? _table$options$debugA11 : table.options.debugHeaders;
        }
      }),
      getRightFlatHeaders: memo(() => [table.getRightHeaderGroups()], (left) => {
        return left.map((headerGroup) => {
          return headerGroup.headers;
        }).flat();
      }, {
        key: "getRightFlatHeaders",
        debug: () => {
          var _table$options$debugA12;
          return (_table$options$debugA12 = table.options.debugAll) != null ? _table$options$debugA12 : table.options.debugHeaders;
        }
      }),
      // Leaf Headers
      getCenterLeafHeaders: memo(() => [table.getCenterFlatHeaders()], (flatHeaders) => {
        return flatHeaders.filter((header) => {
          var _header$subHeaders;
          return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);
        });
      }, {
        key: "getCenterLeafHeaders",
        debug: () => {
          var _table$options$debugA13;
          return (_table$options$debugA13 = table.options.debugAll) != null ? _table$options$debugA13 : table.options.debugHeaders;
        }
      }),
      getLeftLeafHeaders: memo(() => [table.getLeftFlatHeaders()], (flatHeaders) => {
        return flatHeaders.filter((header) => {
          var _header$subHeaders2;
          return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);
        });
      }, {
        key: "getLeftLeafHeaders",
        debug: () => {
          var _table$options$debugA14;
          return (_table$options$debugA14 = table.options.debugAll) != null ? _table$options$debugA14 : table.options.debugHeaders;
        }
      }),
      getRightLeafHeaders: memo(() => [table.getRightFlatHeaders()], (flatHeaders) => {
        return flatHeaders.filter((header) => {
          var _header$subHeaders3;
          return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);
        });
      }, {
        key: "getRightLeafHeaders",
        debug: () => {
          var _table$options$debugA15;
          return (_table$options$debugA15 = table.options.debugAll) != null ? _table$options$debugA15 : table.options.debugHeaders;
        }
      }),
      getLeafHeaders: memo(() => [table.getLeftHeaderGroups(), table.getCenterHeaderGroups(), table.getRightHeaderGroups()], (left, center, right) => {
        var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;
        return [...(_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : [], ...(_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : [], ...(_right$0$headers = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : []].map((header) => {
          return header.getLeafHeaders();
        }).flat();
      }, {
        key: "getLeafHeaders",
        debug: () => {
          var _table$options$debugA16;
          return (_table$options$debugA16 = table.options.debugAll) != null ? _table$options$debugA16 : table.options.debugHeaders;
        }
      })
    };
  }
};
function buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {
  var _headerGroups$0$heade, _headerGroups$;
  let maxDepth = 0;
  const findMaxDepth = function(columns, depth) {
    if (depth === void 0) {
      depth = 1;
    }
    maxDepth = Math.max(maxDepth, depth);
    columns.filter((column) => column.getIsVisible()).forEach((column) => {
      var _column$columns;
      if ((_column$columns = column.columns) != null && _column$columns.length) {
        findMaxDepth(column.columns, depth + 1);
      }
    }, 0);
  };
  findMaxDepth(allColumns);
  let headerGroups = [];
  const createHeaderGroup = (headersToGroup, depth) => {
    const headerGroup = {
      depth,
      id: [headerFamily, `${depth}`].filter(Boolean).join("_"),
      headers: []
    };
    const pendingParentHeaders = [];
    headersToGroup.forEach((headerToGroup) => {
      const latestPendingParentHeader = [...pendingParentHeaders].reverse()[0];
      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;
      let column;
      let isPlaceholder = false;
      if (isLeafHeader && headerToGroup.column.parent) {
        column = headerToGroup.column.parent;
      } else {
        column = headerToGroup.column;
        isPlaceholder = true;
      }
      if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {
        latestPendingParentHeader.subHeaders.push(headerToGroup);
      } else {
        const header = createHeader(table, column, {
          id: [headerFamily, depth, column.id, headerToGroup == null ? void 0 : headerToGroup.id].filter(Boolean).join("_"),
          isPlaceholder,
          placeholderId: isPlaceholder ? `${pendingParentHeaders.filter((d) => d.column === column).length}` : void 0,
          depth,
          index: pendingParentHeaders.length
        });
        header.subHeaders.push(headerToGroup);
        pendingParentHeaders.push(header);
      }
      headerGroup.headers.push(headerToGroup);
      headerToGroup.headerGroup = headerGroup;
    });
    headerGroups.push(headerGroup);
    if (depth > 0) {
      createHeaderGroup(pendingParentHeaders, depth - 1);
    }
  };
  const bottomHeaders = columnsToGroup.map((column, index) => createHeader(table, column, {
    depth: maxDepth,
    index
  }));
  createHeaderGroup(bottomHeaders, maxDepth - 1);
  headerGroups.reverse();
  const recurseHeadersForSpans = (headers) => {
    const filteredHeaders = headers.filter((header) => header.column.getIsVisible());
    return filteredHeaders.map((header) => {
      let colSpan = 0;
      let rowSpan = 0;
      let childRowSpans = [0];
      if (header.subHeaders && header.subHeaders.length) {
        childRowSpans = [];
        recurseHeadersForSpans(header.subHeaders).forEach((_ref) => {
          let {
            colSpan: childColSpan,
            rowSpan: childRowSpan
          } = _ref;
          colSpan += childColSpan;
          childRowSpans.push(childRowSpan);
        });
      } else {
        colSpan = 1;
      }
      const minChildRowSpan = Math.min(...childRowSpans);
      rowSpan = rowSpan + minChildRowSpan;
      header.colSpan = colSpan;
      header.rowSpan = rowSpan;
      return {
        colSpan,
        rowSpan
      };
    });
  };
  recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);
  return headerGroups;
}
var defaultColumnSizing = {
  size: 150,
  minSize: 20,
  maxSize: Number.MAX_SAFE_INTEGER
};
var getDefaultColumnSizingInfoState = () => ({
  startOffset: null,
  startSize: null,
  deltaOffset: null,
  deltaPercentage: null,
  isResizingColumn: false,
  columnSizingStart: []
});
var ColumnSizing = {
  getDefaultColumnDef: () => {
    return defaultColumnSizing;
  },
  getInitialState: (state) => {
    return {
      columnSizing: {},
      columnSizingInfo: getDefaultColumnSizingInfoState(),
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      columnResizeMode: "onEnd",
      onColumnSizingChange: makeStateUpdater("columnSizing", table),
      onColumnSizingInfoChange: makeStateUpdater("columnSizingInfo", table)
    };
  },
  createColumn: (column, table) => {
    return {
      getSize: () => {
        var _column$columnDef$min, _ref, _column$columnDef$max;
        const columnSize = table.getState().columnSizing[column.id];
        return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);
      },
      getStart: (position) => {
        const columns = !position ? table.getVisibleLeafColumns() : position === "left" ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();
        const index = columns.findIndex((d) => d.id === column.id);
        if (index > 0) {
          const prevSiblingColumn = columns[index - 1];
          return prevSiblingColumn.getStart(position) + prevSiblingColumn.getSize();
        }
        return 0;
      },
      resetSize: () => {
        table.setColumnSizing((_ref2) => {
          let {
            [column.id]: _,
            ...rest
          } = _ref2;
          return rest;
        });
      },
      getCanResize: () => {
        var _column$columnDef$ena, _table$options$enable;
        return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);
      },
      getIsResizing: () => {
        return table.getState().columnSizingInfo.isResizingColumn === column.id;
      }
    };
  },
  createHeader: (header, table) => {
    return {
      getSize: () => {
        let sum2 = 0;
        const recurse = (header2) => {
          if (header2.subHeaders.length) {
            header2.subHeaders.forEach(recurse);
          } else {
            var _header$column$getSiz;
            sum2 += (_header$column$getSiz = header2.column.getSize()) != null ? _header$column$getSiz : 0;
          }
        };
        recurse(header);
        return sum2;
      },
      getStart: () => {
        if (header.index > 0) {
          const prevSiblingHeader = header.headerGroup.headers[header.index - 1];
          return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();
        }
        return 0;
      },
      getResizeHandler: () => {
        const column = table.getColumn(header.column.id);
        const canResize = column == null ? void 0 : column.getCanResize();
        return (e) => {
          if (!column || !canResize) {
            return;
          }
          e.persist == null ? void 0 : e.persist();
          if (isTouchStartEvent(e)) {
            if (e.touches && e.touches.length > 1) {
              return;
            }
          }
          const startSize = header.getSize();
          const columnSizingStart = header ? header.getLeafHeaders().map((d) => [d.column.id, d.column.getSize()]) : [[column.id, column.getSize()]];
          const clientX = isTouchStartEvent(e) ? Math.round(e.touches[0].clientX) : e.clientX;
          const newColumnSizing = {};
          const updateOffset = (eventType, clientXPos) => {
            if (typeof clientXPos !== "number") {
              return;
            }
            table.setColumnSizingInfo((old) => {
              var _old$startOffset, _old$startSize;
              const deltaOffset = clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0);
              const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);
              old.columnSizingStart.forEach((_ref3) => {
                let [columnId, headerSize] = _ref3;
                newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;
              });
              return {
                ...old,
                deltaOffset,
                deltaPercentage
              };
            });
            if (table.options.columnResizeMode === "onChange" || eventType === "end") {
              table.setColumnSizing((old) => ({
                ...old,
                ...newColumnSizing
              }));
            }
          };
          const onMove = (clientXPos) => updateOffset("move", clientXPos);
          const onEnd = (clientXPos) => {
            updateOffset("end", clientXPos);
            table.setColumnSizingInfo((old) => ({
              ...old,
              isResizingColumn: false,
              startOffset: null,
              startSize: null,
              deltaOffset: null,
              deltaPercentage: null,
              columnSizingStart: []
            }));
          };
          const mouseEvents = {
            moveHandler: (e2) => onMove(e2.clientX),
            upHandler: (e2) => {
              document.removeEventListener("mousemove", mouseEvents.moveHandler);
              document.removeEventListener("mouseup", mouseEvents.upHandler);
              onEnd(e2.clientX);
            }
          };
          const touchEvents = {
            moveHandler: (e2) => {
              if (e2.cancelable) {
                e2.preventDefault();
                e2.stopPropagation();
              }
              onMove(e2.touches[0].clientX);
              return false;
            },
            upHandler: (e2) => {
              var _e$touches$;
              document.removeEventListener("touchmove", touchEvents.moveHandler);
              document.removeEventListener("touchend", touchEvents.upHandler);
              if (e2.cancelable) {
                e2.preventDefault();
                e2.stopPropagation();
              }
              onEnd((_e$touches$ = e2.touches[0]) == null ? void 0 : _e$touches$.clientX);
            }
          };
          const passiveIfSupported = passiveEventSupported() ? {
            passive: false
          } : false;
          if (isTouchStartEvent(e)) {
            document.addEventListener("touchmove", touchEvents.moveHandler, passiveIfSupported);
            document.addEventListener("touchend", touchEvents.upHandler, passiveIfSupported);
          } else {
            document.addEventListener("mousemove", mouseEvents.moveHandler, passiveIfSupported);
            document.addEventListener("mouseup", mouseEvents.upHandler, passiveIfSupported);
          }
          table.setColumnSizingInfo((old) => ({
            ...old,
            startOffset: clientX,
            startSize,
            deltaOffset: 0,
            deltaPercentage: 0,
            columnSizingStart,
            isResizingColumn: column.id
          }));
        };
      }
    };
  },
  createTable: (table) => {
    return {
      setColumnSizing: (updater) => table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater),
      setColumnSizingInfo: (updater) => table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater),
      resetColumnSizing: (defaultState) => {
        var _table$initialState$c;
        table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});
      },
      resetHeaderSizeInfo: (defaultState) => {
        var _table$initialState$c2;
        table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());
      },
      getTotalSize: () => {
        var _table$getHeaderGroup, _table$getHeaderGroup2;
        return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup2.headers.reduce((sum2, header) => {
          return sum2 + header.getSize();
        }, 0)) != null ? _table$getHeaderGroup : 0;
      },
      getLeftTotalSize: () => {
        var _table$getLeftHeaderG, _table$getLeftHeaderG2;
        return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG2.headers.reduce((sum2, header) => {
          return sum2 + header.getSize();
        }, 0)) != null ? _table$getLeftHeaderG : 0;
      },
      getCenterTotalSize: () => {
        var _table$getCenterHeade, _table$getCenterHeade2;
        return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade2.headers.reduce((sum2, header) => {
          return sum2 + header.getSize();
        }, 0)) != null ? _table$getCenterHeade : 0;
      },
      getRightTotalSize: () => {
        var _table$getRightHeader, _table$getRightHeader2;
        return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader2.headers.reduce((sum2, header) => {
          return sum2 + header.getSize();
        }, 0)) != null ? _table$getRightHeader : 0;
      }
    };
  }
};
var passiveSupported = null;
function passiveEventSupported() {
  if (typeof passiveSupported === "boolean")
    return passiveSupported;
  let supported = false;
  try {
    const options = {
      get passive() {
        supported = true;
        return false;
      }
    };
    const noop = () => {
    };
    window.addEventListener("test", noop, options);
    window.removeEventListener("test", noop);
  } catch (err) {
    supported = false;
  }
  passiveSupported = supported;
  return passiveSupported;
}
function isTouchStartEvent(e) {
  return e.type === "touchstart";
}
var Expanding = {
  getInitialState: (state) => {
    return {
      expanded: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onExpandedChange: makeStateUpdater("expanded", table),
      paginateExpandedRows: true
    };
  },
  createTable: (table) => {
    let registered = false;
    let queued = false;
    return {
      _autoResetExpanded: () => {
        var _ref, _table$options$autoRe;
        if (!registered) {
          table._queue(() => {
            registered = true;
          });
          return;
        }
        if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {
          if (queued)
            return;
          queued = true;
          table._queue(() => {
            table.resetExpanded();
            queued = false;
          });
        }
      },
      setExpanded: (updater) => table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater),
      toggleAllRowsExpanded: (expanded) => {
        if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {
          table.setExpanded(true);
        } else {
          table.setExpanded({});
        }
      },
      resetExpanded: (defaultState) => {
        var _table$initialState$e, _table$initialState;
        table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _table$initialState$e : {});
      },
      getCanSomeRowsExpand: () => {
        return table.getPrePaginationRowModel().flatRows.some((row) => row.getCanExpand());
      },
      getToggleAllRowsExpandedHandler: () => {
        return (e) => {
          e.persist == null ? void 0 : e.persist();
          table.toggleAllRowsExpanded();
        };
      },
      getIsSomeRowsExpanded: () => {
        const expanded = table.getState().expanded;
        return expanded === true || Object.values(expanded).some(Boolean);
      },
      getIsAllRowsExpanded: () => {
        const expanded = table.getState().expanded;
        if (typeof expanded === "boolean") {
          return expanded === true;
        }
        if (!Object.keys(expanded).length) {
          return false;
        }
        if (table.getRowModel().flatRows.some((row) => !row.getIsExpanded())) {
          return false;
        }
        return true;
      },
      getExpandedDepth: () => {
        let maxDepth = 0;
        const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);
        rowIds.forEach((id) => {
          const splitId = id.split(".");
          maxDepth = Math.max(maxDepth, splitId.length);
        });
        return maxDepth;
      },
      getPreExpandedRowModel: () => table.getSortedRowModel(),
      getExpandedRowModel: () => {
        if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {
          table._getExpandedRowModel = table.options.getExpandedRowModel(table);
        }
        if (table.options.manualExpanding || !table._getExpandedRowModel) {
          return table.getPreExpandedRowModel();
        }
        return table._getExpandedRowModel();
      }
    };
  },
  createRow: (row, table) => {
    return {
      toggleExpanded: (expanded) => {
        table.setExpanded((old) => {
          var _expanded;
          const exists = old === true ? true : !!(old != null && old[row.id]);
          let oldExpanded = {};
          if (old === true) {
            Object.keys(table.getRowModel().rowsById).forEach((rowId) => {
              oldExpanded[rowId] = true;
            });
          } else {
            oldExpanded = old;
          }
          expanded = (_expanded = expanded) != null ? _expanded : !exists;
          if (!exists && expanded) {
            return {
              ...oldExpanded,
              [row.id]: true
            };
          }
          if (exists && !expanded) {
            const {
              [row.id]: _,
              ...rest
            } = oldExpanded;
            return rest;
          }
          return old;
        });
      },
      getIsExpanded: () => {
        var _table$options$getIsR;
        const expanded = table.getState().expanded;
        return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded === true || (expanded == null ? void 0 : expanded[row.id]));
      },
      getCanExpand: () => {
        var _table$options$getRow, _table$options$enable, _row$subRows;
        return (_table$options$getRow = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
      },
      getToggleExpandedHandler: () => {
        const canExpand = row.getCanExpand();
        return () => {
          if (!canExpand)
            return;
          row.toggleExpanded();
        };
      }
    };
  }
};
var includesString = (row, columnId, filterValue) => {
  var _row$getValue, _row$getValue$toStrin, _row$getValue$toStrin2;
  const search = filterValue.toLowerCase();
  return Boolean((_row$getValue = row.getValue(columnId)) == null ? void 0 : (_row$getValue$toStrin = _row$getValue.toString()) == null ? void 0 : (_row$getValue$toStrin2 = _row$getValue$toStrin.toLowerCase()) == null ? void 0 : _row$getValue$toStrin2.includes(search));
};
includesString.autoRemove = (val) => testFalsey(val);
var includesStringSensitive = (row, columnId, filterValue) => {
  var _row$getValue2, _row$getValue2$toStri;
  return Boolean((_row$getValue2 = row.getValue(columnId)) == null ? void 0 : (_row$getValue2$toStri = _row$getValue2.toString()) == null ? void 0 : _row$getValue2$toStri.includes(filterValue));
};
includesStringSensitive.autoRemove = (val) => testFalsey(val);
var equalsString = (row, columnId, filterValue) => {
  var _row$getValue3, _row$getValue3$toStri;
  return ((_row$getValue3 = row.getValue(columnId)) == null ? void 0 : (_row$getValue3$toStri = _row$getValue3.toString()) == null ? void 0 : _row$getValue3$toStri.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());
};
equalsString.autoRemove = (val) => testFalsey(val);
var arrIncludes = (row, columnId, filterValue) => {
  var _row$getValue4;
  return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);
};
arrIncludes.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
var arrIncludesAll = (row, columnId, filterValue) => {
  return !filterValue.some((val) => {
    var _row$getValue5;
    return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));
  });
};
arrIncludesAll.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
var arrIncludesSome = (row, columnId, filterValue) => {
  return filterValue.some((val) => {
    var _row$getValue6;
    return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);
  });
};
arrIncludesSome.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
var equals = (row, columnId, filterValue) => {
  return row.getValue(columnId) === filterValue;
};
equals.autoRemove = (val) => testFalsey(val);
var weakEquals = (row, columnId, filterValue) => {
  return row.getValue(columnId) == filterValue;
};
weakEquals.autoRemove = (val) => testFalsey(val);
var inNumberRange = (row, columnId, filterValue) => {
  let [min2, max2] = filterValue;
  const rowValue = row.getValue(columnId);
  return rowValue >= min2 && rowValue <= max2;
};
inNumberRange.resolveFilterValue = (val) => {
  let [unsafeMin, unsafeMax] = val;
  let parsedMin = typeof unsafeMin !== "number" ? parseFloat(unsafeMin) : unsafeMin;
  let parsedMax = typeof unsafeMax !== "number" ? parseFloat(unsafeMax) : unsafeMax;
  let min2 = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;
  let max2 = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;
  if (min2 > max2) {
    const temp = min2;
    min2 = max2;
    max2 = temp;
  }
  return [min2, max2];
};
inNumberRange.autoRemove = (val) => testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);
var filterFns = {
  includesString,
  includesStringSensitive,
  equalsString,
  arrIncludes,
  arrIncludesAll,
  arrIncludesSome,
  equals,
  weakEquals,
  inNumberRange
};
function testFalsey(val) {
  return val === void 0 || val === null || val === "";
}
var Filters = {
  getDefaultColumnDef: () => {
    return {
      filterFn: "auto"
    };
  },
  getInitialState: (state) => {
    return {
      columnFilters: [],
      globalFilter: void 0,
      // filtersProgress: 1,
      // facetProgress: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnFiltersChange: makeStateUpdater("columnFilters", table),
      onGlobalFilterChange: makeStateUpdater("globalFilter", table),
      filterFromLeafRows: false,
      maxLeafRowFilterDepth: 100,
      globalFilterFn: "auto",
      getColumnCanGlobalFilter: (column) => {
        var _table$getCoreRowMode, _table$getCoreRowMode2;
        const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null ? void 0 : (_table$getCoreRowMode2 = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? void 0 : _table$getCoreRowMode2.getValue();
        return typeof value === "string" || typeof value === "number";
      }
    };
  },
  createColumn: (column, table) => {
    return {
      getAutoFilterFn: () => {
        const firstRow = table.getCoreRowModel().flatRows[0];
        const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
        if (typeof value === "string") {
          return filterFns.includesString;
        }
        if (typeof value === "number") {
          return filterFns.inNumberRange;
        }
        if (typeof value === "boolean") {
          return filterFns.equals;
        }
        if (value !== null && typeof value === "object") {
          return filterFns.equals;
        }
        if (Array.isArray(value)) {
          return filterFns.arrIncludes;
        }
        return filterFns.weakEquals;
      },
      getFilterFn: () => {
        var _table$options$filter, _table$options$filter2;
        return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === "auto" ? column.getAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[column.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column.columnDef.filterFn];
      },
      getCanFilter: () => {
        var _column$columnDef$ena, _table$options$enable, _table$options$enable2;
        return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column.accessorFn;
      },
      getCanGlobalFilter: () => {
        var _column$columnDef$ena2, _table$options$enable3, _table$options$enable4, _table$options$getCol;
        return ((_column$columnDef$ena2 = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena2 : true) && ((_table$options$enable3 = table.options.enableGlobalFilter) != null ? _table$options$enable3 : true) && ((_table$options$enable4 = table.options.enableFilters) != null ? _table$options$enable4 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column)) != null ? _table$options$getCol : true) && !!column.accessorFn;
      },
      getIsFiltered: () => column.getFilterIndex() > -1,
      getFilterValue: () => {
        var _table$getState$colum, _table$getState$colum2;
        return (_table$getState$colum = table.getState().columnFilters) == null ? void 0 : (_table$getState$colum2 = _table$getState$colum.find((d) => d.id === column.id)) == null ? void 0 : _table$getState$colum2.value;
      },
      getFilterIndex: () => {
        var _table$getState$colum3, _table$getState$colum4;
        return (_table$getState$colum3 = (_table$getState$colum4 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum4.findIndex((d) => d.id === column.id)) != null ? _table$getState$colum3 : -1;
      },
      setFilterValue: (value) => {
        table.setColumnFilters((old) => {
          const filterFn = column.getFilterFn();
          const previousfilter = old == null ? void 0 : old.find((d) => d.id === column.id);
          const newFilter = functionalUpdate(value, previousfilter ? previousfilter.value : void 0);
          if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {
            var _old$filter;
            return (_old$filter = old == null ? void 0 : old.filter((d) => d.id !== column.id)) != null ? _old$filter : [];
          }
          const newFilterObj = {
            id: column.id,
            value: newFilter
          };
          if (previousfilter) {
            var _old$map;
            return (_old$map = old == null ? void 0 : old.map((d) => {
              if (d.id === column.id) {
                return newFilterObj;
              }
              return d;
            })) != null ? _old$map : [];
          }
          if (old != null && old.length) {
            return [...old, newFilterObj];
          }
          return [newFilterObj];
        });
      },
      _getFacetedRowModel: table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id),
      getFacetedRowModel: () => {
        if (!column._getFacetedRowModel) {
          return table.getPreFilteredRowModel();
        }
        return column._getFacetedRowModel();
      },
      _getFacetedUniqueValues: table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id),
      getFacetedUniqueValues: () => {
        if (!column._getFacetedUniqueValues) {
          return /* @__PURE__ */ new Map();
        }
        return column._getFacetedUniqueValues();
      },
      _getFacetedMinMaxValues: table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id),
      getFacetedMinMaxValues: () => {
        if (!column._getFacetedMinMaxValues) {
          return void 0;
        }
        return column._getFacetedMinMaxValues();
      }
      // () => [column.getFacetedRowModel()],
      // facetedRowModel => getRowModelMinMaxValues(facetedRowModel, column.id),
    };
  },
  createRow: (row, table) => {
    return {
      columnFilters: {},
      columnFiltersMeta: {}
    };
  },
  createTable: (table) => {
    return {
      getGlobalAutoFilterFn: () => {
        return filterFns.includesString;
      },
      getGlobalFilterFn: () => {
        var _table$options$filter3, _table$options$filter4;
        const {
          globalFilterFn
        } = table.options;
        return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === "auto" ? table.getGlobalAutoFilterFn() : (_table$options$filter3 = (_table$options$filter4 = table.options.filterFns) == null ? void 0 : _table$options$filter4[globalFilterFn]) != null ? _table$options$filter3 : filterFns[globalFilterFn];
      },
      setColumnFilters: (updater) => {
        const leafColumns = table.getAllLeafColumns();
        const updateFn = (old) => {
          var _functionalUpdate;
          return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter((filter) => {
            const column = leafColumns.find((d) => d.id === filter.id);
            if (column) {
              const filterFn = column.getFilterFn();
              if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {
                return false;
              }
            }
            return true;
          });
        };
        table.options.onColumnFiltersChange == null ? void 0 : table.options.onColumnFiltersChange(updateFn);
      },
      setGlobalFilter: (updater) => {
        table.options.onGlobalFilterChange == null ? void 0 : table.options.onGlobalFilterChange(updater);
      },
      resetGlobalFilter: (defaultState) => {
        table.setGlobalFilter(defaultState ? void 0 : table.initialState.globalFilter);
      },
      resetColumnFilters: (defaultState) => {
        var _table$initialState$c, _table$initialState;
        table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _table$initialState$c : []);
      },
      getPreFilteredRowModel: () => table.getCoreRowModel(),
      getFilteredRowModel: () => {
        if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {
          table._getFilteredRowModel = table.options.getFilteredRowModel(table);
        }
        if (table.options.manualFiltering || !table._getFilteredRowModel) {
          return table.getPreFilteredRowModel();
        }
        return table._getFilteredRowModel();
      },
      _getGlobalFacetedRowModel: table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, "__global__"),
      getGlobalFacetedRowModel: () => {
        if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {
          return table.getPreFilteredRowModel();
        }
        return table._getGlobalFacetedRowModel();
      },
      _getGlobalFacetedUniqueValues: table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, "__global__"),
      getGlobalFacetedUniqueValues: () => {
        if (!table._getGlobalFacetedUniqueValues) {
          return /* @__PURE__ */ new Map();
        }
        return table._getGlobalFacetedUniqueValues();
      },
      _getGlobalFacetedMinMaxValues: table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, "__global__"),
      getGlobalFacetedMinMaxValues: () => {
        if (!table._getGlobalFacetedMinMaxValues) {
          return;
        }
        return table._getGlobalFacetedMinMaxValues();
      }
    };
  }
};
function shouldAutoRemoveFilter(filterFn, value, column) {
  return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === "undefined" || typeof value === "string" && !value;
}
var sum = (columnId, _leafRows, childRows) => {
  return childRows.reduce((sum2, next) => {
    const nextValue = next.getValue(columnId);
    return sum2 + (typeof nextValue === "number" ? nextValue : 0);
  }, 0);
};
var min = (columnId, _leafRows, childRows) => {
  let min2;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
      min2 = value;
    }
  });
  return min2;
};
var max = (columnId, _leafRows, childRows) => {
  let max2;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
      max2 = value;
    }
  });
  return max2;
};
var extent = (columnId, _leafRows, childRows) => {
  let min2;
  let max2;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null) {
      if (min2 === void 0) {
        if (value >= value)
          min2 = max2 = value;
      } else {
        if (min2 > value)
          min2 = value;
        if (max2 < value)
          max2 = value;
      }
    }
  });
  return [min2, max2];
};
var mean = (columnId, leafRows) => {
  let count2 = 0;
  let sum2 = 0;
  leafRows.forEach((row) => {
    let value = row.getValue(columnId);
    if (value != null && (value = +value) >= value) {
      ++count2, sum2 += value;
    }
  });
  if (count2)
    return sum2 / count2;
  return;
};
var median = (columnId, leafRows) => {
  if (!leafRows.length) {
    return;
  }
  const values = leafRows.map((row) => row.getValue(columnId));
  if (!isNumberArray(values)) {
    return;
  }
  if (values.length === 1) {
    return values[0];
  }
  const mid = Math.floor(values.length / 2);
  const nums = values.sort((a, b) => a - b);
  return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;
};
var unique = (columnId, leafRows) => {
  return Array.from(new Set(leafRows.map((d) => d.getValue(columnId))).values());
};
var uniqueCount = (columnId, leafRows) => {
  return new Set(leafRows.map((d) => d.getValue(columnId))).size;
};
var count = (_columnId, leafRows) => {
  return leafRows.length;
};
var aggregationFns = {
  sum,
  min,
  max,
  extent,
  mean,
  median,
  unique,
  uniqueCount,
  count
};
var Grouping = {
  getDefaultColumnDef: () => {
    return {
      aggregatedCell: (props) => {
        var _toString, _props$getValue;
        return (_toString = (_props$getValue = props.getValue()) == null ? void 0 : _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _toString : null;
      },
      aggregationFn: "auto"
    };
  },
  getInitialState: (state) => {
    return {
      grouping: [],
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onGroupingChange: makeStateUpdater("grouping", table),
      groupedColumnMode: "reorder"
    };
  },
  createColumn: (column, table) => {
    return {
      toggleGrouping: () => {
        table.setGrouping((old) => {
          if (old != null && old.includes(column.id)) {
            return old.filter((d) => d !== column.id);
          }
          return [...old != null ? old : [], column.id];
        });
      },
      getCanGroup: () => {
        var _ref, _ref2, _ref3, _column$columnDef$ena;
        return (_ref = (_ref2 = (_ref3 = (_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) != null ? _ref3 : table.options.enableGrouping) != null ? _ref2 : true) != null ? _ref : !!column.accessorFn;
      },
      getIsGrouped: () => {
        var _table$getState$group;
        return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column.id);
      },
      getGroupedIndex: () => {
        var _table$getState$group2;
        return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column.id);
      },
      getToggleGroupingHandler: () => {
        const canGroup = column.getCanGroup();
        return () => {
          if (!canGroup)
            return;
          column.toggleGrouping();
        };
      },
      getAutoAggregationFn: () => {
        const firstRow = table.getCoreRowModel().flatRows[0];
        const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
        if (typeof value === "number") {
          return aggregationFns.sum;
        }
        if (Object.prototype.toString.call(value) === "[object Date]") {
          return aggregationFns.extent;
        }
      },
      getAggregationFn: () => {
        var _table$options$aggreg, _table$options$aggreg2;
        if (!column) {
          throw new Error();
        }
        return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === "auto" ? column.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg2[column.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column.columnDef.aggregationFn];
      }
    };
  },
  createTable: (table) => {
    return {
      setGrouping: (updater) => table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater),
      resetGrouping: (defaultState) => {
        var _table$initialState$g, _table$initialState;
        table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _table$initialState$g : []);
      },
      getPreGroupedRowModel: () => table.getFilteredRowModel(),
      getGroupedRowModel: () => {
        if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {
          table._getGroupedRowModel = table.options.getGroupedRowModel(table);
        }
        if (table.options.manualGrouping || !table._getGroupedRowModel) {
          return table.getPreGroupedRowModel();
        }
        return table._getGroupedRowModel();
      }
    };
  },
  createRow: (row, table) => {
    return {
      getIsGrouped: () => !!row.groupingColumnId,
      getGroupingValue: (columnId) => {
        if (row._groupingValuesCache.hasOwnProperty(columnId)) {
          return row._groupingValuesCache[columnId];
        }
        const column = table.getColumn(columnId);
        if (!(column != null && column.columnDef.getGroupingValue)) {
          return row.getValue(columnId);
        }
        row._groupingValuesCache[columnId] = column.columnDef.getGroupingValue(row.original);
        return row._groupingValuesCache[columnId];
      },
      _groupingValuesCache: {}
    };
  },
  createCell: (cell, column, row, table) => {
    return {
      getIsGrouped: () => column.getIsGrouped() && column.id === row.groupingColumnId,
      getIsPlaceholder: () => !cell.getIsGrouped() && column.getIsGrouped(),
      getIsAggregated: () => {
        var _row$subRows;
        return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
      }
    };
  }
};
function orderColumns(leafColumns, grouping, groupedColumnMode) {
  if (!(grouping != null && grouping.length) || !groupedColumnMode) {
    return leafColumns;
  }
  const nonGroupingColumns = leafColumns.filter((col) => !grouping.includes(col.id));
  if (groupedColumnMode === "remove") {
    return nonGroupingColumns;
  }
  const groupingColumns = grouping.map((g) => leafColumns.find((col) => col.id === g)).filter(Boolean);
  return [...groupingColumns, ...nonGroupingColumns];
}
var Ordering = {
  getInitialState: (state) => {
    return {
      columnOrder: [],
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnOrderChange: makeStateUpdater("columnOrder", table)
    };
  },
  createTable: (table) => {
    return {
      setColumnOrder: (updater) => table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater),
      resetColumnOrder: (defaultState) => {
        var _table$initialState$c;
        table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);
      },
      _getOrderColumnsFn: memo(() => [table.getState().columnOrder, table.getState().grouping, table.options.groupedColumnMode], (columnOrder, grouping, groupedColumnMode) => (columns) => {
        let orderedColumns = [];
        if (!(columnOrder != null && columnOrder.length)) {
          orderedColumns = columns;
        } else {
          const columnOrderCopy = [...columnOrder];
          const columnsCopy = [...columns];
          while (columnsCopy.length && columnOrderCopy.length) {
            const targetColumnId = columnOrderCopy.shift();
            const foundIndex = columnsCopy.findIndex((d) => d.id === targetColumnId);
            if (foundIndex > -1) {
              orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);
            }
          }
          orderedColumns = [...orderedColumns, ...columnsCopy];
        }
        return orderColumns(orderedColumns, grouping, groupedColumnMode);
      }, {
        key: "getOrderColumnsFn"
        // debug: () => table.options.debugAll ?? table.options.debugTable,
      })
    };
  }
};
var defaultPageIndex = 0;
var defaultPageSize = 10;
var getDefaultPaginationState = () => ({
  pageIndex: defaultPageIndex,
  pageSize: defaultPageSize
});
var Pagination = {
  getInitialState: (state) => {
    return {
      ...state,
      pagination: {
        ...getDefaultPaginationState(),
        ...state == null ? void 0 : state.pagination
      }
    };
  },
  getDefaultOptions: (table) => {
    return {
      onPaginationChange: makeStateUpdater("pagination", table)
    };
  },
  createTable: (table) => {
    let registered = false;
    let queued = false;
    return {
      _autoResetPageIndex: () => {
        var _ref, _table$options$autoRe;
        if (!registered) {
          table._queue(() => {
            registered = true;
          });
          return;
        }
        if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {
          if (queued)
            return;
          queued = true;
          table._queue(() => {
            table.resetPageIndex();
            queued = false;
          });
        }
      },
      setPagination: (updater) => {
        const safeUpdater = (old) => {
          let newState = functionalUpdate(updater, old);
          return newState;
        };
        return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);
      },
      resetPagination: (defaultState) => {
        var _table$initialState$p;
        table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());
      },
      setPageIndex: (updater) => {
        table.setPagination((old) => {
          let pageIndex = functionalUpdate(updater, old.pageIndex);
          const maxPageIndex = typeof table.options.pageCount === "undefined" || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;
          pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));
          return {
            ...old,
            pageIndex
          };
        });
      },
      resetPageIndex: (defaultState) => {
        var _table$initialState$p2, _table$initialState, _table$initialState$p3;
        table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null ? void 0 : (_table$initialState$p3 = _table$initialState.pagination) == null ? void 0 : _table$initialState$p3.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);
      },
      resetPageSize: (defaultState) => {
        var _table$initialState$p4, _table$initialState2, _table$initialState2$;
        table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p4 = (_table$initialState2 = table.initialState) == null ? void 0 : (_table$initialState2$ = _table$initialState2.pagination) == null ? void 0 : _table$initialState2$.pageSize) != null ? _table$initialState$p4 : defaultPageSize);
      },
      setPageSize: (updater) => {
        table.setPagination((old) => {
          const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));
          const topRowIndex = old.pageSize * old.pageIndex;
          const pageIndex = Math.floor(topRowIndex / pageSize);
          return {
            ...old,
            pageIndex,
            pageSize
          };
        });
      },
      setPageCount: (updater) => table.setPagination((old) => {
        var _table$options$pageCo;
        let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);
        if (typeof newPageCount === "number") {
          newPageCount = Math.max(-1, newPageCount);
        }
        return {
          ...old,
          pageCount: newPageCount
        };
      }),
      getPageOptions: memo(() => [table.getPageCount()], (pageCount) => {
        let pageOptions = [];
        if (pageCount && pageCount > 0) {
          pageOptions = [...new Array(pageCount)].fill(null).map((_, i) => i);
        }
        return pageOptions;
      }, {
        key: "getPageOptions",
        debug: () => {
          var _table$options$debugA;
          return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;
        }
      }),
      getCanPreviousPage: () => table.getState().pagination.pageIndex > 0,
      getCanNextPage: () => {
        const {
          pageIndex
        } = table.getState().pagination;
        const pageCount = table.getPageCount();
        if (pageCount === -1) {
          return true;
        }
        if (pageCount === 0) {
          return false;
        }
        return pageIndex < pageCount - 1;
      },
      previousPage: () => {
        return table.setPageIndex((old) => old - 1);
      },
      nextPage: () => {
        return table.setPageIndex((old) => {
          return old + 1;
        });
      },
      getPrePaginationRowModel: () => table.getExpandedRowModel(),
      getPaginationRowModel: () => {
        if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {
          table._getPaginationRowModel = table.options.getPaginationRowModel(table);
        }
        if (table.options.manualPagination || !table._getPaginationRowModel) {
          return table.getPrePaginationRowModel();
        }
        return table._getPaginationRowModel();
      },
      getPageCount: () => {
        var _table$options$pageCo2;
        return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getPrePaginationRowModel().rows.length / table.getState().pagination.pageSize);
      }
    };
  }
};
var getDefaultPinningState = () => ({
  left: [],
  right: []
});
var Pinning = {
  getInitialState: (state) => {
    return {
      columnPinning: getDefaultPinningState(),
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnPinningChange: makeStateUpdater("columnPinning", table)
    };
  },
  createColumn: (column, table) => {
    return {
      pin: (position) => {
        const columnIds = column.getLeafColumns().map((d) => d.id).filter(Boolean);
        table.setColumnPinning((old) => {
          var _old$left3, _old$right3;
          if (position === "right") {
            var _old$left, _old$right;
            return {
              left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter((d) => !(columnIds != null && columnIds.includes(d))),
              right: [...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter((d) => !(columnIds != null && columnIds.includes(d))), ...columnIds]
            };
          }
          if (position === "left") {
            var _old$left2, _old$right2;
            return {
              left: [...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter((d) => !(columnIds != null && columnIds.includes(d))), ...columnIds],
              right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter((d) => !(columnIds != null && columnIds.includes(d)))
            };
          }
          return {
            left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter((d) => !(columnIds != null && columnIds.includes(d))),
            right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter((d) => !(columnIds != null && columnIds.includes(d)))
          };
        });
      },
      getCanPin: () => {
        const leafColumns = column.getLeafColumns();
        return leafColumns.some((d) => {
          var _d$columnDef$enablePi, _table$options$enable;
          return ((_d$columnDef$enablePi = d.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_table$options$enable = table.options.enablePinning) != null ? _table$options$enable : true);
        });
      },
      getIsPinned: () => {
        const leafColumnIds = column.getLeafColumns().map((d) => d.id);
        const {
          left,
          right
        } = table.getState().columnPinning;
        const isLeft = leafColumnIds.some((d) => left == null ? void 0 : left.includes(d));
        const isRight = leafColumnIds.some((d) => right == null ? void 0 : right.includes(d));
        return isLeft ? "left" : isRight ? "right" : false;
      },
      getPinnedIndex: () => {
        var _table$getState$colum, _table$getState$colum2, _table$getState$colum3;
        const position = column.getIsPinned();
        return position ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null ? void 0 : (_table$getState$colum3 = _table$getState$colum2[position]) == null ? void 0 : _table$getState$colum3.indexOf(column.id)) != null ? _table$getState$colum : -1 : 0;
      }
    };
  },
  createRow: (row, table) => {
    return {
      getCenterVisibleCells: memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allCells, left, right) => {
        const leftAndRight = [...left != null ? left : [], ...right != null ? right : []];
        return allCells.filter((d) => !leftAndRight.includes(d.column.id));
      }, {
        key: false,
        debug: () => {
          var _table$options$debugA;
          return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugRows;
        }
      }),
      getLeftVisibleCells: memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left, ,], (allCells, left) => {
        const cells = (left != null ? left : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d) => ({
          ...d,
          position: "left"
        }));
        return cells;
      }, {
        key: false,
        debug: () => {
          var _table$options$debugA2;
          return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugRows;
        }
      }),
      getRightVisibleCells: memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.right], (allCells, right) => {
        const cells = (right != null ? right : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d) => ({
          ...d,
          position: "right"
        }));
        return cells;
      }, {
        key: false,
        debug: () => {
          var _table$options$debugA3;
          return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugRows;
        }
      })
    };
  },
  createTable: (table) => {
    return {
      setColumnPinning: (updater) => table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater),
      resetColumnPinning: (defaultState) => {
        var _table$initialState$c, _table$initialState;
        return table.setColumnPinning(defaultState ? getDefaultPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultPinningState());
      },
      getIsSomeColumnsPinned: (position) => {
        var _pinningState$positio;
        const pinningState = table.getState().columnPinning;
        if (!position) {
          var _pinningState$left, _pinningState$right;
          return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));
        }
        return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);
      },
      getLeftLeafColumns: memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left], (allColumns, left) => {
        return (left != null ? left : []).map((columnId) => allColumns.find((column) => column.id === columnId)).filter(Boolean);
      }, {
        key: "getLeftLeafColumns",
        debug: () => {
          var _table$options$debugA4;
          return (_table$options$debugA4 = table.options.debugAll) != null ? _table$options$debugA4 : table.options.debugColumns;
        }
      }),
      getRightLeafColumns: memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.right], (allColumns, right) => {
        return (right != null ? right : []).map((columnId) => allColumns.find((column) => column.id === columnId)).filter(Boolean);
      }, {
        key: "getRightLeafColumns",
        debug: () => {
          var _table$options$debugA5;
          return (_table$options$debugA5 = table.options.debugAll) != null ? _table$options$debugA5 : table.options.debugColumns;
        }
      }),
      getCenterLeafColumns: memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, left, right) => {
        const leftAndRight = [...left != null ? left : [], ...right != null ? right : []];
        return allColumns.filter((d) => !leftAndRight.includes(d.id));
      }, {
        key: "getCenterLeafColumns",
        debug: () => {
          var _table$options$debugA6;
          return (_table$options$debugA6 = table.options.debugAll) != null ? _table$options$debugA6 : table.options.debugColumns;
        }
      })
    };
  }
};
var RowSelection = {
  getInitialState: (state) => {
    return {
      rowSelection: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onRowSelectionChange: makeStateUpdater("rowSelection", table),
      enableRowSelection: true,
      enableMultiRowSelection: true,
      enableSubRowSelection: true
      // enableGroupingRowSelection: false,
      // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,
      // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,
    };
  },
  createTable: (table) => {
    return {
      setRowSelection: (updater) => table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater),
      resetRowSelection: (defaultState) => {
        var _table$initialState$r;
        return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});
      },
      toggleAllRowsSelected: (value) => {
        table.setRowSelection((old) => {
          value = typeof value !== "undefined" ? value : !table.getIsAllRowsSelected();
          const rowSelection = {
            ...old
          };
          const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;
          if (value) {
            preGroupedFlatRows.forEach((row) => {
              if (!row.getCanSelect()) {
                return;
              }
              rowSelection[row.id] = true;
            });
          } else {
            preGroupedFlatRows.forEach((row) => {
              delete rowSelection[row.id];
            });
          }
          return rowSelection;
        });
      },
      toggleAllPageRowsSelected: (value) => table.setRowSelection((old) => {
        const resolvedValue = typeof value !== "undefined" ? value : !table.getIsAllPageRowsSelected();
        const rowSelection = {
          ...old
        };
        table.getRowModel().rows.forEach((row) => {
          mutateRowIsSelected(rowSelection, row.id, resolvedValue, table);
        });
        return rowSelection;
      }),
      // addRowSelectionRange: rowId => {
      //   const {
      //     rows,
      //     rowsById,
      //     options: { selectGroupingRows, selectSubRows },
      //   } = table
      //   const findSelectedRow = (rows: Row[]) => {
      //     let found
      //     rows.find(d => {
      //       if (d.getIsSelected()) {
      //         found = d
      //         return true
      //       }
      //       const subFound = findSelectedRow(d.subRows || [])
      //       if (subFound) {
      //         found = subFound
      //         return true
      //       }
      //       return false
      //     })
      //     return found
      //   }
      //   const firstRow = findSelectedRow(rows) || rows[0]
      //   const lastRow = rowsById[rowId]
      //   let include = false
      //   const selectedRowIds = {}
      //   const addRow = (row: Row) => {
      //     mutateRowIsSelected(selectedRowIds, row.id, true, {
      //       rowsById,
      //       selectGroupingRows: selectGroupingRows!,
      //       selectSubRows: selectSubRows!,
      //     })
      //   }
      //   table.rows.forEach(row => {
      //     const isFirstRow = row.id === firstRow.id
      //     const isLastRow = row.id === lastRow.id
      //     if (isFirstRow || isLastRow) {
      //       if (!include) {
      //         include = true
      //       } else if (include) {
      //         addRow(row)
      //         include = false
      //       }
      //     }
      //     if (include) {
      //       addRow(row)
      //     }
      //   })
      //   table.setRowSelection(selectedRowIds)
      // },
      getPreSelectedRowModel: () => table.getCoreRowModel(),
      getSelectedRowModel: memo(() => [table.getState().rowSelection, table.getCoreRowModel()], (rowSelection, rowModel) => {
        if (!Object.keys(rowSelection).length) {
          return {
            rows: [],
            flatRows: [],
            rowsById: {}
          };
        }
        return selectRowsFn(table, rowModel);
      }, {
        key: "getSelectedRowModel",
        debug: () => {
          var _table$options$debugA;
          return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;
        }
      }),
      getFilteredSelectedRowModel: memo(() => [table.getState().rowSelection, table.getFilteredRowModel()], (rowSelection, rowModel) => {
        if (!Object.keys(rowSelection).length) {
          return {
            rows: [],
            flatRows: [],
            rowsById: {}
          };
        }
        return selectRowsFn(table, rowModel);
      }, {
        key: false,
        debug: () => {
          var _table$options$debugA2;
          return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugTable;
        }
      }),
      getGroupedSelectedRowModel: memo(() => [table.getState().rowSelection, table.getSortedRowModel()], (rowSelection, rowModel) => {
        if (!Object.keys(rowSelection).length) {
          return {
            rows: [],
            flatRows: [],
            rowsById: {}
          };
        }
        return selectRowsFn(table, rowModel);
      }, {
        key: false,
        debug: () => {
          var _table$options$debugA3;
          return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugTable;
        }
      }),
      ///
      // getGroupingRowCanSelect: rowId => {
      //   const row = table.getRow(rowId)
      //   if (!row) {
      //     throw new Error()
      //   }
      //   if (typeof table.options.enableGroupingRowSelection === 'function') {
      //     return table.options.enableGroupingRowSelection(row)
      //   }
      //   return table.options.enableGroupingRowSelection ?? false
      // },
      getIsAllRowsSelected: () => {
        const preGroupedFlatRows = table.getFilteredRowModel().flatRows;
        const {
          rowSelection
        } = table.getState();
        let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);
        if (isAllRowsSelected) {
          if (preGroupedFlatRows.some((row) => row.getCanSelect() && !rowSelection[row.id])) {
            isAllRowsSelected = false;
          }
        }
        return isAllRowsSelected;
      },
      getIsAllPageRowsSelected: () => {
        const paginationFlatRows = table.getPaginationRowModel().flatRows.filter((row) => row.getCanSelect());
        const {
          rowSelection
        } = table.getState();
        let isAllPageRowsSelected = !!paginationFlatRows.length;
        if (isAllPageRowsSelected && paginationFlatRows.some((row) => !rowSelection[row.id])) {
          isAllPageRowsSelected = false;
        }
        return isAllPageRowsSelected;
      },
      getIsSomeRowsSelected: () => {
        var _table$getState$rowSe;
        const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;
        return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;
      },
      getIsSomePageRowsSelected: () => {
        const paginationFlatRows = table.getPaginationRowModel().flatRows;
        return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter((row) => row.getCanSelect()).some((d) => d.getIsSelected() || d.getIsSomeSelected());
      },
      getToggleAllRowsSelectedHandler: () => {
        return (e) => {
          table.toggleAllRowsSelected(e.target.checked);
        };
      },
      getToggleAllPageRowsSelectedHandler: () => {
        return (e) => {
          table.toggleAllPageRowsSelected(e.target.checked);
        };
      }
    };
  },
  createRow: (row, table) => {
    return {
      toggleSelected: (value) => {
        const isSelected = row.getIsSelected();
        table.setRowSelection((old) => {
          value = typeof value !== "undefined" ? value : !isSelected;
          if (isSelected === value) {
            return old;
          }
          const selectedRowIds = {
            ...old
          };
          mutateRowIsSelected(selectedRowIds, row.id, value, table);
          return selectedRowIds;
        });
      },
      getIsSelected: () => {
        const {
          rowSelection
        } = table.getState();
        return isRowSelected(row, rowSelection);
      },
      getIsSomeSelected: () => {
        const {
          rowSelection
        } = table.getState();
        return isSubRowSelected(row, rowSelection) === "some";
      },
      getIsAllSubRowsSelected: () => {
        const {
          rowSelection
        } = table.getState();
        return isSubRowSelected(row, rowSelection) === "all";
      },
      getCanSelect: () => {
        var _table$options$enable;
        if (typeof table.options.enableRowSelection === "function") {
          return table.options.enableRowSelection(row);
        }
        return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;
      },
      getCanSelectSubRows: () => {
        var _table$options$enable2;
        if (typeof table.options.enableSubRowSelection === "function") {
          return table.options.enableSubRowSelection(row);
        }
        return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;
      },
      getCanMultiSelect: () => {
        var _table$options$enable3;
        if (typeof table.options.enableMultiRowSelection === "function") {
          return table.options.enableMultiRowSelection(row);
        }
        return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;
      },
      getToggleSelectedHandler: () => {
        const canSelect = row.getCanSelect();
        return (e) => {
          var _target;
          if (!canSelect)
            return;
          row.toggleSelected((_target = e.target) == null ? void 0 : _target.checked);
        };
      }
    };
  }
};
var mutateRowIsSelected = (selectedRowIds, id, value, table) => {
  var _row$subRows;
  const row = table.getRow(id);
  if (value) {
    if (!row.getCanMultiSelect()) {
      Object.keys(selectedRowIds).forEach((key) => delete selectedRowIds[key]);
    }
    if (row.getCanSelect()) {
      selectedRowIds[id] = true;
    }
  } else {
    delete selectedRowIds[id];
  }
  if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {
    row.subRows.forEach((row2) => mutateRowIsSelected(selectedRowIds, row2.id, value, table));
  }
};
function selectRowsFn(table, rowModel) {
  const rowSelection = table.getState().rowSelection;
  const newSelectedFlatRows = [];
  const newSelectedRowsById = {};
  const recurseRows = function(rows, depth) {
    return rows.map((row) => {
      var _row$subRows2;
      const isSelected = isRowSelected(row, rowSelection);
      if (isSelected) {
        newSelectedFlatRows.push(row);
        newSelectedRowsById[row.id] = row;
      }
      if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {
        row = {
          ...row,
          subRows: recurseRows(row.subRows)
        };
      }
      if (isSelected) {
        return row;
      }
    }).filter(Boolean);
  };
  return {
    rows: recurseRows(rowModel.rows),
    flatRows: newSelectedFlatRows,
    rowsById: newSelectedRowsById
  };
}
function isRowSelected(row, selection) {
  var _selection$row$id;
  return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;
}
function isSubRowSelected(row, selection, table) {
  if (row.subRows && row.subRows.length) {
    let allChildrenSelected = true;
    let someSelected = false;
    row.subRows.forEach((subRow) => {
      if (someSelected && !allChildrenSelected) {
        return;
      }
      if (isRowSelected(subRow, selection)) {
        someSelected = true;
      } else {
        allChildrenSelected = false;
      }
    });
    return allChildrenSelected ? "all" : someSelected ? "some" : false;
  }
  return false;
}
var reSplitAlphaNumeric = /([0-9]+)/gm;
var alphanumeric = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
};
var alphanumericCaseSensitive = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
};
var text = (rowA, rowB, columnId) => {
  return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
};
var textCaseSensitive = (rowA, rowB, columnId) => {
  return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
};
var datetime = (rowA, rowB, columnId) => {
  const a = rowA.getValue(columnId);
  const b = rowB.getValue(columnId);
  return a > b ? 1 : a < b ? -1 : 0;
};
var basic = (rowA, rowB, columnId) => {
  return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));
};
function compareBasic(a, b) {
  return a === b ? 0 : a > b ? 1 : -1;
}
function toString(a) {
  if (typeof a === "number") {
    if (isNaN(a) || a === Infinity || a === -Infinity) {
      return "";
    }
    return String(a);
  }
  if (typeof a === "string") {
    return a;
  }
  return "";
}
function compareAlphanumeric(aStr, bStr) {
  const a = aStr.split(reSplitAlphaNumeric).filter(Boolean);
  const b = bStr.split(reSplitAlphaNumeric).filter(Boolean);
  while (a.length && b.length) {
    const aa = a.shift();
    const bb = b.shift();
    const an = parseInt(aa, 10);
    const bn = parseInt(bb, 10);
    const combo = [an, bn].sort();
    if (isNaN(combo[0])) {
      if (aa > bb) {
        return 1;
      }
      if (bb > aa) {
        return -1;
      }
      continue;
    }
    if (isNaN(combo[1])) {
      return isNaN(an) ? -1 : 1;
    }
    if (an > bn) {
      return 1;
    }
    if (bn > an) {
      return -1;
    }
  }
  return a.length - b.length;
}
var sortingFns = {
  alphanumeric,
  alphanumericCaseSensitive,
  text,
  textCaseSensitive,
  datetime,
  basic
};
var Sorting = {
  getInitialState: (state) => {
    return {
      sorting: [],
      ...state
    };
  },
  getDefaultColumnDef: () => {
    return {
      sortingFn: "auto"
    };
  },
  getDefaultOptions: (table) => {
    return {
      onSortingChange: makeStateUpdater("sorting", table),
      isMultiSortEvent: (e) => {
        return e.shiftKey;
      }
    };
  },
  createColumn: (column, table) => {
    return {
      getAutoSortingFn: () => {
        const firstRows = table.getFilteredRowModel().flatRows.slice(10);
        let isString = false;
        for (const row of firstRows) {
          const value = row == null ? void 0 : row.getValue(column.id);
          if (Object.prototype.toString.call(value) === "[object Date]") {
            return sortingFns.datetime;
          }
          if (typeof value === "string") {
            isString = true;
            if (value.split(reSplitAlphaNumeric).length > 1) {
              return sortingFns.alphanumeric;
            }
          }
        }
        if (isString) {
          return sortingFns.text;
        }
        return sortingFns.basic;
      },
      getAutoSortDir: () => {
        const firstRow = table.getFilteredRowModel().flatRows[0];
        const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
        if (typeof value === "string") {
          return "asc";
        }
        return "desc";
      },
      getSortingFn: () => {
        var _table$options$sortin, _table$options$sortin2;
        if (!column) {
          throw new Error();
        }
        return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === "auto" ? column.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? void 0 : _table$options$sortin2[column.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column.columnDef.sortingFn];
      },
      toggleSorting: (desc, multi) => {
        const nextSortingOrder = column.getNextSortingOrder();
        const hasManualValue = typeof desc !== "undefined" && desc !== null;
        table.setSorting((old) => {
          const existingSorting = old == null ? void 0 : old.find((d) => d.id === column.id);
          const existingIndex = old == null ? void 0 : old.findIndex((d) => d.id === column.id);
          let newSorting = [];
          let sortAction;
          let nextDesc = hasManualValue ? desc : nextSortingOrder === "desc";
          if (old != null && old.length && column.getCanMultiSort() && multi) {
            if (existingSorting) {
              sortAction = "toggle";
            } else {
              sortAction = "add";
            }
          } else {
            if (old != null && old.length && existingIndex !== old.length - 1) {
              sortAction = "replace";
            } else if (existingSorting) {
              sortAction = "toggle";
            } else {
              sortAction = "replace";
            }
          }
          if (sortAction === "toggle") {
            if (!hasManualValue) {
              if (!nextSortingOrder) {
                sortAction = "remove";
              }
            }
          }
          if (sortAction === "add") {
            var _table$options$maxMul;
            newSorting = [...old, {
              id: column.id,
              desc: nextDesc
            }];
            newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));
          } else if (sortAction === "toggle") {
            newSorting = old.map((d) => {
              if (d.id === column.id) {
                return {
                  ...d,
                  desc: nextDesc
                };
              }
              return d;
            });
          } else if (sortAction === "remove") {
            newSorting = old.filter((d) => d.id !== column.id);
          } else {
            newSorting = [{
              id: column.id,
              desc: nextDesc
            }];
          }
          return newSorting;
        });
      },
      getFirstSortDir: () => {
        var _ref, _column$columnDef$sor;
        const sortDescFirst = (_ref = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column.getAutoSortDir() === "desc";
        return sortDescFirst ? "desc" : "asc";
      },
      getNextSortingOrder: (multi) => {
        var _table$options$enable, _table$options$enable2;
        const firstSortDirection = column.getFirstSortDir();
        const isSorted = column.getIsSorted();
        if (!isSorted) {
          return firstSortDirection;
        }
        if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && // If enableSortRemove, enable in general
        (multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true)) {
          return false;
        }
        return isSorted === "desc" ? "asc" : "desc";
      },
      getCanSort: () => {
        var _column$columnDef$ena, _table$options$enable3;
        return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column.accessorFn;
      },
      getCanMultiSort: () => {
        var _ref2, _column$columnDef$ena2;
        return (_ref2 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column.accessorFn;
      },
      getIsSorted: () => {
        var _table$getState$sorti;
        const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find((d) => d.id === column.id);
        return !columnSort ? false : columnSort.desc ? "desc" : "asc";
      },
      getSortIndex: () => {
        var _table$getState$sorti2, _table$getState$sorti3;
        return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? void 0 : _table$getState$sorti3.findIndex((d) => d.id === column.id)) != null ? _table$getState$sorti2 : -1;
      },
      clearSorting: () => {
        table.setSorting((old) => old != null && old.length ? old.filter((d) => d.id !== column.id) : []);
      },
      getToggleSortingHandler: () => {
        const canSort = column.getCanSort();
        return (e) => {
          if (!canSort)
            return;
          e.persist == null ? void 0 : e.persist();
          column.toggleSorting == null ? void 0 : column.toggleSorting(void 0, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e) : false);
        };
      }
    };
  },
  createTable: (table) => {
    return {
      setSorting: (updater) => table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater),
      resetSorting: (defaultState) => {
        var _table$initialState$s, _table$initialState;
        table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _table$initialState$s : []);
      },
      getPreSortedRowModel: () => table.getGroupedRowModel(),
      getSortedRowModel: () => {
        if (!table._getSortedRowModel && table.options.getSortedRowModel) {
          table._getSortedRowModel = table.options.getSortedRowModel(table);
        }
        if (table.options.manualSorting || !table._getSortedRowModel) {
          return table.getPreSortedRowModel();
        }
        return table._getSortedRowModel();
      }
    };
  }
};
var Visibility = {
  getInitialState: (state) => {
    return {
      columnVisibility: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnVisibilityChange: makeStateUpdater("columnVisibility", table)
    };
  },
  createColumn: (column, table) => {
    return {
      toggleVisibility: (value) => {
        if (column.getCanHide()) {
          table.setColumnVisibility((old) => ({
            ...old,
            [column.id]: value != null ? value : !column.getIsVisible()
          }));
        }
      },
      getIsVisible: () => {
        var _table$getState$colum, _table$getState$colum2;
        return (_table$getState$colum = (_table$getState$colum2 = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum2[column.id]) != null ? _table$getState$colum : true;
      },
      getCanHide: () => {
        var _column$columnDef$ena, _table$options$enable;
        return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);
      },
      getToggleVisibilityHandler: () => {
        return (e) => {
          column.toggleVisibility == null ? void 0 : column.toggleVisibility(e.target.checked);
        };
      }
    };
  },
  createRow: (row, table) => {
    return {
      _getAllVisibleCells: memo(() => [row.getAllCells(), table.getState().columnVisibility], (cells) => {
        return cells.filter((cell) => cell.column.getIsVisible());
      }, {
        key: false,
        debug: () => {
          var _table$options$debugA;
          return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugRows;
        }
      }),
      getVisibleCells: memo(() => [row.getLeftVisibleCells(), row.getCenterVisibleCells(), row.getRightVisibleCells()], (left, center, right) => [...left, ...center, ...right], {
        key: "row.getVisibleCells",
        debug: () => {
          var _table$options$debugA2;
          return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugRows;
        }
      })
    };
  },
  createTable: (table) => {
    const makeVisibleColumnsMethod = (key, getColumns) => {
      return memo(() => [getColumns(), getColumns().filter((d) => d.getIsVisible()).map((d) => d.id).join("_")], (columns) => {
        return columns.filter((d) => d.getIsVisible == null ? void 0 : d.getIsVisible());
      }, {
        key,
        debug: () => {
          var _table$options$debugA3;
          return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugColumns;
        }
      });
    };
    return {
      getVisibleFlatColumns: makeVisibleColumnsMethod("getVisibleFlatColumns", () => table.getAllFlatColumns()),
      getVisibleLeafColumns: makeVisibleColumnsMethod("getVisibleLeafColumns", () => table.getAllLeafColumns()),
      getLeftVisibleLeafColumns: makeVisibleColumnsMethod("getLeftVisibleLeafColumns", () => table.getLeftLeafColumns()),
      getRightVisibleLeafColumns: makeVisibleColumnsMethod("getRightVisibleLeafColumns", () => table.getRightLeafColumns()),
      getCenterVisibleLeafColumns: makeVisibleColumnsMethod("getCenterVisibleLeafColumns", () => table.getCenterLeafColumns()),
      setColumnVisibility: (updater) => table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater),
      resetColumnVisibility: (defaultState) => {
        var _table$initialState$c;
        table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});
      },
      toggleAllColumnsVisible: (value) => {
        var _value;
        value = (_value = value) != null ? _value : !table.getIsAllColumnsVisible();
        table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column) => ({
          ...obj,
          [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value
        }), {}));
      },
      getIsAllColumnsVisible: () => !table.getAllLeafColumns().some((column) => !(column.getIsVisible != null && column.getIsVisible())),
      getIsSomeColumnsVisible: () => table.getAllLeafColumns().some((column) => column.getIsVisible == null ? void 0 : column.getIsVisible()),
      getToggleAllColumnsVisibilityHandler: () => {
        return (e) => {
          var _target;
          table.toggleAllColumnsVisible((_target = e.target) == null ? void 0 : _target.checked);
        };
      }
    };
  }
};
var features = [Headers, Visibility, Ordering, Pinning, Filters, Sorting, Grouping, Expanding, Pagination, RowSelection, ColumnSizing];
function createTable(options) {
  var _options$initialState;
  if (options.debugAll || options.debugTable) {
    console.info("Creating Table Instance...");
  }
  let table = {
    _features: features
  };
  const defaultOptions = table._features.reduce((obj, feature) => {
    return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));
  }, {});
  const mergeOptions = (options2) => {
    if (table.options.mergeOptions) {
      return table.options.mergeOptions(defaultOptions, options2);
    }
    return {
      ...defaultOptions,
      ...options2
    };
  };
  const coreInitialState = {};
  let initialState = {
    ...coreInitialState,
    ...(_options$initialState = options.initialState) != null ? _options$initialState : {}
  };
  table._features.forEach((feature) => {
    var _feature$getInitialSt;
    initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;
  });
  const queued = [];
  let queuedTimeout = false;
  const coreInstance = {
    _features: features,
    options: {
      ...defaultOptions,
      ...options
    },
    initialState,
    _queue: (cb) => {
      queued.push(cb);
      if (!queuedTimeout) {
        queuedTimeout = true;
        Promise.resolve().then(() => {
          while (queued.length) {
            queued.shift()();
          }
          queuedTimeout = false;
        }).catch((error) => setTimeout(() => {
          throw error;
        }));
      }
    },
    reset: () => {
      table.setState(table.initialState);
    },
    setOptions: (updater) => {
      const newOptions = functionalUpdate(updater, table.options);
      table.options = mergeOptions(newOptions);
    },
    getState: () => {
      return table.options.state;
    },
    setState: (updater) => {
      table.options.onStateChange == null ? void 0 : table.options.onStateChange(updater);
    },
    _getRowId: (row, index, parent) => {
      var _table$options$getRow;
      return (_table$options$getRow = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index, parent)) != null ? _table$options$getRow : `${parent ? [parent.id, index].join(".") : index}`;
    },
    getCoreRowModel: () => {
      if (!table._getCoreRowModel) {
        table._getCoreRowModel = table.options.getCoreRowModel(table);
      }
      return table._getCoreRowModel();
    },
    // The final calls start at the bottom of the model,
    // expanded rows, which then work their way up
    getRowModel: () => {
      return table.getPaginationRowModel();
    },
    getRow: (id) => {
      const row = table.getRowModel().rowsById[id];
      if (!row) {
        if (true) {
          throw new Error(`getRow expected an ID, but got ${id}`);
        }
        throw new Error();
      }
      return row;
    },
    _getDefaultColumnDef: memo(() => [table.options.defaultColumn], (defaultColumn) => {
      var _defaultColumn;
      defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};
      return {
        header: (props) => {
          const resolvedColumnDef = props.header.column.columnDef;
          if (resolvedColumnDef.accessorKey) {
            return resolvedColumnDef.accessorKey;
          }
          if (resolvedColumnDef.accessorFn) {
            return resolvedColumnDef.id;
          }
          return null;
        },
        // footer: props => props.header.column.id,
        cell: (props) => {
          var _props$renderValue$to, _props$renderValue;
          return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null ? void 0 : _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _props$renderValue$to : null;
        },
        ...table._features.reduce((obj, feature) => {
          return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());
        }, {}),
        ...defaultColumn
      };
    }, {
      debug: () => {
        var _table$options$debugA;
        return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugColumns;
      },
      key: "getDefaultColumnDef"
    }),
    _getColumnDefs: () => table.options.columns,
    getAllColumns: memo(() => [table._getColumnDefs()], (columnDefs) => {
      const recurseColumns = function(columnDefs2, parent, depth) {
        if (depth === void 0) {
          depth = 0;
        }
        return columnDefs2.map((columnDef) => {
          const column = createColumn(table, columnDef, depth, parent);
          const groupingColumnDef = columnDef;
          column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];
          return column;
        });
      };
      return recurseColumns(columnDefs);
    }, {
      key: "getAllColumns",
      debug: () => {
        var _table$options$debugA2;
        return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugColumns;
      }
    }),
    getAllFlatColumns: memo(() => [table.getAllColumns()], (allColumns) => {
      return allColumns.flatMap((column) => {
        return column.getFlatColumns();
      });
    }, {
      key: "getAllFlatColumns",
      debug: () => {
        var _table$options$debugA3;
        return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugColumns;
      }
    }),
    _getAllFlatColumnsById: memo(() => [table.getAllFlatColumns()], (flatColumns) => {
      return flatColumns.reduce((acc, column) => {
        acc[column.id] = column;
        return acc;
      }, {});
    }, {
      key: "getAllFlatColumnsById",
      debug: () => {
        var _table$options$debugA4;
        return (_table$options$debugA4 = table.options.debugAll) != null ? _table$options$debugA4 : table.options.debugColumns;
      }
    }),
    getAllLeafColumns: memo(() => [table.getAllColumns(), table._getOrderColumnsFn()], (allColumns, orderColumns2) => {
      let leafColumns = allColumns.flatMap((column) => column.getLeafColumns());
      return orderColumns2(leafColumns);
    }, {
      key: "getAllLeafColumns",
      debug: () => {
        var _table$options$debugA5;
        return (_table$options$debugA5 = table.options.debugAll) != null ? _table$options$debugA5 : table.options.debugColumns;
      }
    }),
    getColumn: (columnId) => {
      const column = table._getAllFlatColumnsById()[columnId];
      if (!column) {
        console.error(`[Table] Column with id '${columnId}' does not exist.`);
      }
      return column;
    }
  };
  Object.assign(table, coreInstance);
  table._features.forEach((feature) => {
    return Object.assign(table, feature.createTable == null ? void 0 : feature.createTable(table));
  });
  return table;
}
function createCell(table, row, column, columnId) {
  const getRenderValue = () => {
    var _cell$getValue;
    return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;
  };
  const cell = {
    id: `${row.id}_${column.id}`,
    row,
    column,
    getValue: () => row.getValue(columnId),
    renderValue: getRenderValue,
    getContext: memo(() => [table, column, row, cell], (table2, column2, row2, cell2) => ({
      table: table2,
      column: column2,
      row: row2,
      cell: cell2,
      getValue: cell2.getValue,
      renderValue: cell2.renderValue
    }), {
      key: "cell.getContext",
      debug: () => table.options.debugAll
    })
  };
  table._features.forEach((feature) => {
    Object.assign(cell, feature.createCell == null ? void 0 : feature.createCell(cell, column, row, table));
  }, {});
  return cell;
}
var createRow = (table, id, original, rowIndex, depth, subRows, parentId) => {
  let row = {
    id,
    index: rowIndex,
    original,
    depth,
    parentId,
    _valuesCache: {},
    _uniqueValuesCache: {},
    getValue: (columnId) => {
      if (row._valuesCache.hasOwnProperty(columnId)) {
        return row._valuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.accessorFn)) {
        return void 0;
      }
      row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);
      return row._valuesCache[columnId];
    },
    getUniqueValues: (columnId) => {
      if (row._uniqueValuesCache.hasOwnProperty(columnId)) {
        return row._uniqueValuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.accessorFn)) {
        return void 0;
      }
      if (!column.columnDef.getUniqueValues) {
        row._uniqueValuesCache[columnId] = [row.getValue(columnId)];
        return row._uniqueValuesCache[columnId];
      }
      row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);
      return row._uniqueValuesCache[columnId];
    },
    renderValue: (columnId) => {
      var _row$getValue;
      return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;
    },
    subRows: subRows != null ? subRows : [],
    getLeafRows: () => flattenBy(row.subRows, (d) => d.subRows),
    getParentRow: () => row.parentId ? table.getRow(row.parentId) : void 0,
    getParentRows: () => {
      let parentRows = [];
      let currentRow = row;
      while (true) {
        const parentRow = currentRow.getParentRow();
        if (!parentRow)
          break;
        parentRows.push(parentRow);
        currentRow = parentRow;
      }
      return parentRows.reverse();
    },
    getAllCells: memo(() => [table.getAllLeafColumns()], (leafColumns) => {
      return leafColumns.map((column) => {
        return createCell(table, row, column, column.id);
      });
    }, {
      key: "row.getAllCells",
      debug: () => {
        var _table$options$debugA;
        return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugRows;
      }
    }),
    _getAllCellsByColumnId: memo(() => [row.getAllCells()], (allCells) => {
      return allCells.reduce((acc, cell) => {
        acc[cell.column.id] = cell;
        return acc;
      }, {});
    }, {
      key: false,
      debug: () => {
        var _table$options$debugA2;
        return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugRows;
      }
    })
  };
  for (let i = 0; i < table._features.length; i++) {
    const feature = table._features[i];
    Object.assign(row, feature == null ? void 0 : feature.createRow == null ? void 0 : feature.createRow(row, table));
  }
  return row;
};
function getCoreRowModel() {
  return (table) => memo(() => [table.options.data], (data) => {
    const rowModel = {
      rows: [],
      flatRows: [],
      rowsById: {}
    };
    const accessRows = function(originalRows, depth, parentRow) {
      if (depth === void 0) {
        depth = 0;
      }
      const rows = [];
      for (let i = 0; i < originalRows.length; i++) {
        const row = createRow(table, table._getRowId(originalRows[i], i, parentRow), originalRows[i], i, depth, void 0, parentRow == null ? void 0 : parentRow.id);
        rowModel.flatRows.push(row);
        rowModel.rowsById[row.id] = row;
        rows.push(row);
        if (table.options.getSubRows) {
          var _row$originalSubRows;
          row.originalSubRows = table.options.getSubRows(originalRows[i], i);
          if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {
            row.subRows = accessRows(row.originalSubRows, depth + 1, row);
          }
        }
      }
      return rows;
    };
    rowModel.rows = accessRows(data);
    return rowModel;
  }, {
    key: "getRowModel",
    debug: () => {
      var _table$options$debugA;
      return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;
    },
    onChange: () => {
      table._autoResetPageIndex();
    }
  });
}
function filterRows(rows, filterRowImpl, table) {
  if (table.options.filterFromLeafRows) {
    return filterRowModelFromLeafs(rows, filterRowImpl, table);
  }
  return filterRowModelFromRoot(rows, filterRowImpl, table);
}
function filterRowModelFromLeafs(rowsToFilter, filterRow, table) {
  var _table$options$maxLea;
  const newFilteredFlatRows = [];
  const newFilteredRowsById = {};
  const maxDepth = (_table$options$maxLea = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea : 100;
  const recurseFilterRows = function(rowsToFilter2, depth) {
    if (depth === void 0) {
      depth = 0;
    }
    const rows = [];
    for (let i = 0; i < rowsToFilter2.length; i++) {
      var _row$subRows;
      let row = rowsToFilter2[i];
      const newRow = createRow(table, row.id, row.original, row.index, row.depth, void 0, row.parentId);
      newRow.columnFilters = row.columnFilters;
      if ((_row$subRows = row.subRows) != null && _row$subRows.length && depth < maxDepth) {
        newRow.subRows = recurseFilterRows(row.subRows, depth + 1);
        row = newRow;
        if (filterRow(row) && !newRow.subRows.length) {
          rows.push(row);
          newFilteredRowsById[row.id] = row;
          newFilteredRowsById[i] = row;
          continue;
        }
        if (filterRow(row) || newRow.subRows.length) {
          rows.push(row);
          newFilteredRowsById[row.id] = row;
          newFilteredRowsById[i] = row;
          continue;
        }
      } else {
        row = newRow;
        if (filterRow(row)) {
          rows.push(row);
          newFilteredRowsById[row.id] = row;
          newFilteredRowsById[i] = row;
        }
      }
    }
    return rows;
  };
  return {
    rows: recurseFilterRows(rowsToFilter),
    flatRows: newFilteredFlatRows,
    rowsById: newFilteredRowsById
  };
}
function filterRowModelFromRoot(rowsToFilter, filterRow, table) {
  var _table$options$maxLea2;
  const newFilteredFlatRows = [];
  const newFilteredRowsById = {};
  const maxDepth = (_table$options$maxLea2 = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea2 : 100;
  const recurseFilterRows = function(rowsToFilter2, depth) {
    if (depth === void 0) {
      depth = 0;
    }
    const rows = [];
    for (let i = 0; i < rowsToFilter2.length; i++) {
      let row = rowsToFilter2[i];
      const pass = filterRow(row);
      if (pass) {
        var _row$subRows2;
        if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length && depth < maxDepth) {
          const newRow = createRow(table, row.id, row.original, row.index, row.depth, void 0, row.parentId);
          newRow.subRows = recurseFilterRows(row.subRows, depth + 1);
          row = newRow;
        }
        rows.push(row);
        newFilteredFlatRows.push(row);
        newFilteredRowsById[row.id] = row;
      }
    }
    return rows;
  };
  return {
    rows: recurseFilterRows(rowsToFilter),
    flatRows: newFilteredFlatRows,
    rowsById: newFilteredRowsById
  };
}
function getFilteredRowModel() {
  return (table) => memo(() => [table.getPreFilteredRowModel(), table.getState().columnFilters, table.getState().globalFilter], (rowModel, columnFilters, globalFilter) => {
    if (!rowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {
      for (let i = 0; i < rowModel.flatRows.length; i++) {
        rowModel.flatRows[i].columnFilters = {};
        rowModel.flatRows[i].columnFiltersMeta = {};
      }
      return rowModel;
    }
    const resolvedColumnFilters = [];
    const resolvedGlobalFilters = [];
    (columnFilters != null ? columnFilters : []).forEach((d) => {
      var _filterFn$resolveFilt;
      const column = table.getColumn(d.id);
      if (!column) {
        return;
      }
      const filterFn = column.getFilterFn();
      if (!filterFn) {
        if (true) {
          console.warn(`Could not find a valid 'column.filterFn' for column with the ID: ${column.id}.`);
        }
        return;
      }
      resolvedColumnFilters.push({
        id: d.id,
        filterFn,
        resolvedValue: (_filterFn$resolveFilt = filterFn.resolveFilterValue == null ? void 0 : filterFn.resolveFilterValue(d.value)) != null ? _filterFn$resolveFilt : d.value
      });
    });
    const filterableIds = columnFilters.map((d) => d.id);
    const globalFilterFn = table.getGlobalFilterFn();
    const globallyFilterableColumns = table.getAllLeafColumns().filter((column) => column.getCanGlobalFilter());
    if (globalFilter && globalFilterFn && globallyFilterableColumns.length) {
      filterableIds.push("__global__");
      globallyFilterableColumns.forEach((column) => {
        var _globalFilterFn$resol;
        resolvedGlobalFilters.push({
          id: column.id,
          filterFn: globalFilterFn,
          resolvedValue: (_globalFilterFn$resol = globalFilterFn.resolveFilterValue == null ? void 0 : globalFilterFn.resolveFilterValue(globalFilter)) != null ? _globalFilterFn$resol : globalFilter
        });
      });
    }
    let currentColumnFilter;
    let currentGlobalFilter;
    for (let j = 0; j < rowModel.flatRows.length; j++) {
      const row = rowModel.flatRows[j];
      row.columnFilters = {};
      if (resolvedColumnFilters.length) {
        for (let i = 0; i < resolvedColumnFilters.length; i++) {
          currentColumnFilter = resolvedColumnFilters[i];
          const id = currentColumnFilter.id;
          row.columnFilters[id] = currentColumnFilter.filterFn(row, id, currentColumnFilter.resolvedValue, (filterMeta) => {
            row.columnFiltersMeta[id] = filterMeta;
          });
        }
      }
      if (resolvedGlobalFilters.length) {
        for (let i = 0; i < resolvedGlobalFilters.length; i++) {
          currentGlobalFilter = resolvedGlobalFilters[i];
          const id = currentGlobalFilter.id;
          if (currentGlobalFilter.filterFn(row, id, currentGlobalFilter.resolvedValue, (filterMeta) => {
            row.columnFiltersMeta[id] = filterMeta;
          })) {
            row.columnFilters.__global__ = true;
            break;
          }
        }
        if (row.columnFilters.__global__ !== true) {
          row.columnFilters.__global__ = false;
        }
      }
    }
    const filterRowsImpl = (row) => {
      for (let i = 0; i < filterableIds.length; i++) {
        if (row.columnFilters[filterableIds[i]] === false) {
          return false;
        }
      }
      return true;
    };
    return filterRows(rowModel.rows, filterRowsImpl, table);
  }, {
    key: "getFilteredRowModel",
    debug: () => {
      var _table$options$debugA;
      return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;
    },
    onChange: () => {
      table._autoResetPageIndex();
    }
  });
}
function getFacetedRowModel() {
  return (table, columnId) => memo(() => [table.getPreFilteredRowModel(), table.getState().columnFilters, table.getState().globalFilter, table.getFilteredRowModel()], (preRowModel, columnFilters, globalFilter) => {
    if (!preRowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {
      return preRowModel;
    }
    const filterableIds = [...columnFilters.map((d) => d.id).filter((d) => d !== columnId), globalFilter ? "__global__" : void 0].filter(Boolean);
    const filterRowsImpl = (row) => {
      for (let i = 0; i < filterableIds.length; i++) {
        if (row.columnFilters[filterableIds[i]] === false) {
          return false;
        }
      }
      return true;
    };
    return filterRows(preRowModel.rows, filterRowsImpl, table);
  }, {
    key: "getFacetedRowModel_" + columnId,
    debug: () => {
      var _table$options$debugA;
      return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;
    },
    onChange: () => {
    }
  });
}
function getFacetedUniqueValues() {
  return (table, columnId) => memo(() => {
    var _table$getColumn;
    return [(_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()];
  }, (facetedRowModel) => {
    if (!facetedRowModel)
      return /* @__PURE__ */ new Map();
    let facetedUniqueValues = /* @__PURE__ */ new Map();
    for (let i = 0; i < facetedRowModel.flatRows.length; i++) {
      const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);
      for (let j = 0; j < values.length; j++) {
        const value = values[j];
        if (facetedUniqueValues.has(value)) {
          var _facetedUniqueValues$;
          facetedUniqueValues.set(value, ((_facetedUniqueValues$ = facetedUniqueValues.get(value)) != null ? _facetedUniqueValues$ : 0) + 1);
        } else {
          facetedUniqueValues.set(value, 1);
        }
      }
    }
    return facetedUniqueValues;
  }, {
    key: "getFacetedUniqueValues_" + columnId,
    debug: () => {
      var _table$options$debugA;
      return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;
    },
    onChange: () => {
    }
  });
}
function getFacetedMinMaxValues() {
  return (table, columnId) => memo(() => {
    var _table$getColumn;
    return [(_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()];
  }, (facetedRowModel) => {
    var _facetedRowModel$flat;
    if (!facetedRowModel)
      return void 0;
    const firstValue = (_facetedRowModel$flat = facetedRowModel.flatRows[0]) == null ? void 0 : _facetedRowModel$flat.getUniqueValues(columnId);
    if (typeof firstValue === "undefined") {
      return void 0;
    }
    let facetedMinMaxValues = [firstValue, firstValue];
    for (let i = 0; i < facetedRowModel.flatRows.length; i++) {
      const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);
      for (let j = 0; j < values.length; j++) {
        const value = values[j];
        if (value < facetedMinMaxValues[0]) {
          facetedMinMaxValues[0] = value;
        } else if (value > facetedMinMaxValues[1]) {
          facetedMinMaxValues[1] = value;
        }
      }
    }
    return facetedMinMaxValues;
  }, {
    key: "getFacetedMinMaxValues_" + columnId,
    debug: () => {
      var _table$options$debugA;
      return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;
    },
    onChange: () => {
    }
  });
}
function getSortedRowModel() {
  return (table) => memo(() => [table.getState().sorting, table.getPreSortedRowModel()], (sorting, rowModel) => {
    if (!rowModel.rows.length || !(sorting != null && sorting.length)) {
      return rowModel;
    }
    const sortingState = table.getState().sorting;
    const sortedFlatRows = [];
    const availableSorting = sortingState.filter((sort) => {
      var _table$getColumn;
      return (_table$getColumn = table.getColumn(sort.id)) == null ? void 0 : _table$getColumn.getCanSort();
    });
    const columnInfoById = {};
    availableSorting.forEach((sortEntry) => {
      const column = table.getColumn(sortEntry.id);
      if (!column)
        return;
      columnInfoById[sortEntry.id] = {
        sortUndefined: column.columnDef.sortUndefined,
        invertSorting: column.columnDef.invertSorting,
        sortingFn: column.getSortingFn()
      };
    });
    const sortData = (rows) => {
      const sortedData = [...rows];
      sortedData.sort((rowA, rowB) => {
        for (let i = 0; i < availableSorting.length; i += 1) {
          var _sortEntry$desc;
          const sortEntry = availableSorting[i];
          const columnInfo = columnInfoById[sortEntry.id];
          const isDesc = (_sortEntry$desc = sortEntry == null ? void 0 : sortEntry.desc) != null ? _sortEntry$desc : false;
          if (columnInfo.sortUndefined) {
            const aValue = rowA.getValue(sortEntry.id);
            const bValue = rowB.getValue(sortEntry.id);
            const aUndefined = typeof aValue === "undefined";
            const bUndefined = typeof bValue === "undefined";
            if (aUndefined || bUndefined) {
              let undefinedSort = aUndefined && bUndefined ? 0 : aUndefined ? columnInfo.sortUndefined : -columnInfo.sortUndefined;
              if (isDesc && undefinedSort !== 0) {
                undefinedSort *= -1;
              }
              return undefinedSort;
            }
          }
          let sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);
          if (sortInt !== 0) {
            if (isDesc) {
              sortInt *= -1;
            }
            if (columnInfo.invertSorting) {
              sortInt *= -1;
            }
            return sortInt;
          }
        }
        return rowA.index - rowB.index;
      });
      sortedData.forEach((row) => {
        var _row$subRows;
        sortedFlatRows.push(row);
        if ((_row$subRows = row.subRows) != null && _row$subRows.length) {
          row.subRows = sortData(row.subRows);
        }
      });
      return sortedData;
    };
    return {
      rows: sortData(rowModel.rows),
      flatRows: sortedFlatRows,
      rowsById: rowModel.rowsById
    };
  }, {
    key: "getSortedRowModel",
    debug: () => {
      var _table$options$debugA;
      return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;
    },
    onChange: () => {
      table._autoResetPageIndex();
    }
  });
}
function getGroupedRowModel() {
  return (table) => memo(() => [table.getState().grouping, table.getPreGroupedRowModel()], (grouping, rowModel) => {
    if (!rowModel.rows.length || !grouping.length) {
      return rowModel;
    }
    const existingGrouping = grouping.filter((columnId) => table.getColumn(columnId));
    const groupedFlatRows = [];
    const groupedRowsById = {};
    const groupUpRecursively = function(rows, depth, parentId) {
      if (depth === void 0) {
        depth = 0;
      }
      if (depth >= existingGrouping.length) {
        return rows.map((row) => {
          row.depth = depth;
          groupedFlatRows.push(row);
          groupedRowsById[row.id] = row;
          if (row.subRows) {
            row.subRows = groupUpRecursively(row.subRows, depth + 1, row.id);
          }
          return row;
        });
      }
      const columnId = existingGrouping[depth];
      const rowGroupsMap = groupBy(rows, columnId);
      const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map((_ref, index) => {
        let [groupingValue, groupedRows2] = _ref;
        let id = `${columnId}:${groupingValue}`;
        id = parentId ? `${parentId}>${id}` : id;
        const subRows = groupUpRecursively(groupedRows2, depth + 1, id);
        const leafRows = depth ? flattenBy(groupedRows2, (row2) => row2.subRows) : groupedRows2;
        const row = createRow(table, id, leafRows[0].original, index, depth, void 0, parentId);
        Object.assign(row, {
          groupingColumnId: columnId,
          groupingValue,
          subRows,
          leafRows,
          getValue: (columnId2) => {
            if (existingGrouping.includes(columnId2)) {
              if (row._valuesCache.hasOwnProperty(columnId2)) {
                return row._valuesCache[columnId2];
              }
              if (groupedRows2[0]) {
                var _groupedRows$0$getVal;
                row._valuesCache[columnId2] = (_groupedRows$0$getVal = groupedRows2[0].getValue(columnId2)) != null ? _groupedRows$0$getVal : void 0;
              }
              return row._valuesCache[columnId2];
            }
            if (row._groupingValuesCache.hasOwnProperty(columnId2)) {
              return row._groupingValuesCache[columnId2];
            }
            const column = table.getColumn(columnId2);
            const aggregateFn = column == null ? void 0 : column.getAggregationFn();
            if (aggregateFn) {
              row._groupingValuesCache[columnId2] = aggregateFn(columnId2, leafRows, groupedRows2);
              return row._groupingValuesCache[columnId2];
            }
          }
        });
        subRows.forEach((subRow) => {
          groupedFlatRows.push(subRow);
          groupedRowsById[subRow.id] = subRow;
        });
        return row;
      });
      return aggregatedGroupedRows;
    };
    const groupedRows = groupUpRecursively(rowModel.rows, 0);
    groupedRows.forEach((subRow) => {
      groupedFlatRows.push(subRow);
      groupedRowsById[subRow.id] = subRow;
    });
    return {
      rows: groupedRows,
      flatRows: groupedFlatRows,
      rowsById: groupedRowsById
    };
  }, {
    key: "getGroupedRowModel",
    debug: () => {
      var _table$options$debugA;
      return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;
    },
    onChange: () => {
      table._queue(() => {
        table._autoResetExpanded();
        table._autoResetPageIndex();
      });
    }
  });
}
function groupBy(rows, columnId) {
  const groupMap = /* @__PURE__ */ new Map();
  return rows.reduce((map, row) => {
    const resKey = `${row.getGroupingValue(columnId)}`;
    const previous = map.get(resKey);
    if (!previous) {
      map.set(resKey, [row]);
    } else {
      previous.push(row);
    }
    return map;
  }, groupMap);
}
function getExpandedRowModel() {
  return (table) => memo(() => [table.getState().expanded, table.getPreExpandedRowModel(), table.options.paginateExpandedRows], (expanded, rowModel, paginateExpandedRows) => {
    if (!rowModel.rows.length || expanded !== true && !Object.keys(expanded != null ? expanded : {}).length) {
      return rowModel;
    }
    if (!paginateExpandedRows) {
      return rowModel;
    }
    return expandRows(rowModel);
  }, {
    key: "getExpandedRowModel",
    debug: () => {
      var _table$options$debugA;
      return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;
    }
  });
}
function expandRows(rowModel) {
  const expandedRows = [];
  const handleRow = (row) => {
    var _row$subRows;
    expandedRows.push(row);
    if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getIsExpanded()) {
      row.subRows.forEach(handleRow);
    }
  };
  rowModel.rows.forEach(handleRow);
  return {
    rows: expandedRows,
    flatRows: rowModel.flatRows,
    rowsById: rowModel.rowsById
  };
}
function getPaginationRowModel(opts) {
  return (table) => memo(() => [table.getState().pagination, table.getPrePaginationRowModel(), table.options.paginateExpandedRows ? void 0 : table.getState().expanded], (pagination, rowModel) => {
    if (!rowModel.rows.length) {
      return rowModel;
    }
    const {
      pageSize,
      pageIndex
    } = pagination;
    let {
      rows,
      flatRows,
      rowsById
    } = rowModel;
    const pageStart = pageSize * pageIndex;
    const pageEnd = pageStart + pageSize;
    rows = rows.slice(pageStart, pageEnd);
    let paginatedRowModel;
    if (!table.options.paginateExpandedRows) {
      paginatedRowModel = expandRows({
        rows,
        flatRows,
        rowsById
      });
    } else {
      paginatedRowModel = {
        rows,
        flatRows,
        rowsById
      };
    }
    paginatedRowModel.flatRows = [];
    const handleRow = (row) => {
      paginatedRowModel.flatRows.push(row);
      if (row.subRows.length) {
        row.subRows.forEach(handleRow);
      }
    };
    paginatedRowModel.rows.forEach(handleRow);
    return paginatedRowModel;
  }, {
    key: "getPaginationRowModel",
    debug: () => {
      var _table$options$debugA;
      return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;
    }
  });
}

// node_modules/@tanstack/react-table/build/lib/index.mjs
function useReactTable(options) {
  const resolvedOptions = {
    state: {},
    // Dummy state
    onStateChange: () => {
    },
    // noop
    renderFallbackValue: null,
    ...options
  };
  const [tableRef] = React.useState(() => ({
    current: createTable(resolvedOptions)
  }));
  const [state, setState] = React.useState(() => tableRef.current.initialState);
  tableRef.current.setOptions((prev) => ({
    ...prev,
    ...options,
    state: {
      ...state,
      ...options.state
    },
    // Similarly, we'll maintain both our internal state and any user-provided
    // state.
    onStateChange: (updater) => {
      setState(updater);
      options.onStateChange == null ? void 0 : options.onStateChange(updater);
    }
  }));
  return tableRef.current;
}

// node_modules/@tanstack/match-sorter-utils/build/lib/index.mjs
var characterMap = {
  À: "A",
  Á: "A",
  Â: "A",
  Ã: "A",
  Ä: "A",
  Å: "A",
  Ấ: "A",
  Ắ: "A",
  Ẳ: "A",
  Ẵ: "A",
  Ặ: "A",
  Æ: "AE",
  Ầ: "A",
  Ằ: "A",
  Ȃ: "A",
  Ç: "C",
  Ḉ: "C",
  È: "E",
  É: "E",
  Ê: "E",
  Ë: "E",
  Ế: "E",
  Ḗ: "E",
  Ề: "E",
  Ḕ: "E",
  Ḝ: "E",
  Ȇ: "E",
  Ì: "I",
  Í: "I",
  Î: "I",
  Ï: "I",
  Ḯ: "I",
  Ȋ: "I",
  Ð: "D",
  Ñ: "N",
  Ò: "O",
  Ó: "O",
  Ô: "O",
  Õ: "O",
  Ö: "O",
  Ø: "O",
  Ố: "O",
  Ṍ: "O",
  Ṓ: "O",
  Ȏ: "O",
  Ù: "U",
  Ú: "U",
  Û: "U",
  Ü: "U",
  Ý: "Y",
  à: "a",
  á: "a",
  â: "a",
  ã: "a",
  ä: "a",
  å: "a",
  ấ: "a",
  ắ: "a",
  ẳ: "a",
  ẵ: "a",
  ặ: "a",
  æ: "ae",
  ầ: "a",
  ằ: "a",
  ȃ: "a",
  ç: "c",
  ḉ: "c",
  è: "e",
  é: "e",
  ê: "e",
  ë: "e",
  ế: "e",
  ḗ: "e",
  ề: "e",
  ḕ: "e",
  ḝ: "e",
  ȇ: "e",
  ì: "i",
  í: "i",
  î: "i",
  ï: "i",
  ḯ: "i",
  ȋ: "i",
  ð: "d",
  ñ: "n",
  ò: "o",
  ó: "o",
  ô: "o",
  õ: "o",
  ö: "o",
  ø: "o",
  ố: "o",
  ṍ: "o",
  ṓ: "o",
  ȏ: "o",
  ù: "u",
  ú: "u",
  û: "u",
  ü: "u",
  ý: "y",
  ÿ: "y",
  Ā: "A",
  ā: "a",
  Ă: "A",
  ă: "a",
  Ą: "A",
  ą: "a",
  Ć: "C",
  ć: "c",
  Ĉ: "C",
  ĉ: "c",
  Ċ: "C",
  ċ: "c",
  Č: "C",
  č: "c",
  C̆: "C",
  c̆: "c",
  Ď: "D",
  ď: "d",
  Đ: "D",
  đ: "d",
  Ē: "E",
  ē: "e",
  Ĕ: "E",
  ĕ: "e",
  Ė: "E",
  ė: "e",
  Ę: "E",
  ę: "e",
  Ě: "E",
  ě: "e",
  Ĝ: "G",
  Ǵ: "G",
  ĝ: "g",
  ǵ: "g",
  Ğ: "G",
  ğ: "g",
  Ġ: "G",
  ġ: "g",
  Ģ: "G",
  ģ: "g",
  Ĥ: "H",
  ĥ: "h",
  Ħ: "H",
  ħ: "h",
  Ḫ: "H",
  ḫ: "h",
  Ĩ: "I",
  ĩ: "i",
  Ī: "I",
  ī: "i",
  Ĭ: "I",
  ĭ: "i",
  Į: "I",
  į: "i",
  İ: "I",
  ı: "i",
  Ĳ: "IJ",
  ĳ: "ij",
  Ĵ: "J",
  ĵ: "j",
  Ķ: "K",
  ķ: "k",
  Ḱ: "K",
  ḱ: "k",
  K̆: "K",
  k̆: "k",
  Ĺ: "L",
  ĺ: "l",
  Ļ: "L",
  ļ: "l",
  Ľ: "L",
  ľ: "l",
  Ŀ: "L",
  ŀ: "l",
  Ł: "l",
  ł: "l",
  Ḿ: "M",
  ḿ: "m",
  M̆: "M",
  m̆: "m",
  Ń: "N",
  ń: "n",
  Ņ: "N",
  ņ: "n",
  Ň: "N",
  ň: "n",
  ŉ: "n",
  N̆: "N",
  n̆: "n",
  Ō: "O",
  ō: "o",
  Ŏ: "O",
  ŏ: "o",
  Ő: "O",
  ő: "o",
  Œ: "OE",
  œ: "oe",
  P̆: "P",
  p̆: "p",
  Ŕ: "R",
  ŕ: "r",
  Ŗ: "R",
  ŗ: "r",
  Ř: "R",
  ř: "r",
  R̆: "R",
  r̆: "r",
  Ȓ: "R",
  ȓ: "r",
  Ś: "S",
  ś: "s",
  Ŝ: "S",
  ŝ: "s",
  Ş: "S",
  Ș: "S",
  ș: "s",
  ş: "s",
  Š: "S",
  š: "s",
  Ţ: "T",
  ţ: "t",
  ț: "t",
  Ț: "T",
  Ť: "T",
  ť: "t",
  Ŧ: "T",
  ŧ: "t",
  T̆: "T",
  t̆: "t",
  Ũ: "U",
  ũ: "u",
  Ū: "U",
  ū: "u",
  Ŭ: "U",
  ŭ: "u",
  Ů: "U",
  ů: "u",
  Ű: "U",
  ű: "u",
  Ų: "U",
  ų: "u",
  Ȗ: "U",
  ȗ: "u",
  V̆: "V",
  v̆: "v",
  Ŵ: "W",
  ŵ: "w",
  Ẃ: "W",
  ẃ: "w",
  X̆: "X",
  x̆: "x",
  Ŷ: "Y",
  ŷ: "y",
  Ÿ: "Y",
  Y̆: "Y",
  y̆: "y",
  Ź: "Z",
  ź: "z",
  Ż: "Z",
  ż: "z",
  Ž: "Z",
  ž: "z",
  ſ: "s",
  ƒ: "f",
  Ơ: "O",
  ơ: "o",
  Ư: "U",
  ư: "u",
  Ǎ: "A",
  ǎ: "a",
  Ǐ: "I",
  ǐ: "i",
  Ǒ: "O",
  ǒ: "o",
  Ǔ: "U",
  ǔ: "u",
  Ǖ: "U",
  ǖ: "u",
  Ǘ: "U",
  ǘ: "u",
  Ǚ: "U",
  ǚ: "u",
  Ǜ: "U",
  ǜ: "u",
  Ứ: "U",
  ứ: "u",
  Ṹ: "U",
  ṹ: "u",
  Ǻ: "A",
  ǻ: "a",
  Ǽ: "AE",
  ǽ: "ae",
  Ǿ: "O",
  ǿ: "o",
  Þ: "TH",
  þ: "th",
  Ṕ: "P",
  ṕ: "p",
  Ṥ: "S",
  ṥ: "s",
  X́: "X",
  x́: "x",
  Ѓ: "Г",
  ѓ: "г",
  Ќ: "К",
  ќ: "к",
  A̋: "A",
  a̋: "a",
  E̋: "E",
  e̋: "e",
  I̋: "I",
  i̋: "i",
  Ǹ: "N",
  ǹ: "n",
  Ồ: "O",
  ồ: "o",
  Ṑ: "O",
  ṑ: "o",
  Ừ: "U",
  ừ: "u",
  Ẁ: "W",
  ẁ: "w",
  Ỳ: "Y",
  ỳ: "y",
  Ȁ: "A",
  ȁ: "a",
  Ȅ: "E",
  ȅ: "e",
  Ȉ: "I",
  ȉ: "i",
  Ȍ: "O",
  ȍ: "o",
  Ȑ: "R",
  ȑ: "r",
  Ȕ: "U",
  ȕ: "u",
  B̌: "B",
  b̌: "b",
  Č̣: "C",
  č̣: "c",
  Ê̌: "E",
  ê̌: "e",
  F̌: "F",
  f̌: "f",
  Ǧ: "G",
  ǧ: "g",
  Ȟ: "H",
  ȟ: "h",
  J̌: "J",
  ǰ: "j",
  Ǩ: "K",
  ǩ: "k",
  M̌: "M",
  m̌: "m",
  P̌: "P",
  p̌: "p",
  Q̌: "Q",
  q̌: "q",
  Ř̩: "R",
  ř̩: "r",
  Ṧ: "S",
  ṧ: "s",
  V̌: "V",
  v̌: "v",
  W̌: "W",
  w̌: "w",
  X̌: "X",
  x̌: "x",
  Y̌: "Y",
  y̌: "y",
  A̧: "A",
  a̧: "a",
  B̧: "B",
  b̧: "b",
  Ḑ: "D",
  ḑ: "d",
  Ȩ: "E",
  ȩ: "e",
  Ɛ̧: "E",
  ɛ̧: "e",
  Ḩ: "H",
  ḩ: "h",
  I̧: "I",
  i̧: "i",
  Ɨ̧: "I",
  ɨ̧: "i",
  M̧: "M",
  m̧: "m",
  O̧: "O",
  o̧: "o",
  Q̧: "Q",
  q̧: "q",
  U̧: "U",
  u̧: "u",
  X̧: "X",
  x̧: "x",
  Z̧: "Z",
  z̧: "z"
};
var chars = Object.keys(characterMap).join("|");
var allAccents = new RegExp(chars, "g");
function removeAccents(str) {
  return str.replace(allAccents, (match) => {
    return characterMap[match];
  });
}
var rankings = {
  CASE_SENSITIVE_EQUAL: 7,
  EQUAL: 6,
  STARTS_WITH: 5,
  WORD_STARTS_WITH: 4,
  CONTAINS: 3,
  ACRONYM: 2,
  MATCHES: 1,
  NO_MATCH: 0
};
function rankItem(item, value, options) {
  var _options$threshold;
  options = options || {};
  options.threshold = (_options$threshold = options.threshold) != null ? _options$threshold : rankings.MATCHES;
  if (!options.accessors) {
    const rank = getMatchRanking(item, value, options);
    return {
      // ends up being duplicate of 'item' in matches but consistent
      rankedValue: item,
      rank,
      accessorIndex: -1,
      accessorThreshold: options.threshold,
      passed: rank >= options.threshold
    };
  }
  const valuesToRank = getAllValuesToRank(item, options.accessors);
  const rankingInfo = {
    rankedValue: item,
    rank: rankings.NO_MATCH,
    accessorIndex: -1,
    accessorThreshold: options.threshold,
    passed: false
  };
  for (let i = 0; i < valuesToRank.length; i++) {
    const rankValue = valuesToRank[i];
    let newRank = getMatchRanking(rankValue.itemValue, value, options);
    const {
      minRanking,
      maxRanking,
      threshold = options.threshold
    } = rankValue.attributes;
    if (newRank < minRanking && newRank >= rankings.MATCHES) {
      newRank = minRanking;
    } else if (newRank > maxRanking) {
      newRank = maxRanking;
    }
    newRank = Math.min(newRank, maxRanking);
    if (newRank >= threshold && newRank > rankingInfo.rank) {
      rankingInfo.rank = newRank;
      rankingInfo.passed = true;
      rankingInfo.accessorIndex = i;
      rankingInfo.accessorThreshold = threshold;
      rankingInfo.rankedValue = rankValue.itemValue;
    }
  }
  return rankingInfo;
}
function getMatchRanking(testString, stringToRank, options) {
  testString = prepareValueForComparison(testString, options);
  stringToRank = prepareValueForComparison(stringToRank, options);
  if (stringToRank.length > testString.length) {
    return rankings.NO_MATCH;
  }
  if (testString === stringToRank) {
    return rankings.CASE_SENSITIVE_EQUAL;
  }
  testString = testString.toLowerCase();
  stringToRank = stringToRank.toLowerCase();
  if (testString === stringToRank) {
    return rankings.EQUAL;
  }
  if (testString.startsWith(stringToRank)) {
    return rankings.STARTS_WITH;
  }
  if (testString.includes(` ${stringToRank}`)) {
    return rankings.WORD_STARTS_WITH;
  }
  if (testString.includes(stringToRank)) {
    return rankings.CONTAINS;
  } else if (stringToRank.length === 1) {
    return rankings.NO_MATCH;
  }
  if (getAcronym(testString).includes(stringToRank)) {
    return rankings.ACRONYM;
  }
  return getClosenessRanking(testString, stringToRank);
}
function getAcronym(string) {
  let acronym = "";
  const wordsInString = string.split(" ");
  wordsInString.forEach((wordInString) => {
    const splitByHyphenWords = wordInString.split("-");
    splitByHyphenWords.forEach((splitByHyphenWord) => {
      acronym += splitByHyphenWord.substr(0, 1);
    });
  });
  return acronym;
}
function getClosenessRanking(testString, stringToRank) {
  let matchingInOrderCharCount = 0;
  let charNumber = 0;
  function findMatchingCharacter(matchChar, string, index) {
    for (let j = index, J = string.length; j < J; j++) {
      const stringChar = string[j];
      if (stringChar === matchChar) {
        matchingInOrderCharCount += 1;
        return j + 1;
      }
    }
    return -1;
  }
  function getRanking(spread2) {
    const spreadPercentage = 1 / spread2;
    const inOrderPercentage = matchingInOrderCharCount / stringToRank.length;
    const ranking = rankings.MATCHES + inOrderPercentage * spreadPercentage;
    return ranking;
  }
  const firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);
  if (firstIndex < 0) {
    return rankings.NO_MATCH;
  }
  charNumber = firstIndex;
  for (let i = 1, I = stringToRank.length; i < I; i++) {
    const matchChar = stringToRank[i];
    charNumber = findMatchingCharacter(matchChar, testString, charNumber);
    const found = charNumber > -1;
    if (!found) {
      return rankings.NO_MATCH;
    }
  }
  const spread = charNumber - firstIndex;
  return getRanking(spread);
}
function compareItems(a, b) {
  return a.rank === b.rank ? 0 : a.rank > b.rank ? -1 : 1;
}
function prepareValueForComparison(value, _ref) {
  let {
    keepDiacritics
  } = _ref;
  value = `${value}`;
  if (!keepDiacritics) {
    value = removeAccents(value);
  }
  return value;
}
function getItemValues(item, accessor) {
  let accessorFn = accessor;
  if (typeof accessor === "object") {
    accessorFn = accessor.accessor;
  }
  const value = accessorFn(item);
  if (value == null) {
    return [];
  }
  if (Array.isArray(value)) {
    return value;
  }
  return [String(value)];
}
function getAllValuesToRank(item, accessors) {
  const allValues = [];
  for (let j = 0, J = accessors.length; j < J; j++) {
    const accessor = accessors[j];
    const attributes = getAccessorAttributes(accessor);
    const itemValues = getItemValues(item, accessor);
    for (let i = 0, I = itemValues.length; i < I; i++) {
      allValues.push({
        itemValue: itemValues[i],
        attributes
      });
    }
  }
  return allValues;
}
var defaultKeyAttributes = {
  maxRanking: Infinity,
  minRanking: -Infinity
};
function getAccessorAttributes(accessor) {
  if (typeof accessor === "function") {
    return defaultKeyAttributes;
  }
  return {
    ...defaultKeyAttributes,
    ...accessor
  };
}

// node_modules/material-react-table/dist/esm/material-react-table.esm.js
var import_ArrowDownward = __toESM(require_ArrowDownward());
var import_ArrowRight = __toESM(require_ArrowRight());
var import_Cancel = __toESM(require_Cancel());
var import_ClearAll = __toESM(require_ClearAll());
var import_Close = __toESM(require_Close());
var import_DensityLarge = __toESM(require_DensityLarge());
var import_DensityMedium = __toESM(require_DensityMedium());
var import_DensitySmall = __toESM(require_DensitySmall());
var import_DragHandle = __toESM(require_DragHandle());
var import_DynamicFeed = __toESM(require_DynamicFeed());
var import_Edit = __toESM(require_Edit());
var import_ExpandMore = __toESM(require_ExpandMore());
var import_FilterAlt = __toESM(require_FilterAlt());
var import_FilterList = __toESM(require_FilterList());
var import_FilterListOff = __toESM(require_FilterListOff());
var import_FullscreenExit = __toESM(require_FullscreenExit());
var import_Fullscreen = __toESM(require_Fullscreen());
var import_KeyboardDoubleArrowDown = __toESM(require_KeyboardDoubleArrowDown());
var import_MoreHoriz = __toESM(require_MoreHoriz());
var import_MoreVert = __toESM(require_MoreVert());
var import_PushPin = __toESM(require_PushPin());
var import_RestartAlt = __toESM(require_RestartAlt());
var import_Save = __toESM(require_Save());
var import_Search = __toESM(require_Search());
var import_SearchOff = __toESM(require_SearchOff());
var import_Sort = __toESM(require_Sort());
var import_ViewColumn = __toESM(require_ViewColumn());
var import_VisibilityOff = __toESM(require_VisibilityOff());
init_utils();

// node_modules/@tanstack/react-virtual/build/lib/_virtual/_rollupPluginBabelHelpers.mjs
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

// node_modules/@tanstack/react-virtual/build/lib/index.mjs
var React2 = __toESM(require_react(), 1);

// node_modules/@tanstack/virtual-core/build/lib/_virtual/_rollupPluginBabelHelpers.mjs
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}

// node_modules/@tanstack/virtual-core/build/lib/utils.mjs
function memo2(getDeps, fn, opts) {
  var _opts$initialDeps;
  var deps = (_opts$initialDeps = opts.initialDeps) != null ? _opts$initialDeps : [];
  var result;
  return function() {
    var depTime;
    if (opts.key && opts.debug != null && opts.debug())
      depTime = Date.now();
    var newDeps = getDeps();
    var depsChanged = newDeps.length !== deps.length || newDeps.some(function(dep, index) {
      return deps[index] !== dep;
    });
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    var resultTime;
    if (opts.key && opts.debug != null && opts.debug())
      resultTime = Date.now();
    result = fn.apply(void 0, newDeps);
    if (opts.key && opts.debug != null && opts.debug()) {
      var depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
      var resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
      var resultFpsPercentage = resultEndTime / 16;
      var pad = function pad2(str, num) {
        str = String(str);
        while (str.length < num) {
          str = " " + str;
        }
        return str;
      };
      console.info("%c⏱ " + pad(resultEndTime, 5) + " /" + pad(depEndTime, 5) + " ms", "\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(" + Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120)) + "deg 100% 31%);", opts == null ? void 0 : opts.key);
    }
    opts == null ? void 0 : opts.onChange == null ? void 0 : opts.onChange(result);
    return result;
  };
}
function notUndefined(value, msg) {
  if (value === void 0) {
    throw new Error("Unexpected undefined" + (msg ? ": " + msg : ""));
  } else {
    return value;
  }
}
var approxEqual = function approxEqual2(a, b) {
  return Math.abs(a - b) < 1;
};

// node_modules/@tanstack/virtual-core/build/lib/index.mjs
var defaultKeyExtractor = function defaultKeyExtractor2(index) {
  return index;
};
var defaultRangeExtractor = function defaultRangeExtractor2(range) {
  var start = Math.max(range.startIndex - range.overscan, 0);
  var end = Math.min(range.endIndex + range.overscan, range.count - 1);
  var arr = [];
  for (var _i = start; _i <= end; _i++) {
    arr.push(_i);
  }
  return arr;
};
var observeElementRect = function observeElementRect2(instance, cb) {
  var element = instance.scrollElement;
  if (!element) {
    return;
  }
  var handler = function handler2(rect) {
    var width = rect.width, height = rect.height;
    cb({
      width: Math.round(width),
      height: Math.round(height)
    });
  };
  handler(element.getBoundingClientRect());
  var observer = new ResizeObserver(function(entries) {
    var entry = entries[0];
    if (entry != null && entry.borderBoxSize) {
      var box = entry.borderBoxSize[0];
      if (box) {
        handler({
          width: box.inlineSize,
          height: box.blockSize
        });
        return;
      }
    }
    handler(element.getBoundingClientRect());
  });
  observer.observe(element, {
    box: "border-box"
  });
  return function() {
    observer.unobserve(element);
  };
};
var observeElementOffset = function observeElementOffset2(instance, cb) {
  var element = instance.scrollElement;
  if (!element) {
    return;
  }
  var handler = function handler2() {
    cb(element[instance.options.horizontal ? "scrollLeft" : "scrollTop"]);
  };
  handler();
  element.addEventListener("scroll", handler, {
    passive: true
  });
  return function() {
    element.removeEventListener("scroll", handler);
  };
};
var measureElement = function measureElement2(element, entry, instance) {
  if (entry != null && entry.borderBoxSize) {
    var box = entry.borderBoxSize[0];
    if (box) {
      var size = Math.round(box[instance.options.horizontal ? "inlineSize" : "blockSize"]);
      return size;
    }
  }
  return Math.round(element.getBoundingClientRect()[instance.options.horizontal ? "width" : "height"]);
};
var elementScroll = function elementScroll2(offset, _ref2, instance) {
  var _instance$scrollEleme3, _instance$scrollEleme4;
  var _ref2$adjustments = _ref2.adjustments, adjustments = _ref2$adjustments === void 0 ? 0 : _ref2$adjustments, behavior = _ref2.behavior;
  var toOffset = offset + adjustments;
  (_instance$scrollEleme3 = instance.scrollElement) == null ? void 0 : _instance$scrollEleme3.scrollTo == null ? void 0 : _instance$scrollEleme3.scrollTo((_instance$scrollEleme4 = {}, _instance$scrollEleme4[instance.options.horizontal ? "left" : "top"] = toOffset, _instance$scrollEleme4.behavior = behavior, _instance$scrollEleme4));
};
var Virtualizer = function Virtualizer2(_opts) {
  var _this = this;
  this.unsubs = [];
  this.scrollElement = null;
  this.isScrolling = false;
  this.isScrollingTimeoutId = null;
  this.scrollToIndexTimeoutId = null;
  this.measurementsCache = [];
  this.itemSizeCache = /* @__PURE__ */ new Map();
  this.pendingMeasuredCacheIndexes = [];
  this.scrollDirection = null;
  this.scrollAdjustments = 0;
  this.measureElementCache = /* @__PURE__ */ new Map();
  this.observer = function() {
    var _ro = null;
    var get = function get2() {
      if (_ro) {
        return _ro;
      } else if (typeof ResizeObserver !== "undefined") {
        return _ro = new ResizeObserver(function(entries) {
          entries.forEach(function(entry) {
            _this._measureElement(entry.target, entry);
          });
        });
      } else {
        return null;
      }
    };
    return {
      disconnect: function disconnect() {
        var _get;
        return (_get = get()) == null ? void 0 : _get.disconnect();
      },
      observe: function observe(target) {
        var _get2;
        return (_get2 = get()) == null ? void 0 : _get2.observe(target, {
          box: "border-box"
        });
      },
      unobserve: function unobserve(target) {
        var _get3;
        return (_get3 = get()) == null ? void 0 : _get3.unobserve(target);
      }
    };
  }();
  this.range = {
    startIndex: 0,
    endIndex: 0
  };
  this.setOptions = function(opts) {
    Object.entries(opts).forEach(function(_ref3) {
      var key = _ref3[0], value = _ref3[1];
      if (typeof value === "undefined")
        delete opts[key];
    });
    _this.options = _extends2({
      debug: false,
      initialOffset: 0,
      overscan: 1,
      paddingStart: 0,
      paddingEnd: 0,
      scrollPaddingStart: 0,
      scrollPaddingEnd: 0,
      horizontal: false,
      getItemKey: defaultKeyExtractor,
      rangeExtractor: defaultRangeExtractor,
      onChange: function onChange() {
      },
      measureElement,
      initialRect: {
        width: 0,
        height: 0
      },
      scrollMargin: 0,
      scrollingDelay: 150,
      indexAttribute: "data-index",
      initialMeasurementsCache: [],
      lanes: 1
    }, opts);
  };
  this.notify = function() {
    _this.options.onChange == null ? void 0 : _this.options.onChange(_this);
  };
  this.cleanup = function() {
    _this.unsubs.filter(Boolean).forEach(function(d) {
      return d();
    });
    _this.unsubs = [];
    _this.scrollElement = null;
  };
  this._didMount = function() {
    _this.measureElementCache.forEach(_this.observer.observe);
    return function() {
      _this.observer.disconnect();
      _this.cleanup();
    };
  };
  this._willUpdate = function() {
    var scrollElement = _this.options.getScrollElement();
    if (_this.scrollElement !== scrollElement) {
      _this.cleanup();
      _this.scrollElement = scrollElement;
      _this._scrollToOffset(_this.scrollOffset, {
        adjustments: void 0,
        behavior: void 0
      });
      _this.unsubs.push(_this.options.observeElementRect(_this, function(rect) {
        var prev = _this.scrollRect;
        _this.scrollRect = rect;
        if (_this.options.horizontal ? rect.width !== prev.width : rect.height !== prev.height) {
          _this.maybeNotify();
        }
      }));
      _this.unsubs.push(_this.options.observeElementOffset(_this, function(offset) {
        _this.scrollAdjustments = 0;
        if (_this.scrollOffset === offset) {
          return;
        }
        if (_this.isScrollingTimeoutId !== null) {
          clearTimeout(_this.isScrollingTimeoutId);
          _this.isScrollingTimeoutId = null;
        }
        _this.isScrolling = true;
        _this.scrollDirection = _this.scrollOffset < offset ? "forward" : "backward";
        _this.scrollOffset = offset;
        _this.maybeNotify();
        _this.isScrollingTimeoutId = setTimeout(function() {
          _this.isScrollingTimeoutId = null;
          _this.isScrolling = false;
          _this.scrollDirection = null;
          _this.maybeNotify();
        }, _this.options.scrollingDelay);
      }));
    }
  };
  this.getSize = function() {
    return _this.scrollRect[_this.options.horizontal ? "width" : "height"];
  };
  this.memoOptions = memo2(function() {
    return [_this.options.count, _this.options.paddingStart, _this.options.scrollMargin, _this.options.getItemKey];
  }, function(count2, paddingStart, scrollMargin, getItemKey) {
    _this.pendingMeasuredCacheIndexes = [];
    return {
      count: count2,
      paddingStart,
      scrollMargin,
      getItemKey
    };
  }, {
    key: false
  });
  this.getFurthestMeasurement = function(measurements, index) {
    var furthestMeasurementsFound = /* @__PURE__ */ new Map();
    var furthestMeasurements = /* @__PURE__ */ new Map();
    for (var m = index - 1; m >= 0; m--) {
      var measurement = measurements[m];
      if (furthestMeasurementsFound.has(measurement.lane)) {
        continue;
      }
      var previousFurthestMeasurement = furthestMeasurements.get(measurement.lane);
      if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {
        furthestMeasurements.set(measurement.lane, measurement);
      } else if (measurement.end < previousFurthestMeasurement.end) {
        furthestMeasurementsFound.set(measurement.lane, true);
      }
      if (furthestMeasurementsFound.size === _this.options.lanes) {
        break;
      }
    }
    return furthestMeasurements.size === _this.options.lanes ? Array.from(furthestMeasurements.values()).sort(function(a, b) {
      return a.end - b.end;
    })[0] : void 0;
  };
  this.getMeasurements = memo2(function() {
    return [_this.memoOptions(), _this.itemSizeCache];
  }, function(_ref4, itemSizeCache) {
    var count2 = _ref4.count, paddingStart = _ref4.paddingStart, scrollMargin = _ref4.scrollMargin, getItemKey = _ref4.getItemKey;
    var min2 = _this.pendingMeasuredCacheIndexes.length > 0 ? Math.min.apply(Math, _this.pendingMeasuredCacheIndexes) : 0;
    _this.pendingMeasuredCacheIndexes = [];
    var measurements = _this.measurementsCache.slice(0, min2);
    for (var _i2 = min2; _i2 < count2; _i2++) {
      var key = getItemKey(_i2);
      var furthestMeasurement = _this.options.lanes === 1 ? measurements[_i2 - 1] : _this.getFurthestMeasurement(measurements, _i2);
      var start = furthestMeasurement ? furthestMeasurement.end : paddingStart + scrollMargin;
      var measuredSize = itemSizeCache.get(key);
      var size = typeof measuredSize === "number" ? measuredSize : _this.options.estimateSize(_i2);
      var end = start + size;
      var lane = furthestMeasurement ? furthestMeasurement.lane : _i2 % _this.options.lanes;
      measurements[_i2] = {
        index: _i2,
        start,
        size,
        end,
        key,
        lane
      };
    }
    _this.measurementsCache = measurements;
    return measurements;
  }, {
    key: "getMeasurements",
    debug: function debug() {
      return _this.options.debug;
    }
  });
  this.calculateRange = memo2(function() {
    return [_this.getMeasurements(), _this.getSize(), _this.scrollOffset];
  }, function(measurements, outerSize, scrollOffset) {
    return _this.range = calculateRange({
      measurements,
      outerSize,
      scrollOffset
    });
  }, {
    key: "calculateRange",
    debug: function debug() {
      return _this.options.debug;
    }
  });
  this.maybeNotify = memo2(function() {
    var range = _this.calculateRange();
    return [range.startIndex, range.endIndex, _this.isScrolling];
  }, function() {
    _this.notify();
  }, {
    key: "maybeNotify",
    debug: function debug() {
      return _this.options.debug;
    },
    initialDeps: [this.range.startIndex, this.range.endIndex, this.isScrolling]
  });
  this.getIndexes = memo2(function() {
    return [_this.options.rangeExtractor, _this.calculateRange(), _this.options.overscan, _this.options.count];
  }, function(rangeExtractor, range, overscan, count2) {
    return rangeExtractor(_extends2({}, range, {
      overscan,
      count: count2
    }));
  }, {
    key: "getIndexes",
    debug: function debug() {
      return _this.options.debug;
    }
  });
  this.indexFromElement = function(node) {
    var attributeName = _this.options.indexAttribute;
    var indexStr = node.getAttribute(attributeName);
    if (!indexStr) {
      console.warn("Missing attribute name '" + attributeName + "={index}' on measured element.");
      return -1;
    }
    return parseInt(indexStr, 10);
  };
  this._measureElement = function(node, entry) {
    var _this$itemSizeCache$g;
    var index = _this.indexFromElement(node);
    var item = _this.measurementsCache[index];
    if (!item) {
      return;
    }
    var prevNode = _this.measureElementCache.get(item.key);
    if (!node.isConnected) {
      _this.observer.unobserve(node);
      if (node === prevNode) {
        _this.measureElementCache["delete"](item.key);
      }
      return;
    }
    if (prevNode !== node) {
      if (prevNode) {
        _this.observer.unobserve(prevNode);
      }
      _this.observer.observe(node);
      _this.measureElementCache.set(item.key, node);
    }
    var measuredItemSize = _this.options.measureElement(node, entry, _this);
    var itemSize = (_this$itemSizeCache$g = _this.itemSizeCache.get(item.key)) != null ? _this$itemSizeCache$g : item.size;
    var delta = measuredItemSize - itemSize;
    if (delta !== 0) {
      if (item.start < _this.scrollOffset) {
        if (_this.options.debug) {
          console.info("correction", delta);
        }
        _this._scrollToOffset(_this.scrollOffset, {
          adjustments: _this.scrollAdjustments += delta,
          behavior: void 0
        });
      }
      _this.pendingMeasuredCacheIndexes.push(index);
      _this.itemSizeCache = new Map(_this.itemSizeCache.set(item.key, measuredItemSize));
      _this.notify();
    }
  };
  this.measureElement = function(node) {
    if (!node) {
      return;
    }
    _this._measureElement(node, void 0);
  };
  this.getVirtualItems = memo2(function() {
    return [_this.getIndexes(), _this.getMeasurements()];
  }, function(indexes, measurements) {
    var virtualItems = [];
    for (var k = 0, len = indexes.length; k < len; k++) {
      var _i3 = indexes[k];
      var measurement = measurements[_i3];
      virtualItems.push(measurement);
    }
    return virtualItems;
  }, {
    key: "getIndexes",
    debug: function debug() {
      return _this.options.debug;
    }
  });
  this.getVirtualItemForOffset = function(offset) {
    var measurements = _this.getMeasurements();
    return notUndefined(measurements[findNearestBinarySearch(0, measurements.length - 1, function(index) {
      return notUndefined(measurements[index]).start;
    }, offset)]);
  };
  this.getOffsetForAlignment = function(toOffset, align) {
    var size = _this.getSize();
    if (align === "auto") {
      if (toOffset <= _this.scrollOffset) {
        align = "start";
      } else if (toOffset >= _this.scrollOffset + size) {
        align = "end";
      } else {
        align = "start";
      }
    }
    if (align === "start") {
      toOffset = toOffset;
    } else if (align === "end") {
      toOffset = toOffset - size;
    } else if (align === "center") {
      toOffset = toOffset - size / 2;
    }
    var scrollSizeProp = _this.options.horizontal ? "scrollWidth" : "scrollHeight";
    var scrollSize = _this.scrollElement ? "document" in _this.scrollElement ? _this.scrollElement.document.documentElement[scrollSizeProp] : _this.scrollElement[scrollSizeProp] : 0;
    var maxOffset = scrollSize - _this.getSize();
    return Math.max(Math.min(maxOffset, toOffset), 0);
  };
  this.getOffsetForIndex = function(index, align) {
    if (align === void 0) {
      align = "auto";
    }
    index = Math.max(0, Math.min(index, _this.options.count - 1));
    var measurement = notUndefined(_this.getMeasurements()[index]);
    if (align === "auto") {
      if (measurement.end >= _this.scrollOffset + _this.getSize() - _this.options.scrollPaddingEnd) {
        align = "end";
      } else if (measurement.start <= _this.scrollOffset + _this.options.scrollPaddingStart) {
        align = "start";
      } else {
        return [_this.scrollOffset, align];
      }
    }
    var toOffset = align === "end" ? measurement.end + _this.options.scrollPaddingEnd : measurement.start - _this.options.scrollPaddingStart;
    return [_this.getOffsetForAlignment(toOffset, align), align];
  };
  this.isDynamicMode = function() {
    return _this.measureElementCache.size > 0;
  };
  this.cancelScrollToIndex = function() {
    if (_this.scrollToIndexTimeoutId !== null) {
      clearTimeout(_this.scrollToIndexTimeoutId);
      _this.scrollToIndexTimeoutId = null;
    }
  };
  this.scrollToOffset = function(toOffset, _temp) {
    var _ref5 = _temp === void 0 ? {} : _temp, _ref5$align = _ref5.align, align = _ref5$align === void 0 ? "start" : _ref5$align, behavior = _ref5.behavior;
    _this.cancelScrollToIndex();
    if (behavior === "smooth" && _this.isDynamicMode()) {
      console.warn("The `smooth` scroll behavior is not fully supported with dynamic size.");
    }
    _this._scrollToOffset(_this.getOffsetForAlignment(toOffset, align), {
      adjustments: void 0,
      behavior
    });
  };
  this.scrollToIndex = function(index, _temp2) {
    var _ref6 = _temp2 === void 0 ? {} : _temp2, _ref6$align = _ref6.align, initialAlign = _ref6$align === void 0 ? "auto" : _ref6$align, behavior = _ref6.behavior;
    index = Math.max(0, Math.min(index, _this.options.count - 1));
    _this.cancelScrollToIndex();
    if (behavior === "smooth" && _this.isDynamicMode()) {
      console.warn("The `smooth` scroll behavior is not fully supported with dynamic size.");
    }
    var _this$getOffsetForInd = _this.getOffsetForIndex(index, initialAlign), toOffset = _this$getOffsetForInd[0], align = _this$getOffsetForInd[1];
    _this._scrollToOffset(toOffset, {
      adjustments: void 0,
      behavior
    });
    if (behavior !== "smooth" && _this.isDynamicMode()) {
      _this.scrollToIndexTimeoutId = setTimeout(function() {
        _this.scrollToIndexTimeoutId = null;
        var elementInDOM = _this.measureElementCache.has(_this.options.getItemKey(index));
        if (elementInDOM) {
          var _this$getOffsetForInd2 = _this.getOffsetForIndex(index, align), _toOffset = _this$getOffsetForInd2[0];
          if (!approxEqual(_toOffset, _this.scrollOffset)) {
            _this.scrollToIndex(index, {
              align,
              behavior
            });
          }
        } else {
          _this.scrollToIndex(index, {
            align,
            behavior
          });
        }
      });
    }
  };
  this.scrollBy = function(delta, _temp3) {
    var _ref7 = _temp3 === void 0 ? {} : _temp3, behavior = _ref7.behavior;
    _this.cancelScrollToIndex();
    if (behavior === "smooth" && _this.isDynamicMode()) {
      console.warn("The `smooth` scroll behavior is not fully supported with dynamic size.");
    }
    _this._scrollToOffset(_this.scrollOffset + delta, {
      adjustments: void 0,
      behavior
    });
  };
  this.getTotalSize = function() {
    var _this$getMeasurements;
    return (((_this$getMeasurements = _this.getMeasurements()[_this.options.count - 1]) == null ? void 0 : _this$getMeasurements.end) || _this.options.paddingStart) - _this.options.scrollMargin + _this.options.paddingEnd;
  };
  this._scrollToOffset = function(offset, _ref8) {
    var adjustments = _ref8.adjustments, behavior = _ref8.behavior;
    _this.options.scrollToFn(offset, {
      behavior,
      adjustments
    }, _this);
  };
  this.measure = function() {
    _this.itemSizeCache = /* @__PURE__ */ new Map();
    _this.notify();
  };
  this.setOptions(_opts);
  this.scrollRect = this.options.initialRect;
  this.scrollOffset = this.options.initialOffset;
  this.measurementsCache = this.options.initialMeasurementsCache;
  this.measurementsCache.forEach(function(item) {
    _this.itemSizeCache.set(item.key, item.size);
  });
  this.maybeNotify();
};
var findNearestBinarySearch = function findNearestBinarySearch2(low, high, getCurrentValue, value) {
  while (low <= high) {
    var middle = (low + high) / 2 | 0;
    var currentValue = getCurrentValue(middle);
    if (currentValue < value) {
      low = middle + 1;
    } else if (currentValue > value) {
      high = middle - 1;
    } else {
      return middle;
    }
  }
  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};
function calculateRange(_ref9) {
  var measurements = _ref9.measurements, outerSize = _ref9.outerSize, scrollOffset = _ref9.scrollOffset;
  var count2 = measurements.length - 1;
  var getOffset = function getOffset2(index) {
    return measurements[index].start;
  };
  var startIndex = findNearestBinarySearch(0, count2, getOffset, scrollOffset);
  var endIndex = startIndex;
  while (endIndex < count2 && measurements[endIndex].end < scrollOffset + outerSize) {
    endIndex++;
  }
  return {
    startIndex,
    endIndex
  };
}

// node_modules/@tanstack/react-virtual/build/lib/index.mjs
var useIsomorphicLayoutEffect = typeof document !== "undefined" ? React2.useLayoutEffect : React2.useEffect;
function useVirtualizerBase(options) {
  var rerender = React2.useReducer(function() {
    return {};
  }, {})[1];
  var resolvedOptions = _extends({}, options, {
    onChange: function onChange(instance2) {
      rerender();
      options.onChange == null ? void 0 : options.onChange(instance2);
    }
  });
  var _React$useState = React2.useState(function() {
    return new Virtualizer(resolvedOptions);
  }), instance = _React$useState[0];
  instance.setOptions(resolvedOptions);
  React2.useEffect(function() {
    return instance._didMount();
  }, []);
  useIsomorphicLayoutEffect(function() {
    return instance._willUpdate();
  });
  return instance;
}
function useVirtualizer(options) {
  return useVirtualizerBase(_extends({
    observeElementRect,
    observeElementOffset,
    scrollToFn: elementScroll
  }, options));
}

// node_modules/highlight-words/dist/highlight-words.mjs
var IDX = 36;
var HEX = "";
while (IDX--) {
  HEX += IDX.toString(36);
}
function uid(len = 11) {
  let str = "";
  let num = len;
  while (num--) {
    str += HEX[Math.random() * 36 | 0];
  }
  return str;
}
var escapeRegexp = (term) => term.replace(/[|\\{}()[\]^$+*?.-]/g, (char) => `\\${char}`);
var termsToRegExpString = (terms) => terms.replace(/\s{2,}/g, " ").split(" ").join("|");
var regexpQuery = ({
  terms,
  matchExactly = false
}) => {
  if (typeof terms !== "string") {
    throw new TypeError("Expected a string");
  }
  const escapedTerms = escapeRegexp(terms.trim());
  return `(${matchExactly ? escapedTerms : termsToRegExpString(escapedTerms)})`;
};
var buildRegexp = ({
  terms,
  matchExactly = false
}) => {
  try {
    const fromString = /^([/~@;%#'])(.*?)\1([gimsuy]*)$/.exec(terms);
    if (fromString) {
      return new RegExp(fromString[2], fromString[3]);
    }
    return new RegExp(regexpQuery({ terms, matchExactly }), "ig");
  } catch (e) {
    throw new TypeError("Expected terms to be either a string or a RegExp!");
  }
};
var hasProp = (prop) => (obj) => obj !== null && typeof obj === "object" && prop in obj;
var hasMatch = hasProp("match");
var chunkExists = (chunk) => typeof chunk !== "undefined";
function clip({
  curr,
  next,
  prev,
  clipBy = 3
}) {
  const words = curr.text.split(" ");
  const len = words.length;
  if (curr.match || clipBy >= len) {
    return curr.text;
  }
  const ellipsis = "...";
  if (chunkExists(next) && chunkExists(prev) && hasMatch(prev) && hasMatch(next)) {
    if (len > clipBy * 2) {
      return [
        ...words.slice(0, clipBy),
        ellipsis,
        ...words.slice(-clipBy)
      ].join(" ");
    }
    return curr.text;
  }
  if (chunkExists(next) && hasMatch(next)) {
    return [ellipsis, ...words.slice(-clipBy)].join(" ");
  }
  if (chunkExists(prev) && hasMatch(prev)) {
    return [...words.slice(0, clipBy), ellipsis].join(" ");
  }
  return curr.text;
}
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var hasLength = (str) => str.length > 0;
var highlightWords = ({
  text: text2,
  query,
  clipBy,
  matchExactly = false
}) => {
  const safeQuery = typeof query === "string" ? query.trim() : query;
  if (safeQuery === "") {
    return [
      {
        key: uid(),
        text: text2,
        match: false
      }
    ];
  }
  const searchRegexp = buildRegexp({ terms: query, matchExactly });
  return text2.split(searchRegexp).filter(hasLength).map((str) => ({
    // Compose the object for a match
    key: uid(),
    text: str,
    match: matchExactly ? str.toLowerCase() === safeQuery.toLowerCase() : searchRegexp.test(str)
  })).map((chunk, index, chunks) => __spreadValues(__spreadValues({}, chunk), typeof clipBy === "number" && {
    // We only overwrite the text if there is a clip
    text: clip(__spreadProps(__spreadValues(__spreadValues({
      curr: chunk
    }, index < chunks.length - 1 && { next: chunks[index + 1] }), index > 0 && { prev: chunks[index - 1] }), {
      // If this wasn't the first chunk, set the previous chunk
      clipBy
    }))
  }));
};

// node_modules/material-react-table/dist/esm/material-react-table.esm.js
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
var MRT_AggregationFns = Object.assign({}, aggregationFns);
var fuzzy$1 = (row, columnId, filterValue, addMeta) => {
  const itemRank = rankItem(row.getValue(columnId), filterValue, {
    threshold: rankings.MATCHES
  });
  addMeta(itemRank);
  return itemRank.passed;
};
fuzzy$1.autoRemove = (val) => !val;
var contains = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim().includes(filterValue.toString().toLowerCase().trim());
contains.autoRemove = (val) => !val;
var startsWith = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim().startsWith(filterValue.toString().toLowerCase().trim());
startsWith.autoRemove = (val) => !val;
var endsWith = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim().endsWith(filterValue.toString().toLowerCase().trim());
endsWith.autoRemove = (val) => !val;
var equals2 = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim() === filterValue.toString().toLowerCase().trim();
equals2.autoRemove = (val) => !val;
var notEquals = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim() !== filterValue.toString().toLowerCase().trim();
notEquals.autoRemove = (val) => !val;
var greaterThan = (row, id, filterValue) => !isNaN(+filterValue) && !isNaN(+row.getValue(id)) ? +row.getValue(id) > +filterValue : row.getValue(id).toString().toLowerCase().trim() > filterValue.toString().toLowerCase().trim();
greaterThan.autoRemove = (val) => !val;
var greaterThanOrEqualTo = (row, id, filterValue) => equals2(row, id, filterValue) || greaterThan(row, id, filterValue);
greaterThanOrEqualTo.autoRemove = (val) => !val;
var lessThan = (row, id, filterValue) => !isNaN(+filterValue) && !isNaN(+row.getValue(id)) ? +row.getValue(id) < +filterValue : row.getValue(id).toString().toLowerCase().trim() < filterValue.toString().toLowerCase().trim();
lessThan.autoRemove = (val) => !val;
var lessThanOrEqualTo = (row, id, filterValue) => equals2(row, id, filterValue) || lessThan(row, id, filterValue);
lessThanOrEqualTo.autoRemove = (val) => !val;
var between = (row, id, filterValues) => (["", void 0].includes(filterValues[0]) || greaterThan(row, id, filterValues[0])) && (!isNaN(+filterValues[0]) && !isNaN(+filterValues[1]) && +filterValues[0] > +filterValues[1] || ["", void 0].includes(filterValues[1]) || lessThan(row, id, filterValues[1]));
between.autoRemove = (val) => !val;
var betweenInclusive = (row, id, filterValues) => (["", void 0].includes(filterValues[0]) || greaterThanOrEqualTo(row, id, filterValues[0])) && (!isNaN(+filterValues[0]) && !isNaN(+filterValues[1]) && +filterValues[0] > +filterValues[1] || ["", void 0].includes(filterValues[1]) || lessThanOrEqualTo(row, id, filterValues[1]));
betweenInclusive.autoRemove = (val) => !val;
var empty = (row, id, _filterValue) => !row.getValue(id).toString().trim();
empty.autoRemove = (val) => !val;
var notEmpty = (row, id, _filterValue) => !!row.getValue(id).toString().trim();
notEmpty.autoRemove = (val) => !val;
var MRT_FilterFns = Object.assign(Object.assign({}, filterFns), {
  between,
  betweenInclusive,
  contains,
  empty,
  endsWith,
  equals: equals2,
  fuzzy: fuzzy$1,
  greaterThan,
  greaterThanOrEqualTo,
  lessThan,
  lessThanOrEqualTo,
  notEmpty,
  notEquals,
  startsWith
});
var fuzzy = (rowA, rowB, columnId) => {
  let dir = 0;
  if (rowA.columnFiltersMeta[columnId]) {
    dir = compareItems(rowA.columnFiltersMeta[columnId], rowB.columnFiltersMeta[columnId]);
  }
  return dir === 0 ? sortingFns.alphanumeric(rowA, rowB, columnId) : dir;
};
var MRT_SortingFns = Object.assign(Object.assign({}, sortingFns), { fuzzy });
var rankGlobalFuzzy = (rowA, rowB) => Math.max(...Object.values(rowB.columnFiltersMeta).map((v) => v.rank)) - Math.max(...Object.values(rowA.columnFiltersMeta).map((v) => v.rank));
var getColumnId = (columnDef) => {
  var _a, _b, _c, _d;
  return (_d = (_a = columnDef.id) !== null && _a !== void 0 ? _a : (_c = (_b = columnDef.accessorKey) === null || _b === void 0 ? void 0 : _b.toString) === null || _c === void 0 ? void 0 : _c.call(_b)) !== null && _d !== void 0 ? _d : columnDef.header;
};
var getAllLeafColumnDefs = (columns) => {
  const allLeafColumnDefs = [];
  const getLeafColumns = (cols) => {
    cols.forEach((col) => {
      if (col.columns) {
        getLeafColumns(col.columns);
      } else {
        allLeafColumnDefs.push(col);
      }
    });
  };
  getLeafColumns(columns);
  return allLeafColumnDefs;
};
var prepareColumns = ({ aggregationFns: aggregationFns2, columnDefs, columnFilterFns, defaultDisplayColumn, filterFns: filterFns2, sortingFns: sortingFns2 }) => columnDefs.map((columnDef) => {
  var _a, _b;
  if (!columnDef.id)
    columnDef.id = getColumnId(columnDef);
  if (!columnDef.id) {
    console.error("Column definitions must have a valid `accessorKey` or `id` property");
  }
  if (!columnDef.columnDefType)
    columnDef.columnDefType = "data";
  if ((_a = columnDef.columns) === null || _a === void 0 ? void 0 : _a.length) {
    columnDef.columnDefType = "group";
    columnDef.columns = prepareColumns({
      aggregationFns: aggregationFns2,
      columnDefs: columnDef.columns,
      columnFilterFns,
      defaultDisplayColumn,
      filterFns: filterFns2,
      sortingFns: sortingFns2
    });
  } else if (columnDef.columnDefType === "data") {
    if (Array.isArray(columnDef.aggregationFn)) {
      const aggFns = columnDef.aggregationFn;
      columnDef.aggregationFn = (columnId, leafRows, childRows) => aggFns.map((fn) => {
        var _a2;
        return (_a2 = aggregationFns2[fn]) === null || _a2 === void 0 ? void 0 : _a2.call(aggregationFns2, columnId, leafRows, childRows);
      });
    }
    if (Object.keys(filterFns2).includes(columnFilterFns[columnDef.id])) {
      columnDef.filterFn = (_b = filterFns2[columnFilterFns[columnDef.id]]) !== null && _b !== void 0 ? _b : filterFns2.fuzzy;
      columnDef._filterFn = columnFilterFns[columnDef.id];
    }
    if (Object.keys(sortingFns2).includes(columnDef.sortingFn)) {
      columnDef.sortingFn = sortingFns2[columnDef.sortingFn];
    }
  } else if (columnDef.columnDefType === "display") {
    columnDef = Object.assign(Object.assign({}, defaultDisplayColumn), columnDef);
  }
  return columnDef;
});
var reorderColumn = (draggedColumn, targetColumn, columnOrder) => {
  if (draggedColumn.getCanPin()) {
    draggedColumn.pin(targetColumn.getIsPinned());
  }
  const newColumnOrder = [...columnOrder];
  newColumnOrder.splice(newColumnOrder.indexOf(targetColumn.id), 0, newColumnOrder.splice(newColumnOrder.indexOf(draggedColumn.id), 1)[0]);
  return newColumnOrder;
};
var showExpandColumn = (props, grouping) => !!(props.enableExpanding || props.enableGrouping && (grouping === void 0 || (grouping === null || grouping === void 0 ? void 0 : grouping.length)) || props.renderDetailPanel);
var getLeadingDisplayColumnIds = (props) => {
  var _a;
  return [
    (props.enableRowDragging || props.enableRowOrdering) && "mrt-row-drag",
    props.positionActionsColumn === "first" && (props.enableRowActions || props.enableEditing && ["row", "modal"].includes((_a = props.editingMode) !== null && _a !== void 0 ? _a : "")) && "mrt-row-actions",
    props.positionExpandColumn === "first" && showExpandColumn(props) && "mrt-row-expand",
    props.enableRowSelection && "mrt-row-select",
    props.enableRowNumbers && "mrt-row-numbers"
  ].filter(Boolean);
};
var getTrailingDisplayColumnIds = (props) => {
  var _a;
  return [
    props.positionActionsColumn === "last" && (props.enableRowActions || props.enableEditing && ["row", "modal"].includes((_a = props.editingMode) !== null && _a !== void 0 ? _a : "")) && "mrt-row-actions",
    props.positionExpandColumn === "last" && showExpandColumn(props) && "mrt-row-expand"
  ].filter(Boolean);
};
var getDefaultColumnOrderIds = (props) => {
  const leadingDisplayCols = getLeadingDisplayColumnIds(props);
  const trailingDisplayCols = getTrailingDisplayColumnIds(props);
  const allLeafColumnDefs = getAllLeafColumnDefs(props.columns).map((columnDef) => getColumnId(columnDef)).filter((columnId) => !leadingDisplayCols.includes(columnId) && !trailingDisplayCols.includes(columnId));
  return [...leadingDisplayCols, ...allLeafColumnDefs, ...trailingDisplayCols];
};
var getDefaultColumnFilterFn = (columnDef) => {
  if (columnDef.filterVariant === "multi-select")
    return "arrIncludesSome";
  if (columnDef.filterVariant === "range" || columnDef.filterVariant === "range-slider")
    return "betweenInclusive";
  if (columnDef.filterVariant === "select" || columnDef.filterVariant === "checkbox")
    return "equals";
  return "fuzzy";
};
var getIsFirstColumn = (column, table) => {
  return table.getVisibleLeafColumns()[0].id === column.id;
};
var getIsLastColumn = (column, table) => {
  const columns = table.getVisibleLeafColumns();
  return columns[columns.length - 1].id === column.id;
};
var getIsLastLeftPinnedColumn = (table, column) => {
  return column.getIsPinned() === "left" && table.getLeftLeafHeaders().length - 1 === column.getPinnedIndex();
};
var getIsFirstRightPinnedColumn = (column) => {
  return column.getIsPinned() === "right" && column.getPinnedIndex() === 0;
};
var getTotalRight = (table, column) => {
  return table.getRightLeafHeaders().slice(column.getPinnedIndex() + 1).reduce((acc, col) => acc + col.getSize(), 0);
};
var getCommonCellStyles = ({ column, header, table, tableCellProps, theme }) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
  const widthStyles = {
    minWidth: `max(calc(var(--${header ? "header" : "col"}-${parseCSSVarId((_a = header === null || header === void 0 ? void 0 : header.id) !== null && _a !== void 0 ? _a : column.id)}-size) * 1px), ${(_b = column.columnDef.minSize) !== null && _b !== void 0 ? _b : 30}px)`,
    width: `calc(var(--${header ? "header" : "col"}-${parseCSSVarId((_c = header === null || header === void 0 ? void 0 : header.id) !== null && _c !== void 0 ? _c : column.id)}-size) * 1px)`
  };
  return Object.assign(Object.assign(Object.assign({ backgroundColor: column.getIsPinned() && column.columnDef.columnDefType !== "group" ? alpha(lighten(theme.palette.background.default, 0.04), 0.97) : "inherit", backgroundImage: "inherit", boxShadow: getIsLastLeftPinnedColumn(table, column) ? `-4px 0 8px -6px ${alpha(theme.palette.common.black, 0.2)} inset` : getIsFirstRightPinnedColumn(column) ? `4px 0 8px -6px ${alpha(theme.palette.common.black, 0.2)} inset` : void 0, display: table.options.layoutMode === "grid" ? "flex" : "table-cell", flex: table.options.layoutMode === "grid" ? `var(--${header ? "header" : "col"}-${parseCSSVarId((_d = header === null || header === void 0 ? void 0 : header.id) !== null && _d !== void 0 ? _d : column.id)}-size) 0 auto` : void 0, left: column.getIsPinned() === "left" ? `${column.getStart("left")}px` : void 0, ml: table.options.enableColumnVirtualization && column.getIsPinned() === "left" && column.getPinnedIndex() === 0 ? `-${column.getSize() * ((_f = (_e = table.getState().columnPinning.left) === null || _e === void 0 ? void 0 : _e.length) !== null && _f !== void 0 ? _f : 1)}px` : void 0, mr: table.options.enableColumnVirtualization && column.getIsPinned() === "right" && column.getPinnedIndex() === table.getVisibleLeafColumns().length - 1 ? `-${column.getSize() * ((_h = (_g = table.getState().columnPinning.right) === null || _g === void 0 ? void 0 : _g.length) !== null && _h !== void 0 ? _h : 1) * 1.2}px` : void 0, opacity: ((_j = table.getState().draggingColumn) === null || _j === void 0 ? void 0 : _j.id) === column.id || ((_k = table.getState().hoveredColumn) === null || _k === void 0 ? void 0 : _k.id) === column.id ? 0.5 : 1, position: column.getIsPinned() && column.columnDef.columnDefType !== "group" ? "sticky" : void 0, right: column.getIsPinned() === "right" ? `${getTotalRight(table, column)}px` : void 0, transition: table.options.enableColumnVirtualization ? "none" : `padding 150ms ease-in-out` }, !table.options.enableColumnResizing && widthStyles), (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx) instanceof Function ? tableCellProps.sx(theme) : tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx), table.options.enableColumnResizing && widthStyles);
};
var MRT_DefaultColumn = {
  filterVariant: "text",
  minSize: 40,
  maxSize: 1e3,
  size: 180
};
var MRT_DefaultDisplayColumn = {
  columnDefType: "display",
  enableClickToCopy: false,
  enableColumnActions: false,
  enableColumnDragging: false,
  enableColumnFilter: false,
  enableColumnOrdering: false,
  enableEditing: false,
  enableGlobalFilter: false,
  enableGrouping: false,
  enableHiding: false,
  enableResizing: false,
  enableSorting: false
};
var parseCSSVarId = (id) => id.replace(/[^a-zA-Z0-9]/g, "_");
var MRT_Default_Icons = {
  ArrowDownwardIcon: import_ArrowDownward.default,
  ArrowRightIcon: import_ArrowRight.default,
  CancelIcon: import_Cancel.default,
  ClearAllIcon: import_ClearAll.default,
  CloseIcon: import_Close.default,
  DensityLargeIcon: import_DensityLarge.default,
  DensityMediumIcon: import_DensityMedium.default,
  DensitySmallIcon: import_DensitySmall.default,
  DragHandleIcon: import_DragHandle.default,
  DynamicFeedIcon: import_DynamicFeed.default,
  EditIcon: import_Edit.default,
  ExpandMoreIcon: import_ExpandMore.default,
  FilterAltIcon: import_FilterAlt.default,
  FilterListIcon: import_FilterList.default,
  FilterListOffIcon: import_FilterListOff.default,
  FullscreenExitIcon: import_FullscreenExit.default,
  FullscreenIcon: import_Fullscreen.default,
  KeyboardDoubleArrowDownIcon: import_KeyboardDoubleArrowDown.default,
  MoreHorizIcon: import_MoreHoriz.default,
  MoreVertIcon: import_MoreVert.default,
  PushPinIcon: import_PushPin.default,
  RestartAltIcon: import_RestartAlt.default,
  SaveIcon: import_Save.default,
  SearchIcon: import_Search.default,
  SearchOffIcon: import_SearchOff.default,
  SortIcon: import_Sort.default,
  ViewColumnIcon: import_ViewColumn.default,
  VisibilityOffIcon: import_VisibilityOff.default
};
var MRT_Localization_EN = {
  actions: "Actions",
  and: "and",
  cancel: "Cancel",
  changeFilterMode: "Change filter mode",
  changeSearchMode: "Change search mode",
  clearFilter: "Clear filter",
  clearSearch: "Clear search",
  clearSort: "Clear sort",
  clickToCopy: "Click to copy",
  collapse: "Collapse",
  collapseAll: "Collapse all",
  columnActions: "Column Actions",
  copiedToClipboard: "Copied to clipboard",
  dropToGroupBy: "Drop to group by {column}",
  edit: "Edit",
  expand: "Expand",
  expandAll: "Expand all",
  filterArrIncludes: "Includes",
  filterArrIncludesAll: "Includes all",
  filterArrIncludesSome: "Includes",
  filterBetween: "Between",
  filterBetweenInclusive: "Between Inclusive",
  filterByColumn: "Filter by {column}",
  filterContains: "Contains",
  filterEmpty: "Empty",
  filterEndsWith: "Ends With",
  filterEquals: "Equals",
  filterEqualsString: "Equals",
  filterFuzzy: "Fuzzy",
  filterGreaterThan: "Greater Than",
  filterGreaterThanOrEqualTo: "Greater Than Or Equal To",
  filterInNumberRange: "Between",
  filterIncludesString: "Contains",
  filterIncludesStringSensitive: "Contains",
  filterLessThan: "Less Than",
  filterLessThanOrEqualTo: "Less Than Or Equal To",
  filterMode: "Filter Mode: {filterType}",
  filterNotEmpty: "Not Empty",
  filterNotEquals: "Not Equals",
  filterStartsWith: "Starts With",
  filterWeakEquals: "Equals",
  filteringByColumn: "Filtering by {column} - {filterType} {filterValue}",
  goToFirstPage: "Go to first page",
  goToLastPage: "Go to last page",
  goToNextPage: "Go to next page",
  goToPreviousPage: "Go to previous page",
  grab: "Grab",
  groupByColumn: "Group by {column}",
  groupedBy: "Grouped by ",
  hideAll: "Hide all",
  hideColumn: "Hide {column} column",
  max: "Max",
  min: "Min",
  move: "Move",
  noRecordsToDisplay: "No records to display",
  noResultsFound: "No results found",
  of: "of",
  or: "or",
  pinToLeft: "Pin to left",
  pinToRight: "Pin to right",
  resetColumnSize: "Reset column size",
  resetOrder: "Reset order",
  rowActions: "Row Actions",
  rowNumber: "#",
  rowNumbers: "Row Numbers",
  rowsPerPage: "Rows per page",
  save: "Save",
  search: "Search",
  selectedCountOfRowCountRowsSelected: "{selectedCount} of {rowCount} row(s) selected",
  select: "Select",
  showAll: "Show all",
  showAllColumns: "Show all columns",
  showHideColumns: "Show/Hide columns",
  showHideFilters: "Show/Hide filters",
  showHideSearch: "Show/Hide search",
  sortByColumnAsc: "Sort by {column} ascending",
  sortByColumnDesc: "Sort by {column} descending",
  sortedByColumnAsc: "Sorted by {column} ascending",
  sortedByColumnDesc: "Sorted by {column} descending",
  thenBy: ", then by ",
  toggleDensity: "Toggle density",
  toggleFullScreen: "Toggle full screen",
  toggleSelectAll: "Toggle select all",
  toggleSelectRow: "Toggle select row",
  toggleVisibility: "Toggle visibility",
  ungroupByColumn: "Ungroup by {column}",
  unpin: "Unpin",
  unpinAll: "Unpin all",
  unsorted: "Unsorted"
};
var MRT_ExpandAllButton = ({ table }) => {
  var _a, _b;
  const { getIsAllRowsExpanded, getIsSomeRowsExpanded, getCanSomeRowsExpand, getState, options: { icons: { KeyboardDoubleArrowDownIcon: KeyboardDoubleArrowDownIcon2 }, localization, muiExpandAllButtonProps, renderDetailPanel }, toggleAllRowsExpanded } = table;
  const { density, isLoading } = getState();
  const iconButtonProps = muiExpandAllButtonProps instanceof Function ? muiExpandAllButtonProps({ table }) : muiExpandAllButtonProps;
  const isAllRowsExpanded = getIsAllRowsExpanded();
  return (0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, enterDelay: 1e3, enterNextDelay: 1e3, title: ((_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.title) !== null && _a !== void 0 ? _a : isAllRowsExpanded) ? localization.collapseAll : localization.expandAll, children: (0, import_jsx_runtime.jsx)("span", { children: (0, import_jsx_runtime.jsx)(IconButton_default, Object.assign({ "aria-label": localization.expandAll, disabled: isLoading || !renderDetailPanel && !getCanSomeRowsExpand(), onClick: () => toggleAllRowsExpanded(!isAllRowsExpanded) }, iconButtonProps, { sx: (theme) => Object.assign({ height: density === "compact" ? "1.75rem" : "2.25rem", width: density === "compact" ? "1.75rem" : "2.25rem", mt: density !== "compact" ? "-0.25rem" : void 0 }, (iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx) instanceof Function ? iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx(theme) : iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx), title: void 0, children: (_b = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.children) !== null && _b !== void 0 ? _b : (0, import_jsx_runtime.jsx)(KeyboardDoubleArrowDownIcon2, { style: {
    transform: `rotate(${isAllRowsExpanded ? -180 : getIsSomeRowsExpanded() ? -90 : 0}deg)`,
    transition: "transform 150ms"
  } }) })) }) });
};
var MRT_ExpandButton = ({ row, table }) => {
  var _a, _b;
  const { getState, options: { icons: { ExpandMoreIcon: ExpandMoreIcon2 }, localization, muiExpandButtonProps, renderDetailPanel } } = table;
  const { density } = getState();
  const iconButtonProps = muiExpandButtonProps instanceof Function ? muiExpandButtonProps({ table, row }) : muiExpandButtonProps;
  const canExpand = row.getCanExpand();
  const isExpanded = row.getIsExpanded();
  const handleToggleExpand = (event) => {
    var _a2;
    event.stopPropagation();
    row.toggleExpanded();
    (_a2 = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(iconButtonProps, event);
  };
  return (0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, disableHoverListener: !canExpand && !renderDetailPanel, enterDelay: 1e3, enterNextDelay: 1e3, title: ((_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.title) !== null && _a !== void 0 ? _a : isExpanded) ? localization.collapse : localization.expand, children: (0, import_jsx_runtime.jsx)("span", { children: (0, import_jsx_runtime.jsx)(IconButton_default, Object.assign({ "aria-label": localization.expand, disabled: !canExpand && !renderDetailPanel }, iconButtonProps, { onClick: handleToggleExpand, sx: (theme) => Object.assign({ height: density === "compact" ? "1.75rem" : "2.25rem", width: density === "compact" ? "1.75rem" : "2.25rem" }, (iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx) instanceof Function ? iconButtonProps.sx(theme) : iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx), title: void 0, children: (_b = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.children) !== null && _b !== void 0 ? _b : (0, import_jsx_runtime.jsx)(ExpandMoreIcon2, { style: {
    transform: `rotate(${!canExpand && !renderDetailPanel ? -90 : isExpanded ? -180 : 0}deg)`,
    transition: "transform 150ms"
  } }) })) }) });
};
var mrtFilterOptions = (localization) => [
  {
    option: "fuzzy",
    symbol: "≈",
    label: localization.filterFuzzy,
    divider: false
  },
  {
    option: "contains",
    symbol: "*",
    label: localization.filterContains,
    divider: false
  },
  {
    option: "startsWith",
    symbol: "a",
    label: localization.filterStartsWith,
    divider: false
  },
  {
    option: "endsWith",
    symbol: "z",
    label: localization.filterEndsWith,
    divider: true
  },
  {
    option: "equals",
    symbol: "=",
    label: localization.filterEquals,
    divider: false
  },
  {
    option: "notEquals",
    symbol: "≠",
    label: localization.filterNotEquals,
    divider: true
  },
  {
    option: "between",
    symbol: "⇿",
    label: localization.filterBetween,
    divider: false
  },
  {
    option: "betweenInclusive",
    symbol: "⬌",
    label: localization.filterBetweenInclusive,
    divider: true
  },
  {
    option: "greaterThan",
    symbol: ">",
    label: localization.filterGreaterThan,
    divider: false
  },
  {
    option: "greaterThanOrEqualTo",
    symbol: "≥",
    label: localization.filterGreaterThanOrEqualTo,
    divider: false
  },
  {
    option: "lessThan",
    symbol: "<",
    label: localization.filterLessThan,
    divider: false
  },
  {
    option: "lessThanOrEqualTo",
    symbol: "≤",
    label: localization.filterLessThanOrEqualTo,
    divider: true
  },
  {
    option: "empty",
    symbol: "∅",
    label: localization.filterEmpty,
    divider: false
  },
  {
    option: "notEmpty",
    symbol: "!∅",
    label: localization.filterNotEmpty,
    divider: false
  }
];
var rangeModes = ["between", "betweenInclusive", "inNumberRange"];
var emptyModes = ["empty", "notEmpty"];
var arrModes = ["arrIncludesSome", "arrIncludesAll", "arrIncludes"];
var MRT_FilterOptionMenu = ({ anchorEl, header, onSelect, setAnchorEl, setFilterValue, table }) => {
  var _a, _b, _c, _d;
  const { getState, options: { columnFilterModeOptions, globalFilterModeOptions, localization, renderColumnFilterModeMenuItems, renderGlobalFilterModeMenuItems }, setColumnFilterFns, setGlobalFilterFn } = table;
  const { globalFilterFn, density } = getState();
  const { column } = header !== null && header !== void 0 ? header : {};
  const { columnDef } = column !== null && column !== void 0 ? column : {};
  const currentFilterValue = column === null || column === void 0 ? void 0 : column.getFilterValue();
  let allowedColumnFilterOptions = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _a !== void 0 ? _a : columnFilterModeOptions;
  if ((columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant) === "range-slider") {
    allowedColumnFilterOptions = [
      ...rangeModes,
      ...allowedColumnFilterOptions !== null && allowedColumnFilterOptions !== void 0 ? allowedColumnFilterOptions : []
    ].filter((option) => rangeModes.includes(option));
  }
  const internalFilterOptions = (0, import_react.useMemo)(() => mrtFilterOptions(localization).filter((filterOption2) => columnDef ? allowedColumnFilterOptions === void 0 || (allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.includes(filterOption2.option)) : (!globalFilterModeOptions || globalFilterModeOptions.includes(filterOption2.option)) && ["fuzzy", "contains", "startsWith"].includes(filterOption2.option)), []);
  const handleSelectFilterMode = (option) => {
    var _a2;
    const prevFilterMode = (_a2 = columnDef === null || columnDef === void 0 ? void 0 : columnDef._filterFn) !== null && _a2 !== void 0 ? _a2 : "";
    if (!header || !column) {
      setGlobalFilterFn(option);
    } else if (option !== prevFilterMode) {
      setColumnFilterFns((prev) => Object.assign(Object.assign({}, prev), { [header.id]: option }));
      if (emptyModes.includes(option)) {
        if (currentFilterValue !== " " && !emptyModes.includes(prevFilterMode)) {
          column.setFilterValue(" ");
        } else if (currentFilterValue) {
          column.setFilterValue(currentFilterValue);
        }
      } else if ((columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant) === "multi-select" || arrModes.includes(option)) {
        if (currentFilterValue instanceof String || (currentFilterValue === null || currentFilterValue === void 0 ? void 0 : currentFilterValue.length)) {
          column.setFilterValue([]);
          setFilterValue === null || setFilterValue === void 0 ? void 0 : setFilterValue([]);
        } else if (currentFilterValue) {
          column.setFilterValue(currentFilterValue);
        }
      } else if ((columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant) === "range" || rangeModes.includes(option)) {
        if (!Array.isArray(currentFilterValue) || !(currentFilterValue === null || currentFilterValue === void 0 ? void 0 : currentFilterValue.every((v) => v === "")) && !rangeModes.includes(prevFilterMode)) {
          column.setFilterValue(["", ""]);
          setFilterValue === null || setFilterValue === void 0 ? void 0 : setFilterValue("");
        } else {
          column.setFilterValue(currentFilterValue);
        }
      } else {
        if (Array.isArray(currentFilterValue)) {
          column.setFilterValue("");
          setFilterValue === null || setFilterValue === void 0 ? void 0 : setFilterValue("");
        } else {
          column.setFilterValue(currentFilterValue);
        }
      }
    }
    setAnchorEl(null);
    onSelect === null || onSelect === void 0 ? void 0 : onSelect();
  };
  const filterOption = !!header && columnDef ? columnDef._filterFn : globalFilterFn;
  return (0, import_jsx_runtime.jsx)(Menu_default, { anchorEl, anchorOrigin: { vertical: "center", horizontal: "right" }, onClose: () => setAnchorEl(null), open: !!anchorEl, MenuListProps: {
    dense: density === "compact"
  }, children: (_d = header && column && columnDef ? (_c = (_b = columnDef.renderColumnFilterModeMenuItems) === null || _b === void 0 ? void 0 : _b.call(columnDef, {
    column,
    internalFilterOptions,
    onSelectFilterMode: handleSelectFilterMode,
    table
  })) !== null && _c !== void 0 ? _c : renderColumnFilterModeMenuItems === null || renderColumnFilterModeMenuItems === void 0 ? void 0 : renderColumnFilterModeMenuItems({
    column,
    internalFilterOptions,
    onSelectFilterMode: handleSelectFilterMode,
    table
  }) : renderGlobalFilterModeMenuItems === null || renderGlobalFilterModeMenuItems === void 0 ? void 0 : renderGlobalFilterModeMenuItems({
    internalFilterOptions,
    onSelectFilterMode: handleSelectFilterMode,
    table
  })) !== null && _d !== void 0 ? _d : internalFilterOptions.map(({ option, label, divider, symbol }, index) => (0, import_jsx_runtime.jsxs)(MenuItem_default, { divider, onClick: () => handleSelectFilterMode(option), selected: option === filterOption, sx: {
    alignItems: "center",
    display: "flex",
    gap: "2ch",
    my: 0,
    py: "6px"
  }, value: option, children: [(0, import_jsx_runtime.jsx)(Box_default, { sx: { fontSize: "1.25rem", width: "2ch" }, children: symbol }), label] }, index)) });
};
var commonMenuItemStyles = {
  py: "6px",
  my: 0,
  justifyContent: "space-between",
  alignItems: "center"
};
var commonListItemStyles = {
  display: "flex",
  alignItems: "center"
};
var MRT_ColumnActionMenu = ({ anchorEl, header, setAnchorEl, table }) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
  const { getState, toggleAllColumnsVisible, setColumnOrder, options: { columnFilterModeOptions, enableColumnFilterModes, enableColumnFilters, enableColumnResizing, enableGrouping, enableHiding, enablePinning, enableSorting, enableSortingRemoval, icons: { ArrowRightIcon: ArrowRightIcon2, ClearAllIcon: ClearAllIcon2, ViewColumnIcon: ViewColumnIcon2, DynamicFeedIcon: DynamicFeedIcon2, FilterListIcon: FilterListIcon2, FilterListOffIcon: FilterListOffIcon2, PushPinIcon: PushPinIcon2, SortIcon: SortIcon2, RestartAltIcon: RestartAltIcon2, VisibilityOffIcon: VisibilityOffIcon2 }, localization, renderColumnActionsMenuItems }, refs: { filterInputRefs }, setColumnSizingInfo, setShowColumnFilters } = table;
  const { column } = header;
  const { columnDef } = column;
  const { columnSizing, columnVisibility, density, showColumnFilters } = getState();
  const columnFilterValue = column.getFilterValue();
  const [filterMenuAnchorEl, setFilterMenuAnchorEl] = (0, import_react.useState)(null);
  const handleClearSort = () => {
    column.clearSorting();
    setAnchorEl(null);
  };
  const handleSortAsc = () => {
    column.toggleSorting(false);
    setAnchorEl(null);
  };
  const handleSortDesc = () => {
    column.toggleSorting(true);
    setAnchorEl(null);
  };
  const handleResetColumnSize = () => {
    setColumnSizingInfo((old) => Object.assign(Object.assign({}, old), { isResizingColumn: false }));
    column.resetSize();
    setAnchorEl(null);
  };
  const handleHideColumn = () => {
    column.toggleVisibility(false);
    setAnchorEl(null);
  };
  const handlePinColumn = (pinDirection) => {
    column.pin(pinDirection);
    setAnchorEl(null);
  };
  const handleGroupByColumn = () => {
    column.toggleGrouping();
    setColumnOrder((old) => ["mrt-row-expand", ...old]);
    setAnchorEl(null);
  };
  const handleClearFilter = () => {
    column.setFilterValue("");
    setAnchorEl(null);
  };
  const handleFilterByColumn = () => {
    setShowColumnFilters(true);
    queueMicrotask(() => {
      var _a2;
      return (_a2 = filterInputRefs.current[`${column.id}-0`]) === null || _a2 === void 0 ? void 0 : _a2.focus();
    });
    setAnchorEl(null);
  };
  const handleShowAllColumns = () => {
    toggleAllColumnsVisible(true);
    setAnchorEl(null);
  };
  const handleOpenFilterModeMenu = (event) => {
    event.stopPropagation();
    setFilterMenuAnchorEl(event.currentTarget);
  };
  const isSelectFilter = !!columnDef.filterSelectOptions;
  const allowedColumnFilterOptions = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _a !== void 0 ? _a : columnFilterModeOptions;
  const showFilterModeSubMenu = enableColumnFilterModes && columnDef.enableColumnFilterModes !== false && !isSelectFilter && (allowedColumnFilterOptions === void 0 || !!(allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.length));
  const internalColumnMenuItems = [
    ...enableSorting && column.getCanSort() ? [
      enableSortingRemoval !== false && (0, import_jsx_runtime.jsx)(MenuItem_default, { disabled: !column.getIsSorted(), onClick: handleClearSort, sx: commonMenuItemStyles, children: (0, import_jsx_runtime.jsxs)(Box_default, { sx: commonListItemStyles, children: [(0, import_jsx_runtime.jsx)(ListItemIcon_default, { children: (0, import_jsx_runtime.jsx)(ClearAllIcon2, {}) }), localization.clearSort] }) }, 0),
      (0, import_jsx_runtime.jsx)(MenuItem_default, { disabled: column.getIsSorted() === "asc", onClick: handleSortAsc, sx: commonMenuItemStyles, children: (0, import_jsx_runtime.jsxs)(Box_default, { sx: commonListItemStyles, children: [(0, import_jsx_runtime.jsx)(ListItemIcon_default, { children: (0, import_jsx_runtime.jsx)(SortIcon2, { style: { transform: "rotate(180deg) scaleX(-1)" } }) }), (_b = localization.sortByColumnAsc) === null || _b === void 0 ? void 0 : _b.replace("{column}", String(columnDef.header))] }) }, 1),
      (0, import_jsx_runtime.jsx)(MenuItem_default, { divider: enableColumnFilters || enableGrouping || enableHiding, disabled: column.getIsSorted() === "desc", onClick: handleSortDesc, sx: commonMenuItemStyles, children: (0, import_jsx_runtime.jsxs)(Box_default, { sx: commonListItemStyles, children: [(0, import_jsx_runtime.jsx)(ListItemIcon_default, { children: (0, import_jsx_runtime.jsx)(SortIcon2, {}) }), (_c = localization.sortByColumnDesc) === null || _c === void 0 ? void 0 : _c.replace("{column}", String(columnDef.header))] }) }, 2)
    ] : [],
    ...enableColumnFilters && column.getCanFilter() ? [
      (0, import_jsx_runtime.jsx)(MenuItem_default, { disabled: !columnFilterValue || Array.isArray(columnFilterValue) && !columnFilterValue.filter((value) => value).length, onClick: handleClearFilter, sx: commonMenuItemStyles, children: (0, import_jsx_runtime.jsxs)(Box_default, { sx: commonListItemStyles, children: [(0, import_jsx_runtime.jsx)(ListItemIcon_default, { children: (0, import_jsx_runtime.jsx)(FilterListOffIcon2, {}) }), localization.clearFilter] }) }, 3),
      (0, import_jsx_runtime.jsxs)(MenuItem_default, { disabled: showColumnFilters && !enableColumnFilterModes, divider: enableGrouping || enableHiding, onClick: showColumnFilters ? handleOpenFilterModeMenu : handleFilterByColumn, sx: commonMenuItemStyles, children: [(0, import_jsx_runtime.jsxs)(Box_default, { sx: commonListItemStyles, children: [(0, import_jsx_runtime.jsx)(ListItemIcon_default, { children: (0, import_jsx_runtime.jsx)(FilterListIcon2, {}) }), (_d = localization.filterByColumn) === null || _d === void 0 ? void 0 : _d.replace("{column}", String(columnDef.header))] }), showFilterModeSubMenu && (0, import_jsx_runtime.jsx)(IconButton_default, { onClick: handleOpenFilterModeMenu, onMouseEnter: handleOpenFilterModeMenu, size: "small", sx: { p: 0 }, children: (0, import_jsx_runtime.jsx)(ArrowRightIcon2, {}) })] }, 4),
      showFilterModeSubMenu && (0, import_jsx_runtime.jsx)(MRT_FilterOptionMenu, { anchorEl: filterMenuAnchorEl, header, onSelect: handleFilterByColumn, setAnchorEl: setFilterMenuAnchorEl, table }, 5)
    ] : [],
    ...enableGrouping && column.getCanGroup() ? [
      (0, import_jsx_runtime.jsx)(MenuItem_default, { divider: enablePinning, onClick: handleGroupByColumn, sx: commonMenuItemStyles, children: (0, import_jsx_runtime.jsxs)(Box_default, { sx: commonListItemStyles, children: [(0, import_jsx_runtime.jsx)(ListItemIcon_default, { children: (0, import_jsx_runtime.jsx)(DynamicFeedIcon2, {}) }), (_e = localization[column.getIsGrouped() ? "ungroupByColumn" : "groupByColumn"]) === null || _e === void 0 ? void 0 : _e.replace("{column}", String(columnDef.header))] }) }, 6)
    ] : [],
    ...enablePinning && column.getCanPin() ? [
      (0, import_jsx_runtime.jsx)(MenuItem_default, { disabled: column.getIsPinned() === "left" || !column.getCanPin(), onClick: () => handlePinColumn("left"), sx: commonMenuItemStyles, children: (0, import_jsx_runtime.jsxs)(Box_default, { sx: commonListItemStyles, children: [(0, import_jsx_runtime.jsx)(ListItemIcon_default, { children: (0, import_jsx_runtime.jsx)(PushPinIcon2, { style: { transform: "rotate(90deg)" } }) }), localization.pinToLeft] }) }, 7),
      (0, import_jsx_runtime.jsx)(MenuItem_default, { disabled: column.getIsPinned() === "right" || !column.getCanPin(), onClick: () => handlePinColumn("right"), sx: commonMenuItemStyles, children: (0, import_jsx_runtime.jsxs)(Box_default, { sx: commonListItemStyles, children: [(0, import_jsx_runtime.jsx)(ListItemIcon_default, { children: (0, import_jsx_runtime.jsx)(PushPinIcon2, { style: { transform: "rotate(-90deg)" } }) }), localization.pinToRight] }) }, 8),
      (0, import_jsx_runtime.jsx)(MenuItem_default, { disabled: !column.getIsPinned(), divider: enableHiding, onClick: () => handlePinColumn(false), sx: commonMenuItemStyles, children: (0, import_jsx_runtime.jsxs)(Box_default, { sx: commonListItemStyles, children: [(0, import_jsx_runtime.jsx)(ListItemIcon_default, { children: (0, import_jsx_runtime.jsx)(PushPinIcon2, {}) }), localization.unpin] }) }, 9)
    ] : [],
    ...enableColumnResizing && column.getCanResize() ? [
      (0, import_jsx_runtime.jsx)(MenuItem_default, { disabled: !columnSizing[column.id], onClick: handleResetColumnSize, sx: commonMenuItemStyles, children: (0, import_jsx_runtime.jsxs)(Box_default, { sx: commonListItemStyles, children: [(0, import_jsx_runtime.jsx)(ListItemIcon_default, { children: (0, import_jsx_runtime.jsx)(RestartAltIcon2, {}) }), localization.resetColumnSize] }) }, 10)
    ] : [],
    ...enableHiding ? [
      (0, import_jsx_runtime.jsx)(MenuItem_default, { disabled: !column.getCanHide(), onClick: handleHideColumn, sx: commonMenuItemStyles, children: (0, import_jsx_runtime.jsxs)(Box_default, { sx: commonListItemStyles, children: [(0, import_jsx_runtime.jsx)(ListItemIcon_default, { children: (0, import_jsx_runtime.jsx)(VisibilityOffIcon2, {}) }), (_f = localization.hideColumn) === null || _f === void 0 ? void 0 : _f.replace("{column}", String(columnDef.header))] }) }, 11),
      (0, import_jsx_runtime.jsx)(MenuItem_default, { disabled: !Object.values(columnVisibility).filter((visible) => !visible).length, onClick: handleShowAllColumns, sx: commonMenuItemStyles, children: (0, import_jsx_runtime.jsxs)(Box_default, { sx: commonListItemStyles, children: [(0, import_jsx_runtime.jsx)(ListItemIcon_default, { children: (0, import_jsx_runtime.jsx)(ViewColumnIcon2, {}) }), (_g = localization.showAllColumns) === null || _g === void 0 ? void 0 : _g.replace("{column}", String(columnDef.header))] }) }, 12)
    ] : []
  ].filter(Boolean);
  return (0, import_jsx_runtime.jsx)(Menu_default, { anchorEl, open: !!anchorEl, onClose: () => setAnchorEl(null), MenuListProps: {
    dense: density === "compact"
  }, children: (_k = (_j = (_h = columnDef.renderColumnActionsMenuItems) === null || _h === void 0 ? void 0 : _h.call(columnDef, {
    closeMenu: () => setAnchorEl(null),
    column,
    internalColumnMenuItems,
    table
  })) !== null && _j !== void 0 ? _j : renderColumnActionsMenuItems === null || renderColumnActionsMenuItems === void 0 ? void 0 : renderColumnActionsMenuItems({
    closeMenu: () => setAnchorEl(null),
    column,
    internalColumnMenuItems,
    table
  })) !== null && _k !== void 0 ? _k : internalColumnMenuItems });
};
var MRT_RowActionMenu = ({ anchorEl, handleEdit, row, setAnchorEl, table }) => {
  const { getState, options: { icons: { EditIcon: EditIcon2 }, enableEditing, localization, renderRowActionMenuItems } } = table;
  const { density } = getState();
  return (0, import_jsx_runtime.jsxs)(Menu_default, { anchorEl, open: !!anchorEl, onClick: (event) => event.stopPropagation(), onClose: () => setAnchorEl(null), MenuListProps: {
    dense: density === "compact"
  }, children: [enableEditing instanceof Function ? enableEditing(row) : enableEditing && (0, import_jsx_runtime.jsx)(MenuItem_default, { onClick: handleEdit, sx: commonMenuItemStyles, children: (0, import_jsx_runtime.jsxs)(Box_default, { sx: commonListItemStyles, children: [(0, import_jsx_runtime.jsx)(ListItemIcon_default, { children: (0, import_jsx_runtime.jsx)(EditIcon2, {}) }), localization.edit] }) }), renderRowActionMenuItems === null || renderRowActionMenuItems === void 0 ? void 0 : renderRowActionMenuItems({
    row,
    table,
    closeMenu: () => setAnchorEl(null)
  })] });
};
var MRT_EditActionButtons = ({ row, table, variant = "icon" }) => {
  const { getState, options: { icons: { CancelIcon: CancelIcon2, SaveIcon: SaveIcon2 }, localization, onEditingRowSave, onEditingRowCancel }, refs: { editInputRefs }, setEditingRow } = table;
  const { editingRow } = getState();
  const handleCancel = () => {
    onEditingRowCancel === null || onEditingRowCancel === void 0 ? void 0 : onEditingRowCancel({ row, table });
    setEditingRow(null);
  };
  const handleSave = () => {
    var _a, _b;
    (_a = Object.values(editInputRefs === null || editInputRefs === void 0 ? void 0 : editInputRefs.current)) === null || _a === void 0 ? void 0 : _a.forEach((input) => {
      if (input.value !== void 0 && Object.hasOwn(editingRow === null || editingRow === void 0 ? void 0 : editingRow._valuesCache, input.name)) {
        editingRow._valuesCache[input.name] = input.value;
      }
    });
    onEditingRowSave === null || onEditingRowSave === void 0 ? void 0 : onEditingRowSave({
      exitEditingMode: () => setEditingRow(null),
      row: editingRow !== null && editingRow !== void 0 ? editingRow : row,
      table,
      values: (_b = editingRow === null || editingRow === void 0 ? void 0 : editingRow._valuesCache) !== null && _b !== void 0 ? _b : Object.assign({}, row.original)
    });
  };
  return (0, import_jsx_runtime.jsx)(Box_default, { onClick: (e) => e.stopPropagation(), sx: { display: "flex", gap: "0.75rem" }, children: variant === "icon" ? (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, title: localization.cancel, children: (0, import_jsx_runtime.jsx)(IconButton_default, { "aria-label": localization.cancel, onClick: handleCancel, children: (0, import_jsx_runtime.jsx)(CancelIcon2, {}) }) }), (0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, title: localization.save, children: (0, import_jsx_runtime.jsx)(IconButton_default, { "aria-label": localization.save, color: "info", onClick: handleSave, children: (0, import_jsx_runtime.jsx)(SaveIcon2, {}) }) })] }) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(Button_default, { onClick: handleCancel, children: localization.cancel }), (0, import_jsx_runtime.jsx)(Button_default, { onClick: handleSave, variant: "contained", children: localization.save })] }) });
};
var commonIconButtonStyles = {
  height: "2rem",
  ml: "10px",
  opacity: 0.5,
  transition: "opacity 150ms",
  width: "2rem",
  "&:hover": {
    opacity: 1
  }
};
var MRT_ToggleRowActionMenuButton = ({ cell, row, table }) => {
  const { getState, options: { editingMode, enableEditing, icons: { EditIcon: EditIcon2, MoreHorizIcon: MoreHorizIcon2 }, localization, renderRowActionMenuItems, renderRowActions }, setEditingRow } = table;
  const { editingRow } = getState();
  const [anchorEl, setAnchorEl] = (0, import_react.useState)(null);
  const handleOpenRowActionMenu = (event) => {
    event.stopPropagation();
    event.preventDefault();
    setAnchorEl(event.currentTarget);
  };
  const handleStartEditMode = (event) => {
    event.stopPropagation();
    setEditingRow(Object.assign({}, row));
    setAnchorEl(null);
  };
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: renderRowActions ? renderRowActions({ cell, row, table }) : row.id === (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) && editingMode === "row" ? (0, import_jsx_runtime.jsx)(MRT_EditActionButtons, { row, table }) : !renderRowActionMenuItems && (enableEditing instanceof Function ? enableEditing(row) : enableEditing) ? (0, import_jsx_runtime.jsx)(Tooltip_default, { placement: "right", arrow: true, title: localization.edit, children: (0, import_jsx_runtime.jsx)(IconButton_default, { "aria-label": localization.edit, sx: commonIconButtonStyles, onClick: handleStartEditMode, children: (0, import_jsx_runtime.jsx)(EditIcon2, {}) }) }) : renderRowActionMenuItems ? (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, enterDelay: 1e3, enterNextDelay: 1e3, title: localization.rowActions, children: (0, import_jsx_runtime.jsx)(IconButton_default, { "aria-label": localization.rowActions, onClick: handleOpenRowActionMenu, size: "small", sx: commonIconButtonStyles, children: (0, import_jsx_runtime.jsx)(MoreHorizIcon2, {}) }) }), (0, import_jsx_runtime.jsx)(MRT_RowActionMenu, { anchorEl, handleEdit: handleStartEditMode, row, setAnchorEl, table })] }) : null });
};
var MRT_SelectCheckbox = ({ row, selectAll, table }) => {
  var _a;
  const { getState, options: { localization, enableMultiRowSelection, muiSelectCheckboxProps, muiSelectAllCheckboxProps, selectAllMode } } = table;
  const { density, isLoading } = getState();
  const checkboxProps = !row ? muiSelectAllCheckboxProps instanceof Function ? muiSelectAllCheckboxProps({ table }) : muiSelectAllCheckboxProps : muiSelectCheckboxProps instanceof Function ? muiSelectCheckboxProps({ row, table }) : muiSelectCheckboxProps;
  const allRowsSelected = selectAll ? selectAllMode === "page" ? table.getIsAllPageRowsSelected() : table.getIsAllRowsSelected() : void 0;
  const commonProps = Object.assign(Object.assign({ checked: selectAll ? allRowsSelected : row === null || row === void 0 ? void 0 : row.getIsSelected(), disabled: isLoading || row && !row.getCanSelect(), inputProps: {
    "aria-label": selectAll ? localization.toggleSelectAll : localization.toggleSelectRow
  }, onChange: row ? row.getToggleSelectedHandler() : selectAllMode === "all" ? table.getToggleAllRowsSelectedHandler() : table.getToggleAllPageRowsSelectedHandler(), size: density === "compact" ? "small" : "medium" }, checkboxProps), { onClick: (e) => {
    var _a2;
    e.stopPropagation();
    (_a2 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(checkboxProps, e);
  }, sx: (theme) => Object.assign({ height: density === "compact" ? "1.75rem" : "2.5rem", width: density === "compact" ? "1.75rem" : "2.5rem", m: density !== "compact" ? "-0.4rem" : void 0 }, (checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.sx) instanceof Function ? checkboxProps.sx(theme) : checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.sx), title: void 0 });
  return (0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, enterDelay: 1e3, enterNextDelay: 1e3, title: (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.title) !== null && _a !== void 0 ? _a : selectAll ? localization.toggleSelectAll : localization.toggleSelectRow, children: enableMultiRowSelection === false ? (0, import_jsx_runtime.jsx)(Radio_default, Object.assign({}, commonProps)) : (0, import_jsx_runtime.jsx)(Checkbox_default, Object.assign({ indeterminate: selectAll ? table.getIsSomeRowsSelected() && !allRowsSelected : row === null || row === void 0 ? void 0 : row.getIsSomeSelected() }, commonProps)) });
};
var MRT_GlobalFilterTextField = ({ table }) => {
  var _a;
  const { getState, setGlobalFilter, options: { enableGlobalFilterModes, icons: { SearchIcon: SearchIcon2, CloseIcon: CloseIcon2 }, localization, manualFiltering, muiSearchTextFieldProps }, refs: { searchInputRef } } = table;
  const { globalFilter, showGlobalFilter } = getState();
  const textFieldProps = muiSearchTextFieldProps instanceof Function ? muiSearchTextFieldProps({ table }) : muiSearchTextFieldProps;
  const isMounted = (0, import_react.useRef)(false);
  const [anchorEl, setAnchorEl] = (0, import_react.useState)(null);
  const [searchValue, setSearchValue] = (0, import_react.useState)(globalFilter !== null && globalFilter !== void 0 ? globalFilter : "");
  const handleChangeDebounced = (0, import_react.useCallback)(debounce_default((event) => {
    var _a2;
    setGlobalFilter((_a2 = event.target.value) !== null && _a2 !== void 0 ? _a2 : void 0);
  }, manualFiltering ? 500 : 250), []);
  const handleChange = (event) => {
    setSearchValue(event.target.value);
    handleChangeDebounced(event);
  };
  const handleGlobalFilterMenuOpen = (event) => {
    setAnchorEl(event.currentTarget);
  };
  const handleClear = () => {
    setSearchValue("");
    setGlobalFilter(void 0);
  };
  (0, import_react.useEffect)(() => {
    if (isMounted.current) {
      if (globalFilter === void 0) {
        handleClear();
      } else {
        setSearchValue(globalFilter);
      }
    }
    isMounted.current = true;
  }, [globalFilter]);
  return (0, import_jsx_runtime.jsxs)(Collapse_default, { in: showGlobalFilter, orientation: "horizontal", unmountOnExit: true, mountOnEnter: true, children: [(0, import_jsx_runtime.jsx)(TextField_default, Object.assign({ placeholder: localization.search, onChange: handleChange, value: searchValue !== null && searchValue !== void 0 ? searchValue : "", variant: "standard", InputProps: {
    startAdornment: enableGlobalFilterModes ? (0, import_jsx_runtime.jsx)(InputAdornment_default, { position: "start", children: (0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, title: localization.changeSearchMode, children: (0, import_jsx_runtime.jsx)(IconButton_default, { "aria-label": localization.changeSearchMode, onClick: handleGlobalFilterMenuOpen, size: "small", sx: { height: "1.75rem", width: "1.75rem" }, children: (0, import_jsx_runtime.jsx)(SearchIcon2, {}) }) }) }) : (0, import_jsx_runtime.jsx)(SearchIcon2, { style: { marginRight: "4px" } }),
    endAdornment: (0, import_jsx_runtime.jsx)(InputAdornment_default, { position: "end", children: (0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, title: (_a = localization.clearSearch) !== null && _a !== void 0 ? _a : "", children: (0, import_jsx_runtime.jsx)("span", { children: (0, import_jsx_runtime.jsx)(IconButton_default, { "aria-label": localization.clearSearch, disabled: !(searchValue === null || searchValue === void 0 ? void 0 : searchValue.length), onClick: handleClear, size: "small", children: (0, import_jsx_runtime.jsx)(CloseIcon2, {}) }) }) }) })
  } }, textFieldProps, { inputRef: (inputRef) => {
    searchInputRef.current = inputRef;
    if (textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.inputRef) {
      textFieldProps.inputRef = inputRef;
    }
  } })), (0, import_jsx_runtime.jsx)(MRT_FilterOptionMenu, { anchorEl, setAnchorEl, table, onSelect: handleClear })] });
};
var MRT_LinearProgressBar = ({ isTopToolbar, table }) => {
  const { options: { muiLinearProgressProps }, getState } = table;
  const { isLoading, showProgressBars } = getState();
  const linearProgressProps = muiLinearProgressProps instanceof Function ? muiLinearProgressProps({ isTopToolbar, table }) : muiLinearProgressProps;
  return (0, import_jsx_runtime.jsx)(Collapse_default, { in: isLoading || showProgressBars, mountOnEnter: true, unmountOnExit: true, sx: {
    bottom: isTopToolbar ? 0 : void 0,
    position: "absolute",
    top: !isTopToolbar ? 0 : void 0,
    width: "100%"
  }, children: (0, import_jsx_runtime.jsx)(LinearProgress_default, Object.assign({ "aria-label": "Loading", "aria-busy": "true", sx: { position: "relative" } }, linearProgressProps)) });
};
var MRT_TablePagination = ({ table, position = "bottom" }) => {
  const { getPrePaginationRowModel, getState, setPageIndex, setPageSize, options: { muiTablePaginationProps, enableToolbarInternalActions, localization, rowCount } } = table;
  const { pagination: { pageSize = 10, pageIndex = 0 }, showGlobalFilter } = getState();
  const totalRowCount = rowCount !== null && rowCount !== void 0 ? rowCount : getPrePaginationRowModel().rows.length;
  const showFirstLastPageButtons = totalRowCount / pageSize > 2;
  const tablePaginationProps = muiTablePaginationProps instanceof Function ? muiTablePaginationProps({ table }) : muiTablePaginationProps;
  const handleChangeRowsPerPage = (event) => {
    setPageSize(+event.target.value);
  };
  return (0, import_jsx_runtime.jsx)(TablePagination_default, Object.assign({ component: "div", count: totalRowCount, getItemAriaLabel: (type) => type === "first" ? localization.goToFirstPage : type === "last" ? localization.goToLastPage : type === "next" ? localization.goToNextPage : localization.goToPreviousPage, labelDisplayedRows: ({ from, to, count: count2 }) => `${from}-${to} ${localization.of} ${count2}`, labelRowsPerPage: localization.rowsPerPage, onPageChange: (_, newPage) => setPageIndex(newPage), onRowsPerPageChange: handleChangeRowsPerPage, page: Math.max(Math.min(pageIndex, Math.ceil(totalRowCount / pageSize) - 1), 0), rowsPerPage: pageSize, rowsPerPageOptions: [5, 10, 15, 20, 25, 30, 50, 100], showFirstButton: showFirstLastPageButtons, showLastButton: showFirstLastPageButtons }, tablePaginationProps, { SelectProps: Object.assign({ sx: { m: "0 1rem 0 1ch" }, MenuProps: { MenuListProps: { disablePadding: true }, sx: { m: 0 } } }, tablePaginationProps === null || tablePaginationProps === void 0 ? void 0 : tablePaginationProps.SelectProps), sx: (theme) => Object.assign({ "& .MuiTablePagination-toolbar": {
    display: "flex",
    alignItems: "center"
  }, "& .MuiTablePagination-selectLabel": {
    m: "0 -1px"
  }, "&. MuiInputBase-root": {
    m: "0 1px"
  }, "& . MuiTablePagination-select": {
    m: "0 1px"
  }, "& .MuiTablePagination-displayedRows": {
    m: "0 1px"
  }, "& .MuiTablePagination-actions": {
    m: "0 1px"
  }, mt: position === "top" && enableToolbarInternalActions && !showGlobalFilter ? "3.5rem" : void 0, position: "relative", zIndex: 2 }, (tablePaginationProps === null || tablePaginationProps === void 0 ? void 0 : tablePaginationProps.sx) instanceof Function ? tablePaginationProps.sx(theme) : tablePaginationProps === null || tablePaginationProps === void 0 ? void 0 : tablePaginationProps.sx) }));
};
var MRT_ToolbarAlertBanner = ({ stackAlertBanner, table }) => {
  var _a, _b;
  const { getPrePaginationRowModel, getSelectedRowModel, getState, options: { localization, muiToolbarAlertBannerProps, muiToolbarAlertBannerChipProps, positionToolbarAlertBanner, rowCount } } = table;
  const { grouping, showAlertBanner } = getState();
  const alertProps = muiToolbarAlertBannerProps instanceof Function ? muiToolbarAlertBannerProps({ table }) : muiToolbarAlertBannerProps;
  const chipProps = muiToolbarAlertBannerChipProps instanceof Function ? muiToolbarAlertBannerChipProps({ table }) : muiToolbarAlertBannerChipProps;
  const selectMessage = getSelectedRowModel().rows.length > 0 ? (_b = (_a = localization.selectedCountOfRowCountRowsSelected) === null || _a === void 0 ? void 0 : _a.replace("{selectedCount}", getSelectedRowModel().rows.length.toString())) === null || _b === void 0 ? void 0 : _b.replace("{rowCount}", (rowCount !== null && rowCount !== void 0 ? rowCount : getPrePaginationRowModel().rows.length).toString()) : null;
  const groupedByMessage = grouping.length > 0 ? (0, import_jsx_runtime.jsxs)("span", { children: [localization.groupedBy, " ", grouping.map((columnId, index) => (0, import_jsx_runtime.jsxs)(import_react.Fragment, { children: [index > 0 ? localization.thenBy : "", (0, import_jsx_runtime.jsx)(Chip_default, Object.assign({ label: table.getColumn(columnId).columnDef.header, onDelete: () => table.getColumn(columnId).toggleGrouping() }, chipProps))] }, `${index}-${columnId}`))] }) : null;
  return (0, import_jsx_runtime.jsx)(Collapse_default, { in: showAlertBanner || !!selectMessage || !!groupedByMessage, timeout: stackAlertBanner ? 200 : 0, children: (0, import_jsx_runtime.jsxs)(Alert_default, Object.assign({ color: "info", icon: false }, alertProps, { sx: (theme) => Object.assign({ borderRadius: 0, fontSize: "1rem", left: 0, p: 0, position: "relative", mb: stackAlertBanner ? 0 : positionToolbarAlertBanner === "bottom" ? "-1rem" : void 0, right: 0, top: 0, width: "100%", zIndex: 2 }, (alertProps === null || alertProps === void 0 ? void 0 : alertProps.sx) instanceof Function ? alertProps.sx(theme) : alertProps === null || alertProps === void 0 ? void 0 : alertProps.sx), children: [(alertProps === null || alertProps === void 0 ? void 0 : alertProps.title) && (0, import_jsx_runtime.jsx)(AlertTitle_default, { children: alertProps.title }), (0, import_jsx_runtime.jsxs)(Box_default, { sx: { p: "0.5rem 1rem" }, children: [alertProps === null || alertProps === void 0 ? void 0 : alertProps.children, (alertProps === null || alertProps === void 0 ? void 0 : alertProps.children) && (selectMessage || groupedByMessage) && (0, import_jsx_runtime.jsx)("br", {}), selectMessage, selectMessage && groupedByMessage && (0, import_jsx_runtime.jsx)("br", {}), groupedByMessage] })] })) });
};
var MRT_FullScreenToggleButton = (_a) => {
  var _b;
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { getState, options: { icons: { FullscreenExitIcon: FullscreenExitIcon2, FullscreenIcon: FullscreenIcon2 }, localization }, setIsFullScreen } = table;
  const { isFullScreen } = getState();
  const handleToggleFullScreen = () => {
    setIsFullScreen(!isFullScreen);
  };
  return (0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.toggleFullScreen, children: (0, import_jsx_runtime.jsx)(IconButton_default, Object.assign({ "aria-label": localization.showHideFilters, onClick: handleToggleFullScreen }, rest, { title: void 0, children: isFullScreen ? (0, import_jsx_runtime.jsx)(FullscreenExitIcon2, {}) : (0, import_jsx_runtime.jsx)(FullscreenIcon2, {}) })) });
};
var MRT_ColumnPinningButtons = ({ column, table }) => {
  const { options: { icons: { PushPinIcon: PushPinIcon2 }, localization } } = table;
  const handlePinColumn = (pinDirection) => {
    column.pin(pinDirection);
  };
  return (0, import_jsx_runtime.jsx)(Box_default, { sx: { minWidth: "70px", textAlign: "center" }, children: column.getIsPinned() ? (0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, title: localization.unpin, children: (0, import_jsx_runtime.jsx)(IconButton_default, { onClick: () => handlePinColumn(false), size: "small", children: (0, import_jsx_runtime.jsx)(PushPinIcon2, {}) }) }) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, title: localization.pinToLeft, children: (0, import_jsx_runtime.jsx)(IconButton_default, { onClick: () => handlePinColumn("left"), size: "small", children: (0, import_jsx_runtime.jsx)(PushPinIcon2, { style: {
    transform: "rotate(90deg)"
  } }) }) }), (0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, title: localization.pinToRight, children: (0, import_jsx_runtime.jsx)(IconButton_default, { onClick: () => handlePinColumn("right"), size: "small", children: (0, import_jsx_runtime.jsx)(PushPinIcon2, { style: {
    transform: "rotate(-90deg)"
  } }) }) })] }) });
};
var MRT_GrabHandleButton = ({ iconButtonProps, onDragEnd, onDragStart, table }) => {
  var _a;
  const { options: { icons: { DragHandleIcon: DragHandleIcon2 }, localization } } = table;
  return (0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, enterDelay: 1e3, enterNextDelay: 1e3, placement: "top", title: (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.title) !== null && _a !== void 0 ? _a : localization.move, children: (0, import_jsx_runtime.jsx)(IconButton_default, Object.assign({ disableRipple: true, draggable: "true", size: "small" }, iconButtonProps, { onClick: (e) => {
    var _a2;
    e.stopPropagation();
    (_a2 = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(iconButtonProps, e);
  }, onDragStart, onDragEnd, sx: (theme) => Object.assign({ cursor: "grab", m: "0 -0.1rem", opacity: 0.5, p: "2px", transition: "all 150ms ease-in-out", "&:hover": {
    backgroundColor: "transparent",
    opacity: 1
  }, "&:active": {
    cursor: "grabbing"
  } }, (iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx) instanceof Function ? iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx(theme) : iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx), title: void 0, children: (0, import_jsx_runtime.jsx)(DragHandleIcon2, {}) })) });
};
var MRT_ShowHideColumnsMenuItems = ({ allColumns, hoveredColumn, setHoveredColumn, column, table }) => {
  var _a;
  const { getState, options: { enableColumnOrdering, enableHiding, enablePinning, localization }, setColumnOrder } = table;
  const { columnOrder } = getState();
  const { columnDef } = column;
  const { columnDefType } = columnDef;
  const switchChecked = columnDefType !== "group" && column.getIsVisible() || columnDefType === "group" && column.getLeafColumns().some((col) => col.getIsVisible());
  const handleToggleColumnHidden = (column2) => {
    var _a2, _b;
    if (columnDefType === "group") {
      (_b = (_a2 = column2 === null || column2 === void 0 ? void 0 : column2.columns) === null || _a2 === void 0 ? void 0 : _a2.forEach) === null || _b === void 0 ? void 0 : _b.call(_a2, (childColumn) => {
        childColumn.toggleVisibility(!switchChecked);
      });
    } else {
      column2.toggleVisibility();
    }
  };
  const menuItemRef = (0, import_react.useRef)(null);
  const [isDragging, setIsDragging] = (0, import_react.useState)(false);
  const handleDragStart = (e) => {
    setIsDragging(true);
    e.dataTransfer.setDragImage(menuItemRef.current, 0, 0);
  };
  const handleDragEnd = (_e) => {
    setIsDragging(false);
    setHoveredColumn(null);
    if (hoveredColumn) {
      setColumnOrder(reorderColumn(column, hoveredColumn, columnOrder));
    }
  };
  const handleDragEnter = (_e) => {
    if (!isDragging && columnDef.enableColumnOrdering !== false) {
      setHoveredColumn(column);
    }
  };
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(MenuItem_default, { disableRipple: true, ref: menuItemRef, onDragEnter: handleDragEnter, sx: (theme) => ({
    alignItems: "center",
    justifyContent: "flex-start",
    my: 0,
    opacity: isDragging ? 0.5 : 1,
    outlineOffset: "-2px",
    outline: isDragging ? `2px dashed ${theme.palette.divider}` : (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id ? `2px dashed ${theme.palette.primary.main}` : "none",
    pl: `${(column.depth + 0.5) * 2}rem`,
    py: "6px"
  }), children: (0, import_jsx_runtime.jsxs)(Box_default, { sx: {
    display: "flex",
    flexWrap: "nowrap",
    gap: "8px"
  }, children: [columnDefType !== "group" && enableColumnOrdering && !allColumns.some((col) => col.columnDef.columnDefType === "group") && (columnDef.enableColumnOrdering !== false ? (0, import_jsx_runtime.jsx)(MRT_GrabHandleButton, { onDragEnd: handleDragEnd, onDragStart: handleDragStart, table }) : (0, import_jsx_runtime.jsx)(Box_default, { sx: { width: "28px" } })), enablePinning && (column.getCanPin() ? (0, import_jsx_runtime.jsx)(MRT_ColumnPinningButtons, { column, table }) : (0, import_jsx_runtime.jsx)(Box_default, { sx: { width: "70px" } })), enableHiding ? (0, import_jsx_runtime.jsx)(FormControlLabel_default, { componentsProps: {
    typography: {
      sx: {
        mb: 0,
        opacity: columnDefType !== "display" ? 1 : 0.5
      }
    }
  }, checked: switchChecked, control: (0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, enterDelay: 1e3, enterNextDelay: 1e3, title: localization.toggleVisibility, children: (0, import_jsx_runtime.jsx)(Switch_default, {}) }), disabled: !column.getCanHide(), label: columnDef.header, onChange: () => handleToggleColumnHidden(column) }) : (0, import_jsx_runtime.jsx)(Typography_default, { sx: { alignSelf: "center" }, children: columnDef.header })] }) }), (_a = column.columns) === null || _a === void 0 ? void 0 : _a.map((c, i) => (0, import_jsx_runtime.jsx)(MRT_ShowHideColumnsMenuItems, { allColumns, column: c, hoveredColumn, setHoveredColumn, table }, `${i}-${c.id}`))] });
};
var MRT_ShowHideColumnsMenu = ({ anchorEl, setAnchorEl, table }) => {
  const { getAllColumns, getAllLeafColumns, getCenterLeafColumns, getIsAllColumnsVisible, getIsSomeColumnsPinned, getIsSomeColumnsVisible, getLeftLeafColumns, getRightLeafColumns, getState, toggleAllColumnsVisible, options: { enableColumnOrdering, enableHiding, enablePinning, localization } } = table;
  const { density, columnOrder, columnPinning } = getState();
  const hideAllColumns = () => {
    getAllLeafColumns().filter((col) => col.columnDef.enableHiding !== false).forEach((col) => col.toggleVisibility(false));
  };
  const allColumns = (0, import_react.useMemo)(() => {
    const columns = getAllColumns();
    if (columnOrder.length > 0 && !columns.some((col) => col.columnDef.columnDefType === "group")) {
      return [
        ...getLeftLeafColumns(),
        ...Array.from(new Set(columnOrder)).map((colId) => getCenterLeafColumns().find((col) => (col === null || col === void 0 ? void 0 : col.id) === colId)),
        ...getRightLeafColumns()
      ].filter(Boolean);
    }
    return columns;
  }, [
    columnOrder,
    columnPinning,
    getAllColumns(),
    getCenterLeafColumns(),
    getLeftLeafColumns(),
    getRightLeafColumns()
  ]);
  const [hoveredColumn, setHoveredColumn] = (0, import_react.useState)(null);
  return (0, import_jsx_runtime.jsxs)(Menu_default, { anchorEl, open: !!anchorEl, onClose: () => setAnchorEl(null), MenuListProps: {
    dense: density === "compact"
  }, children: [(0, import_jsx_runtime.jsxs)(Box_default, { sx: {
    display: "flex",
    justifyContent: "space-between",
    p: "0.5rem",
    pt: 0
  }, children: [enableHiding && (0, import_jsx_runtime.jsx)(Button_default, { disabled: !getIsSomeColumnsVisible(), onClick: hideAllColumns, children: localization.hideAll }), enableColumnOrdering && (0, import_jsx_runtime.jsx)(Button_default, { onClick: () => table.setColumnOrder(getDefaultColumnOrderIds(table.options)), children: localization.resetOrder }), enablePinning && (0, import_jsx_runtime.jsx)(Button_default, { disabled: !getIsSomeColumnsPinned(), onClick: () => table.resetColumnPinning(true), children: localization.unpinAll }), enableHiding && (0, import_jsx_runtime.jsx)(Button_default, { disabled: getIsAllColumnsVisible(), onClick: () => toggleAllColumnsVisible(true), children: localization.showAll })] }), (0, import_jsx_runtime.jsx)(Divider_default, {}), allColumns.map((column, index) => (0, import_jsx_runtime.jsx)(MRT_ShowHideColumnsMenuItems, { allColumns, column, hoveredColumn, setHoveredColumn, table }, `${index}-${column.id}`))] });
};
var MRT_ShowHideColumnsButton = (_a) => {
  var _b;
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { options: { icons: { ViewColumnIcon: ViewColumnIcon2 }, localization } } = table;
  const [anchorEl, setAnchorEl] = (0, import_react.useState)(null);
  const handleClick = (event) => {
    setAnchorEl(event.currentTarget);
  };
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.showHideColumns, children: (0, import_jsx_runtime.jsx)(IconButton_default, Object.assign({ "aria-label": localization.showHideColumns, onClick: handleClick }, rest, { title: void 0, children: (0, import_jsx_runtime.jsx)(ViewColumnIcon2, {}) })) }), anchorEl && (0, import_jsx_runtime.jsx)(MRT_ShowHideColumnsMenu, { anchorEl, setAnchorEl, table })] });
};
var MRT_ToggleDensePaddingButton = (_a) => {
  var _b;
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { getState, options: { icons: { DensityLargeIcon: DensityLargeIcon2, DensityMediumIcon: DensityMediumIcon2, DensitySmallIcon: DensitySmallIcon2 }, localization }, setDensity } = table;
  const { density } = getState();
  const handleToggleDensePadding = () => {
    const nextDensity = density === "comfortable" ? "compact" : density === "compact" ? "spacious" : "comfortable";
    setDensity(nextDensity);
  };
  return (0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.toggleDensity, children: (0, import_jsx_runtime.jsx)(IconButton_default, Object.assign({ "aria-label": localization.toggleDensity, onClick: handleToggleDensePadding }, rest, { title: void 0, children: density === "compact" ? (0, import_jsx_runtime.jsx)(DensitySmallIcon2, {}) : density === "comfortable" ? (0, import_jsx_runtime.jsx)(DensityMediumIcon2, {}) : (0, import_jsx_runtime.jsx)(DensityLargeIcon2, {}) })) });
};
var MRT_ToggleFiltersButton = (_a) => {
  var _b;
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { getState, options: { icons: { FilterListIcon: FilterListIcon2, FilterListOffIcon: FilterListOffIcon2 }, localization }, setShowColumnFilters } = table;
  const { showColumnFilters } = getState();
  const handleToggleShowFilters = () => {
    setShowColumnFilters(!showColumnFilters);
  };
  return (0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.showHideFilters, children: (0, import_jsx_runtime.jsx)(IconButton_default, Object.assign({ "aria-label": localization.showHideFilters, onClick: handleToggleShowFilters }, rest, { title: void 0, children: showColumnFilters ? (0, import_jsx_runtime.jsx)(FilterListOffIcon2, {}) : (0, import_jsx_runtime.jsx)(FilterListIcon2, {}) })) });
};
var MRT_ToggleGlobalFilterButton = (_a) => {
  var _b, _c;
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { getState, options: { icons: { SearchIcon: SearchIcon2, SearchOffIcon: SearchOffIcon2 }, localization }, refs: { searchInputRef }, setShowGlobalFilter } = table;
  const { globalFilter, showGlobalFilter } = getState();
  const handleToggleSearch = () => {
    setShowGlobalFilter(!showGlobalFilter);
    queueMicrotask(() => {
      var _a2;
      return (_a2 = searchInputRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
    });
  };
  return (0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.showHideSearch, children: (0, import_jsx_runtime.jsx)(IconButton_default, Object.assign({ "aria-label": (_c = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _c !== void 0 ? _c : localization.showHideSearch, disabled: !!globalFilter, onClick: handleToggleSearch }, rest, { title: void 0, children: showGlobalFilter ? (0, import_jsx_runtime.jsx)(SearchOffIcon2, {}) : (0, import_jsx_runtime.jsx)(SearchIcon2, {}) })) });
};
var MRT_ToolbarInternalButtons = ({ table }) => {
  var _a;
  const { options: { enableColumnFilters, enableColumnOrdering, enableDensityToggle, enableFilters, enableFullScreenToggle, enableGlobalFilter, enableHiding, enablePinning, initialState, renderToolbarInternalActions } } = table;
  return (0, import_jsx_runtime.jsx)(Box_default, { sx: {
    alignItems: "center",
    display: "flex",
    zIndex: 3
  }, children: (_a = renderToolbarInternalActions === null || renderToolbarInternalActions === void 0 ? void 0 : renderToolbarInternalActions({
    table
  })) !== null && _a !== void 0 ? _a : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [enableFilters && enableGlobalFilter && !(initialState === null || initialState === void 0 ? void 0 : initialState.showGlobalFilter) && (0, import_jsx_runtime.jsx)(MRT_ToggleGlobalFilterButton, { table }), enableFilters && enableColumnFilters && (0, import_jsx_runtime.jsx)(MRT_ToggleFiltersButton, { table }), (enableHiding || enableColumnOrdering || enablePinning) && (0, import_jsx_runtime.jsx)(MRT_ShowHideColumnsButton, { table }), enableDensityToggle && (0, import_jsx_runtime.jsx)(MRT_ToggleDensePaddingButton, { table }), enableFullScreenToggle && (0, import_jsx_runtime.jsx)(MRT_FullScreenToggleButton, { table })] }) });
};
var MRT_ToolbarDropZone = ({ table }) => {
  var _a, _b;
  const { getState, options: { enableGrouping, localization }, setHoveredColumn, setShowToolbarDropZone } = table;
  const { draggingColumn, hoveredColumn, grouping, showToolbarDropZone } = getState();
  const handleDragEnter = (_event) => {
    setHoveredColumn({ id: "drop-zone" });
  };
  (0, import_react.useEffect)(() => {
    var _a2;
    if (((_a2 = table.options.state) === null || _a2 === void 0 ? void 0 : _a2.showToolbarDropZone) !== void 0) {
      setShowToolbarDropZone(!!enableGrouping && !!draggingColumn && draggingColumn.columnDef.enableGrouping !== false && !grouping.includes(draggingColumn.id));
    }
  }, [enableGrouping, draggingColumn, grouping]);
  return (0, import_jsx_runtime.jsx)(Fade_default, { in: showToolbarDropZone, children: (0, import_jsx_runtime.jsx)(Box_default, { className: "Mui-ToolbarDropZone", sx: (theme) => ({
    alignItems: "center",
    backgroundColor: alpha(theme.palette.info.main, (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === "drop-zone" ? 0.2 : 0.1),
    backdropFilter: "blur(4px)",
    boxSizing: "border-box",
    border: `dashed ${theme.palette.info.main} 2px`,
    display: "flex",
    justifyContent: "center",
    height: "100%",
    position: "absolute",
    width: "100%",
    zIndex: 4
  }), onDragEnter: handleDragEnter, children: (0, import_jsx_runtime.jsx)(Typography_default, { fontStyle: "italic", children: localization.dropToGroupBy.replace("{column}", (_b = (_a = draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.columnDef) === null || _a === void 0 ? void 0 : _a.header) !== null && _b !== void 0 ? _b : "") }) }) });
};
var commonToolbarStyles = ({ theme }) => ({
  alignItems: "flex-start",
  backgroundColor: lighten(theme.palette.background.default, 0.04),
  backgroundImage: "none",
  display: "grid",
  flexWrap: "wrap-reverse",
  minHeight: "3.5rem",
  overflow: "hidden",
  p: "0 !important",
  transition: "all 150ms ease-in-out",
  zIndex: 1
});
var MRT_TopToolbar = ({ table }) => {
  var _a;
  const { getState, options: { enableGlobalFilter, enablePagination, enableToolbarInternalActions, muiTopToolbarProps, positionGlobalFilter, positionPagination, positionToolbarAlertBanner, positionToolbarDropZone, renderTopToolbarCustomActions }, refs: { topToolbarRef } } = table;
  const { isFullScreen, showGlobalFilter } = getState();
  const isMobile = useMediaQuery("(max-width:720px)");
  const toolbarProps = muiTopToolbarProps instanceof Function ? muiTopToolbarProps({ table }) : muiTopToolbarProps;
  const stackAlertBanner = isMobile || !!renderTopToolbarCustomActions || showGlobalFilter;
  return (0, import_jsx_runtime.jsxs)(Toolbar_default, Object.assign({ variant: "dense" }, toolbarProps, { ref: (ref) => {
    topToolbarRef.current = ref;
    if (toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.ref) {
      toolbarProps.ref.current = ref;
    }
  }, sx: (theme) => Object.assign(Object.assign({ position: isFullScreen ? "sticky" : void 0, top: isFullScreen ? "0" : void 0 }, commonToolbarStyles({ theme })), (toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.sx) instanceof Function ? toolbarProps.sx(theme) : toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.sx), children: [positionToolbarAlertBanner === "top" && (0, import_jsx_runtime.jsx)(MRT_ToolbarAlertBanner, { stackAlertBanner, table }), ["both", "top"].includes(positionToolbarDropZone !== null && positionToolbarDropZone !== void 0 ? positionToolbarDropZone : "") && (0, import_jsx_runtime.jsx)(MRT_ToolbarDropZone, { table }), (0, import_jsx_runtime.jsxs)(Box_default, { sx: {
    alignItems: "flex-start",
    boxSizing: "border-box",
    display: "flex",
    justifyContent: "space-between",
    p: "0.5rem",
    position: stackAlertBanner ? "relative" : "absolute",
    right: 0,
    top: 0,
    width: "100%"
  }, children: [enableGlobalFilter && positionGlobalFilter === "left" && (0, import_jsx_runtime.jsx)(MRT_GlobalFilterTextField, { table }), (_a = renderTopToolbarCustomActions === null || renderTopToolbarCustomActions === void 0 ? void 0 : renderTopToolbarCustomActions({ table })) !== null && _a !== void 0 ? _a : (0, import_jsx_runtime.jsx)("span", {}), enableToolbarInternalActions ? (0, import_jsx_runtime.jsxs)(Box_default, { sx: {
    display: "flex",
    flexWrap: "wrap-reverse",
    justifyContent: "flex-end"
  }, children: [enableGlobalFilter && positionGlobalFilter === "right" && (0, import_jsx_runtime.jsx)(MRT_GlobalFilterTextField, { table }), (0, import_jsx_runtime.jsx)(MRT_ToolbarInternalButtons, { table })] }) : enableGlobalFilter && positionGlobalFilter === "right" && (0, import_jsx_runtime.jsx)(MRT_GlobalFilterTextField, { table })] }), enablePagination && ["top", "both"].includes(positionPagination !== null && positionPagination !== void 0 ? positionPagination : "") && (0, import_jsx_runtime.jsx)(MRT_TablePagination, { table, position: "top" }), (0, import_jsx_runtime.jsx)(MRT_LinearProgressBar, { isTopToolbar: true, table })] }));
};
var MRT_BottomToolbar = ({ table }) => {
  const { getState, options: { enablePagination, muiBottomToolbarProps, positionPagination, positionToolbarAlertBanner, positionToolbarDropZone, renderBottomToolbarCustomActions }, refs: { bottomToolbarRef } } = table;
  const { isFullScreen } = getState();
  const isMobile = useMediaQuery("(max-width:720px)");
  const toolbarProps = muiBottomToolbarProps instanceof Function ? muiBottomToolbarProps({ table }) : muiBottomToolbarProps;
  const stackAlertBanner = isMobile || !!renderBottomToolbarCustomActions;
  return (0, import_jsx_runtime.jsxs)(Toolbar_default, Object.assign({ variant: "dense" }, toolbarProps, { ref: (node) => {
    if (node) {
      bottomToolbarRef.current = node;
      if (toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.ref) {
        toolbarProps.ref.current = node;
      }
    }
  }, sx: (theme) => Object.assign(Object.assign(Object.assign({}, commonToolbarStyles({ theme })), { bottom: isFullScreen ? "0" : void 0, boxShadow: `0 1px 2px -1px ${alpha(theme.palette.common.black, 0.1)} inset`, left: 0, position: isFullScreen ? "fixed" : "relative", right: 0 }), (toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.sx) instanceof Function ? toolbarProps.sx(theme) : toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.sx), children: [(0, import_jsx_runtime.jsx)(MRT_LinearProgressBar, { isTopToolbar: false, table }), positionToolbarAlertBanner === "bottom" && (0, import_jsx_runtime.jsx)(MRT_ToolbarAlertBanner, { stackAlertBanner, table }), ["both", "bottom"].includes(positionToolbarDropZone !== null && positionToolbarDropZone !== void 0 ? positionToolbarDropZone : "") && (0, import_jsx_runtime.jsx)(MRT_ToolbarDropZone, { table }), (0, import_jsx_runtime.jsxs)(Box_default, { sx: {
    alignItems: "center",
    boxSizing: "border-box",
    display: "flex",
    justifyContent: "space-between",
    p: "0.5rem",
    width: "100%"
  }, children: [renderBottomToolbarCustomActions ? renderBottomToolbarCustomActions({ table }) : (0, import_jsx_runtime.jsx)("span", {}), (0, import_jsx_runtime.jsx)(Box_default, { sx: {
    display: "flex",
    justifyContent: "flex-end",
    position: stackAlertBanner ? "relative" : "absolute",
    right: 0,
    top: 0
  }, children: enablePagination && ["bottom", "both"].includes(positionPagination !== null && positionPagination !== void 0 ? positionPagination : "") && (0, import_jsx_runtime.jsx)(MRT_TablePagination, { table, position: "bottom" }) })] })] }));
};
var MRT_TableHeadCellColumnActionsButton = ({ header, table }) => {
  var _a;
  const { options: { icons: { MoreVertIcon: MoreVertIcon2 }, localization, muiTableHeadCellColumnActionsButtonProps } } = table;
  const { column } = header;
  const { columnDef } = column;
  const [anchorEl, setAnchorEl] = (0, import_react.useState)(null);
  const handleClick = (event) => {
    event.stopPropagation();
    event.preventDefault();
    setAnchorEl(event.currentTarget);
  };
  const mTableHeadCellColumnActionsButtonProps = muiTableHeadCellColumnActionsButtonProps instanceof Function ? muiTableHeadCellColumnActionsButtonProps({ column, table }) : muiTableHeadCellColumnActionsButtonProps;
  const mcTableHeadCellColumnActionsButtonProps = columnDef.muiTableHeadCellColumnActionsButtonProps instanceof Function ? columnDef.muiTableHeadCellColumnActionsButtonProps({
    column,
    table
  }) : columnDef.muiTableHeadCellColumnActionsButtonProps;
  const iconButtonProps = Object.assign(Object.assign({}, mTableHeadCellColumnActionsButtonProps), mcTableHeadCellColumnActionsButtonProps);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, enterDelay: 1e3, enterNextDelay: 1e3, placement: "top", title: (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.title) !== null && _a !== void 0 ? _a : localization.columnActions, children: (0, import_jsx_runtime.jsx)(IconButton_default, Object.assign({ "aria-label": localization.columnActions, onClick: handleClick, size: "small" }, iconButtonProps, { sx: (theme) => Object.assign({ height: "2rem", m: "-8px -4px", opacity: 0.5, transform: "scale(0.85) translateX(-4px)", transition: "opacity 150ms", width: "2rem", "&:hover": {
    opacity: 1
  } }, (iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx) instanceof Function ? iconButtonProps.sx(theme) : iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx), title: void 0, children: (0, import_jsx_runtime.jsx)(MoreVertIcon2, {}) })) }), anchorEl && (0, import_jsx_runtime.jsx)(MRT_ColumnActionMenu, { anchorEl, header, setAnchorEl, table })] });
};
var MRT_FilterTextField = ({ header, rangeFilterIndex, table }) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
  const { options: { enableColumnFilterModes, columnFilterModeOptions, icons: { FilterListIcon: FilterListIcon2, CloseIcon: CloseIcon2 }, localization, manualFiltering, muiTableHeadCellFilterTextFieldProps }, refs: { filterInputRefs }, setColumnFilterFns } = table;
  const { column } = header;
  const { columnDef } = column;
  const mTableHeadCellFilterTextFieldProps = muiTableHeadCellFilterTextFieldProps instanceof Function ? muiTableHeadCellFilterTextFieldProps({
    column,
    table,
    rangeFilterIndex
  }) : muiTableHeadCellFilterTextFieldProps;
  const mcTableHeadCellFilterTextFieldProps = columnDef.muiTableHeadCellFilterTextFieldProps instanceof Function ? columnDef.muiTableHeadCellFilterTextFieldProps({
    column,
    table,
    rangeFilterIndex
  }) : columnDef.muiTableHeadCellFilterTextFieldProps;
  const textFieldProps = Object.assign(Object.assign({}, mTableHeadCellFilterTextFieldProps), mcTableHeadCellFilterTextFieldProps);
  const isRangeFilter = columnDef.filterVariant === "range" || rangeFilterIndex !== void 0;
  const isSelectFilter = columnDef.filterVariant === "select";
  const isMultiSelectFilter = columnDef.filterVariant === "multi-select";
  const isTextboxFilter = columnDef.filterVariant === "text" || !isSelectFilter && !isMultiSelectFilter;
  const currentFilterOption = columnDef._filterFn;
  const filterChipLabel = ["empty", "notEmpty"].includes(currentFilterOption) ? (
    //@ts-ignore
    localization[`filter${((_b = (_a = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt) === null || _a === void 0 ? void 0 : _a.call(currentFilterOption, 0)) === null || _b === void 0 ? void 0 : _b.toUpperCase()) + (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`]
  ) : "";
  const filterPlaceholder = !isRangeFilter ? (_c = textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.placeholder) !== null && _c !== void 0 ? _c : (_d = localization.filterByColumn) === null || _d === void 0 ? void 0 : _d.replace("{column}", String(columnDef.header)) : rangeFilterIndex === 0 ? localization.min : rangeFilterIndex === 1 ? localization.max : "";
  const allowedColumnFilterOptions = (_e = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _e !== void 0 ? _e : columnFilterModeOptions;
  const showChangeModeButton = enableColumnFilterModes && columnDef.enableColumnFilterModes !== false && !rangeFilterIndex && (allowedColumnFilterOptions === void 0 || !!(allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.length));
  const facetedUniqueValues = column.getFacetedUniqueValues();
  const filterSelectOptions = (0, import_react.useMemo)(() => {
    var _a2;
    return (_a2 = columnDef.filterSelectOptions) !== null && _a2 !== void 0 ? _a2 : (isSelectFilter || isMultiSelectFilter) && facetedUniqueValues ? Array.from(facetedUniqueValues.keys()).sort((a, b) => a.localeCompare(b)) : void 0;
  }, [
    columnDef.filterSelectOptions,
    facetedUniqueValues,
    isMultiSelectFilter,
    isSelectFilter
  ]);
  const [anchorEl, setAnchorEl] = (0, import_react.useState)(null);
  const [filterValue, setFilterValue] = (0, import_react.useState)(() => {
    var _a2, _b2;
    return isMultiSelectFilter ? column.getFilterValue() || [] : isRangeFilter ? ((_a2 = column.getFilterValue()) === null || _a2 === void 0 ? void 0 : _a2[rangeFilterIndex]) || [] : (_b2 = column.getFilterValue()) !== null && _b2 !== void 0 ? _b2 : "";
  });
  const handleChangeDebounced = (0, import_react.useCallback)(debounce_default((event) => {
    const value = textFieldProps.type === "date" ? event.target.valueAsDate : textFieldProps.type === "number" ? event.target.valueAsNumber : event.target.value;
    if (isRangeFilter) {
      column.setFilterValue((old) => {
        const newFilterValues = old !== null && old !== void 0 ? old : ["", ""];
        newFilterValues[rangeFilterIndex] = value;
        return newFilterValues;
      });
    } else {
      column.setFilterValue(value !== null && value !== void 0 ? value : void 0);
    }
  }, isTextboxFilter ? manualFiltering ? 400 : 200 : 1), []);
  const handleChange = (event) => {
    setFilterValue(event.target.value);
    handleChangeDebounced(event);
  };
  const handleClear = () => {
    if (isMultiSelectFilter) {
      setFilterValue([]);
      column.setFilterValue([]);
    } else if (isRangeFilter) {
      setFilterValue("");
      column.setFilterValue((old) => {
        const newFilterValues = Array.isArray(old) && old || ["", ""];
        newFilterValues[rangeFilterIndex] = void 0;
        return newFilterValues;
      });
    } else {
      setFilterValue("");
      column.setFilterValue(void 0);
    }
  };
  const handleClearEmptyFilterChip = () => {
    setFilterValue("");
    column.setFilterValue(void 0);
    setColumnFilterFns((prev) => {
      var _a2;
      return Object.assign(Object.assign({}, prev), { [header.id]: (_a2 = allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions[0]) !== null && _a2 !== void 0 ? _a2 : "fuzzy" });
    });
  };
  const handleFilterMenuOpen = (event) => {
    setAnchorEl(event.currentTarget);
  };
  const isMounted = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(() => {
    if (isMounted.current) {
      const filterValue2 = column.getFilterValue();
      if (filterValue2 === void 0) {
        handleClear();
      } else if (isRangeFilter && rangeFilterIndex !== void 0) {
        setFilterValue(filterValue2[rangeFilterIndex]);
      } else {
        setFilterValue(filterValue2);
      }
    }
    isMounted.current = true;
  }, [column.getFilterValue()]);
  if (columnDef.Filter) {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (_f = columnDef.Filter) === null || _f === void 0 ? void 0 : _f.call(columnDef, { column, header, rangeFilterIndex, table }) });
  }
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsxs)(TextField_default, Object.assign({ fullWidth: true, inputProps: {
    disabled: !!filterChipLabel,
    sx: {
      textOverflow: "ellipsis",
      width: filterChipLabel ? 0 : void 0
    },
    title: filterPlaceholder
  }, helperText: showChangeModeButton ? (0, import_jsx_runtime.jsx)("label", { children: localization.filterMode.replace(
    "{filterType}",
    // @ts-ignore
    localization[`filter${((_g = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt(0)) === null || _g === void 0 ? void 0 : _g.toUpperCase()) + (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`]
  ) }) : null, FormHelperTextProps: {
    sx: {
      fontSize: "0.75rem",
      lineHeight: "0.8rem",
      whiteSpace: "nowrap"
    }
  }, margin: "none", placeholder: filterChipLabel || isSelectFilter || isMultiSelectFilter ? void 0 : filterPlaceholder, onChange: handleChange, onClick: (e) => e.stopPropagation(), select: isSelectFilter || isMultiSelectFilter, value: filterValue !== null && filterValue !== void 0 ? filterValue : "", variant: "standard", InputProps: {
    startAdornment: showChangeModeButton ? (0, import_jsx_runtime.jsxs)(InputAdornment_default, { position: "start", children: [(0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, title: localization.changeFilterMode, children: (0, import_jsx_runtime.jsx)("span", { children: (0, import_jsx_runtime.jsx)(IconButton_default, { "aria-label": localization.changeFilterMode, onClick: handleFilterMenuOpen, size: "small", sx: { height: "1.75rem", width: "1.75rem" }, children: (0, import_jsx_runtime.jsx)(FilterListIcon2, {}) }) }) }), filterChipLabel && (0, import_jsx_runtime.jsx)(Chip_default, { onDelete: handleClearEmptyFilterChip, label: filterChipLabel })] }) : null,
    endAdornment: !filterChipLabel && (0, import_jsx_runtime.jsx)(InputAdornment_default, { position: "end", children: (0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, placement: "right", title: (_h = localization.clearFilter) !== null && _h !== void 0 ? _h : "", children: (0, import_jsx_runtime.jsx)("span", { children: (0, import_jsx_runtime.jsx)(IconButton_default, { "aria-label": localization.clearFilter, disabled: !((_j = filterValue === null || filterValue === void 0 ? void 0 : filterValue.toString()) === null || _j === void 0 ? void 0 : _j.length), onClick: handleClear, size: "small", sx: {
      height: "1.75rem",
      width: "1.75rem"
    }, children: (0, import_jsx_runtime.jsx)(CloseIcon2, {}) }) }) }) })
  }, SelectProps: {
    displayEmpty: true,
    multiple: isMultiSelectFilter,
    renderValue: isMultiSelectFilter ? (selected) => !(selected === null || selected === void 0 ? void 0 : selected.length) ? (0, import_jsx_runtime.jsx)(Box_default, { sx: { opacity: 0.5 }, children: filterPlaceholder }) : (0, import_jsx_runtime.jsx)(Box_default, { sx: { display: "flex", flexWrap: "wrap", gap: "2px" }, children: selected === null || selected === void 0 ? void 0 : selected.map((value) => {
      const selectedValue = filterSelectOptions === null || filterSelectOptions === void 0 ? void 0 : filterSelectOptions.find((option) => option instanceof Object ? option.value === value : option === value);
      return (0, import_jsx_runtime.jsx)(Chip_default, { label: selectedValue instanceof Object ? selectedValue.text : selectedValue }, value);
    }) }) : void 0
  } }, textFieldProps, { inputRef: (inputRef) => {
    filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] = inputRef;
    if (textFieldProps.inputRef) {
      textFieldProps.inputRef = inputRef;
    }
  }, sx: (theme) => Object.assign({ p: 0, minWidth: isRangeFilter ? "100px" : !filterChipLabel ? "120px" : "auto", width: "calc(100% + 4px)", mx: "-2px", "& .MuiSelect-icon": {
    mr: "1.5rem"
  } }, (textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.sx) instanceof Function ? textFieldProps.sx(theme) : textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.sx), children: [(isSelectFilter || isMultiSelectFilter) && (0, import_jsx_runtime.jsx)(MenuItem_default, { divider: true, disabled: true, hidden: true, value: "", children: (0, import_jsx_runtime.jsx)(Box_default, { sx: { opacity: 0.5 }, children: filterPlaceholder }) }), (_k = textFieldProps.children) !== null && _k !== void 0 ? _k : filterSelectOptions === null || filterSelectOptions === void 0 ? void 0 : filterSelectOptions.map((option) => {
    var _a2;
    if (!option)
      return "";
    let value;
    let text2;
    if (typeof option !== "object") {
      value = option;
      text2 = option;
    } else {
      value = option.value;
      text2 = option.text;
    }
    return (0, import_jsx_runtime.jsxs)(MenuItem_default, { sx: {
      display: "flex",
      m: 0,
      alignItems: "center",
      gap: "0.5rem"
    }, value, children: [isMultiSelectFilter && (0, import_jsx_runtime.jsx)(Checkbox_default, { checked: ((_a2 = column.getFilterValue()) !== null && _a2 !== void 0 ? _a2 : []).includes(value), sx: { mr: "0.5rem" } }), text2, " ", !columnDef.filterSelectOptions && `(${facetedUniqueValues.get(value)})`] }, value);
  })] })), (0, import_jsx_runtime.jsx)(MRT_FilterOptionMenu, { anchorEl, header, setAnchorEl, table, setFilterValue })] });
};
var MRT_FilterRangeFields = ({ header, table }) => {
  return (0, import_jsx_runtime.jsxs)(Box_default, { sx: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "1rem" }, children: [(0, import_jsx_runtime.jsx)(MRT_FilterTextField, { header, rangeFilterIndex: 0, table }), (0, import_jsx_runtime.jsx)(MRT_FilterTextField, { header, rangeFilterIndex: 1, table })] });
};
var MRT_FilterCheckbox = ({ column, table }) => {
  var _a, _b, _c;
  const { getState, options: { localization, muiTableHeadCellFilterCheckboxProps } } = table;
  const { density } = getState();
  const { columnDef } = column;
  const mTableHeadCellFilterCheckboxProps = muiTableHeadCellFilterCheckboxProps instanceof Function ? muiTableHeadCellFilterCheckboxProps({
    column,
    table
  }) : muiTableHeadCellFilterCheckboxProps;
  const mcTableHeadCellFilterCheckboxProps = columnDef.muiTableHeadCellFilterCheckboxProps instanceof Function ? columnDef.muiTableHeadCellFilterCheckboxProps({
    column,
    table
  }) : columnDef.muiTableHeadCellFilterCheckboxProps;
  const checkboxProps = Object.assign(Object.assign({}, mTableHeadCellFilterCheckboxProps), mcTableHeadCellFilterCheckboxProps);
  const filterLabel = (_a = localization.filterByColumn) === null || _a === void 0 ? void 0 : _a.replace("{column}", columnDef.header);
  return (0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, enterDelay: 1e3, enterNextDelay: 1e3, title: (_b = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.title) !== null && _b !== void 0 ? _b : filterLabel, children: (0, import_jsx_runtime.jsx)(FormControlLabel_default, { control: (0, import_jsx_runtime.jsx)(Checkbox_default, Object.assign({ checked: column.getFilterValue() === "true", indeterminate: column.getFilterValue() === void 0, color: column.getFilterValue() === void 0 ? "default" : "primary", size: density === "compact" ? "small" : "medium" }, checkboxProps, { onClick: (e) => {
    var _a2;
    e.stopPropagation();
    (_a2 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(checkboxProps, e);
  }, onChange: (e, checked) => {
    var _a2;
    column.setFilterValue(column.getFilterValue() === void 0 ? "true" : column.getFilterValue() === "true" ? "false" : void 0);
    (_a2 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(checkboxProps, e, checked);
  }, sx: (theme) => Object.assign({ height: "2.5rem", width: "2.5rem" }, (checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.sx) instanceof Function ? checkboxProps.sx(theme) : checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.sx) })), disableTypography: true, label: (_c = checkboxProps.title) !== null && _c !== void 0 ? _c : filterLabel, sx: { color: "text.secondary", mt: "-4px", fontWeight: "normal" }, title: void 0 }) });
};
var MRT_FilterRangeSlider = ({ header, table }) => {
  var _a, _b;
  const { options: { localization, muiTableHeadCellFilterSliderProps, enableColumnFilterModes }, refs: { filterInputRefs } } = table;
  const { column } = header;
  const { columnDef } = column;
  const currentFilterOption = columnDef._filterFn;
  const showChangeModeButton = enableColumnFilterModes && columnDef.enableColumnFilterModes !== false;
  const mTableHeadCellFilterTextFieldProps = muiTableHeadCellFilterSliderProps instanceof Function ? muiTableHeadCellFilterSliderProps({
    column,
    table
  }) : muiTableHeadCellFilterSliderProps;
  const mcTableHeadCellFilterTextFieldProps = columnDef.muiTableHeadCellFilterSliderProps instanceof Function ? columnDef.muiTableHeadCellFilterSliderProps({
    column,
    table
  }) : columnDef.muiTableHeadCellFilterSliderProps;
  const sliderProps = Object.assign(Object.assign({}, mTableHeadCellFilterTextFieldProps), mcTableHeadCellFilterTextFieldProps);
  let [min2, max2] = sliderProps.min !== void 0 && sliderProps.max !== void 0 ? [sliderProps.min, sliderProps.max] : (_a = column.getFacetedMinMaxValues()) !== null && _a !== void 0 ? _a : [0, 1];
  if (Array.isArray(min2))
    min2 = min2[0];
  if (Array.isArray(max2))
    max2 = max2[0];
  if (min2 === null)
    min2 = 0;
  if (max2 === null)
    max2 = 1;
  const [filterValues, setFilterValues] = (0, import_react.useState)([min2, max2]);
  const columnFilterValue = column.getFilterValue();
  const isMounted = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(() => {
    if (isMounted.current) {
      if (columnFilterValue === void 0) {
        setFilterValues([min2, max2]);
      } else if (Array.isArray(columnFilterValue)) {
        setFilterValues(columnFilterValue);
      }
    }
    isMounted.current = true;
  }, [columnFilterValue, min2, max2]);
  return (0, import_jsx_runtime.jsxs)(Stack_default, { children: [(0, import_jsx_runtime.jsx)(Slider_default, Object.assign({ disableSwap: true, min: min2, max: max2, onChange: (_event, values) => {
    setFilterValues(values);
  }, onChangeCommitted: (_event, value) => {
    if (Array.isArray(value)) {
      if (value[0] <= min2 && value[1] >= max2) {
        column.setFilterValue(void 0);
      } else {
        column.setFilterValue(value);
      }
    }
  }, value: filterValues, valueLabelDisplay: "auto" }, sliderProps, { slotProps: {
    input: {
      ref: (node) => {
        var _a2, _b2;
        if (node) {
          filterInputRefs.current[`${column.id}-0`] = node;
          if ((_b2 = (_a2 = sliderProps === null || sliderProps === void 0 ? void 0 : sliderProps.slotProps) === null || _a2 === void 0 ? void 0 : _a2.input) === null || _b2 === void 0 ? void 0 : _b2.ref) {
            sliderProps.slotProps.input.ref = node;
          }
        }
      }
    }
  }, sx: (theme) => Object.assign({ m: "auto", mt: !showChangeModeButton ? "10px" : "6px", px: "4px", width: "calc(100% - 8px)" }, (sliderProps === null || sliderProps === void 0 ? void 0 : sliderProps.sx) instanceof Function ? sliderProps.sx(theme) : sliderProps === null || sliderProps === void 0 ? void 0 : sliderProps.sx) })), showChangeModeButton ? (0, import_jsx_runtime.jsx)(FormHelperText_default, { sx: {
    m: "-3px -6px",
    fontSize: "0.75rem",
    lineHeight: "0.8rem",
    whiteSpace: "nowrap"
  }, children: localization.filterMode.replace(
    "{filterType}",
    // @ts-ignore
    localization[`filter${((_b = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt(0)) === null || _b === void 0 ? void 0 : _b.toUpperCase()) + (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`]
  ) }) : null] });
};
var MRT_TableHeadCellFilterContainer = ({ header, table }) => {
  const { getState } = table;
  const { showColumnFilters } = getState();
  const { column } = header;
  const { columnDef } = column;
  return (0, import_jsx_runtime.jsx)(Collapse_default, { in: showColumnFilters, mountOnEnter: true, unmountOnExit: true, children: columnDef.filterVariant === "checkbox" ? (0, import_jsx_runtime.jsx)(MRT_FilterCheckbox, { column, table }) : columnDef.filterVariant === "range-slider" ? (0, import_jsx_runtime.jsx)(MRT_FilterRangeSlider, { header, table }) : columnDef.filterVariant === "range" || ["between", "betweenInclusive", "inNumberRange"].includes(columnDef._filterFn) ? (0, import_jsx_runtime.jsx)(MRT_FilterRangeFields, { header, table }) : (0, import_jsx_runtime.jsx)(MRT_FilterTextField, { header, table }) });
};
var MRT_TableHeadCellFilterLabel = ({ header, table }) => {
  var _a, _b, _c, _d;
  const { options: { icons: { FilterAltIcon: FilterAltIcon2 }, localization }, refs: { filterInputRefs }, setShowColumnFilters } = table;
  const { column } = header;
  const { columnDef } = column;
  const isRangeFilter = ["range", "ranger-slider"].includes((_a = columnDef.filterVariant) !== null && _a !== void 0 ? _a : "") || ["between", "betweenInclusive", "inNumberRange"].includes(columnDef._filterFn);
  const currentFilterOption = columnDef._filterFn;
  const filterTooltip = localization.filteringByColumn.replace("{column}", String(columnDef.header)).replace(
    "{filterType}",
    // @ts-ignore
    localization[`filter${((_b = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt(0)) === null || _b === void 0 ? void 0 : _b.toUpperCase()) + (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`]
  ).replace("{filterValue}", `"${Array.isArray(column.getFilterValue()) ? column.getFilterValue().join(`" ${isRangeFilter ? localization.and : localization.or} "`) : column.getFilterValue()}"`).replace('" "', "");
  return (0, import_jsx_runtime.jsx)(Grow_default, { unmountOnExit: true, in: !!column.getFilterValue() && !isRangeFilter || isRangeFilter && // @ts-ignore
  (!!((_c = column.getFilterValue()) === null || _c === void 0 ? void 0 : _c[0]) || !!((_d = column.getFilterValue()) === null || _d === void 0 ? void 0 : _d[1])), children: (0, import_jsx_runtime.jsx)(Box_default, { component: "span", sx: { flex: "0 0" }, children: (0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, placement: "top", title: filterTooltip, children: (0, import_jsx_runtime.jsx)(IconButton_default, { disableRipple: true, onClick: (event) => {
    setShowColumnFilters(true);
    queueMicrotask(() => {
      var _a2, _b2;
      (_a2 = filterInputRefs.current[`${column.id}-0`]) === null || _a2 === void 0 ? void 0 : _a2.focus();
      (_b2 = filterInputRefs.current[`${column.id}-0`]) === null || _b2 === void 0 ? void 0 : _b2.select();
    });
    event.stopPropagation();
  }, size: "small", sx: {
    height: "12px",
    m: 0,
    opacity: 0.8,
    p: "2px",
    transform: "scale(0.66)",
    width: "12px"
  }, children: (0, import_jsx_runtime.jsx)(FilterAltIcon2, {}) }) }) }) });
};
var MRT_TableHeadCellGrabHandle = ({ column, table, tableHeadCellRef }) => {
  const { getState, options: { enableColumnOrdering, muiTableHeadCellDragHandleProps }, setColumnOrder, setDraggingColumn, setHoveredColumn } = table;
  const { columnDef } = column;
  const { hoveredColumn, draggingColumn, columnOrder } = getState();
  const mIconButtonProps = muiTableHeadCellDragHandleProps instanceof Function ? muiTableHeadCellDragHandleProps({ column, table }) : muiTableHeadCellDragHandleProps;
  const mcIconButtonProps = columnDef.muiTableHeadCellDragHandleProps instanceof Function ? columnDef.muiTableHeadCellDragHandleProps({ column, table }) : columnDef.muiTableHeadCellDragHandleProps;
  const iconButtonProps = Object.assign(Object.assign({}, mIconButtonProps), mcIconButtonProps);
  const handleDragStart = (event) => {
    var _a;
    (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onDragStart) === null || _a === void 0 ? void 0 : _a.call(iconButtonProps, event);
    setDraggingColumn(column);
    event.dataTransfer.setDragImage(tableHeadCellRef.current, 0, 0);
  };
  const handleDragEnd = (event) => {
    var _a;
    (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onDragEnd) === null || _a === void 0 ? void 0 : _a.call(iconButtonProps, event);
    if ((hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === "drop-zone") {
      column.toggleGrouping();
    } else if (enableColumnOrdering && hoveredColumn && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) !== (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id)) {
      setColumnOrder(reorderColumn(column, hoveredColumn, columnOrder));
    }
    setDraggingColumn(null);
    setHoveredColumn(null);
  };
  return (0, import_jsx_runtime.jsx)(MRT_GrabHandleButton, { iconButtonProps, onDragStart: handleDragStart, onDragEnd: handleDragEnd, table });
};
var MRT_TableHeadCellResizeHandle = ({ header, table }) => {
  var _a;
  const { getState, options: { columnResizeMode }, setColumnSizingInfo } = table;
  const { density } = getState();
  const { column } = header;
  return (0, import_jsx_runtime.jsx)(Box_default, { className: "Mui-TableHeadCell-ResizeHandle-Wrapper", onDoubleClick: () => {
    setColumnSizingInfo((old) => Object.assign(Object.assign({}, old), { isResizingColumn: false }));
    column.resetSize();
  }, onMouseDown: header.getResizeHandler(), onTouchStart: header.getResizeHandler(), sx: (theme) => ({
    cursor: "col-resize",
    mr: density === "compact" ? "-0.75rem" : "-1rem",
    position: "absolute",
    right: "4px",
    px: "4px",
    "&:active > hr": {
      backgroundColor: theme.palette.info.main,
      opacity: 1
    }
  }), style: {
    transform: column.getIsResizing() && columnResizeMode === "onEnd" ? `translateX(${(_a = getState().columnSizingInfo.deltaOffset) !== null && _a !== void 0 ? _a : 0}px)` : void 0
  }, children: (0, import_jsx_runtime.jsx)(Divider_default, { className: "Mui-TableHeadCell-ResizeHandle-Divider", flexItem: true, orientation: "vertical", sx: {
    borderRadius: "2px",
    borderWidth: "2px",
    height: "24px",
    touchAction: "none",
    transition: column.getIsResizing() ? void 0 : "all 150ms ease-in-out",
    userSelect: "none",
    zIndex: 4
  } }) });
};
var MRT_TableHeadCellSortLabel = ({ header, table, tableCellProps }) => {
  const { getState, options: { icons: { ArrowDownwardIcon: ArrowDownwardIcon2 }, localization } } = table;
  const { column } = header;
  const { columnDef } = column;
  const { sorting } = getState();
  const sortTooltip = column.getIsSorted() ? column.getIsSorted() === "desc" ? localization.sortedByColumnDesc.replace("{column}", columnDef.header) : localization.sortedByColumnAsc.replace("{column}", columnDef.header) : localization.unsorted;
  return (0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, placement: "top", title: sortTooltip, children: (0, import_jsx_runtime.jsx)(Badge_default, { badgeContent: sorting.length > 1 ? column.getSortIndex() + 1 : 0, overlap: "circular", children: (0, import_jsx_runtime.jsx)(TableSortLabel_default, { "aria-label": sortTooltip, active: !!column.getIsSorted(), direction: column.getIsSorted() ? column.getIsSorted() : void 0, sx: {
    flex: "0 0",
    width: "2.4ch",
    transform: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) !== "right" ? "translateX(-0.5ch)" : void 0
  }, IconComponent: ArrowDownwardIcon2, onClick: (e) => {
    var _a;
    e.stopPropagation();
    (_a = header.column.getToggleSortingHandler()) === null || _a === void 0 ? void 0 : _a(e);
  } }) }) });
};
var MRT_TableHeadCell = ({ header, table }) => {
  var _a, _b, _c, _d, _f, _g;
  const theme = useTheme();
  const { getState, options: { enableColumnActions, enableColumnDragging, enableColumnOrdering, enableGrouping, enableMultiSort, layoutMode, muiTableHeadCellProps }, refs: { tableHeadCellRefs }, setHoveredColumn } = table;
  const { density, draggingColumn, grouping, hoveredColumn, showColumnFilters } = getState();
  const { column } = header;
  const { columnDef } = column;
  const { columnDefType } = columnDef;
  const mTableHeadCellProps = muiTableHeadCellProps instanceof Function ? muiTableHeadCellProps({ column, table }) : muiTableHeadCellProps;
  const mcTableHeadCellProps = columnDef.muiTableHeadCellProps instanceof Function ? columnDef.muiTableHeadCellProps({ column, table }) : columnDef.muiTableHeadCellProps;
  const tableCellProps = Object.assign(Object.assign({}, mTableHeadCellProps), mcTableHeadCellProps);
  const showColumnActions = (enableColumnActions || columnDef.enableColumnActions) && columnDef.enableColumnActions !== false;
  const showDragHandle = enableColumnDragging !== false && columnDef.enableColumnDragging !== false && (enableColumnDragging || enableColumnOrdering && columnDef.enableColumnOrdering !== false || enableGrouping && columnDef.enableGrouping !== false && !grouping.includes(column.id));
  const headerPL = (0, import_react.useMemo)(() => {
    let pl = 0;
    if (column.getCanSort())
      pl++;
    if (showColumnActions)
      pl += 1.75;
    if (showDragHandle)
      pl += 1.25;
    return pl;
  }, [showColumnActions, showDragHandle]);
  const draggingBorder = (0, import_react.useMemo)(() => (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id ? `1px dashed ${theme.palette.text.secondary}` : (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id ? `2px dashed ${theme.palette.primary.main}` : void 0, [draggingColumn, hoveredColumn]);
  const draggingBorders = draggingBorder ? {
    borderLeft: draggingBorder,
    borderRight: draggingBorder,
    borderTop: draggingBorder
  } : void 0;
  const handleDragEnter = (_e) => {
    if (enableGrouping && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === "drop-zone") {
      setHoveredColumn(null);
    }
    if (enableColumnOrdering && draggingColumn && columnDefType !== "group") {
      setHoveredColumn(columnDef.enableColumnOrdering !== false ? column : null);
    }
  };
  const headerElement = (columnDef === null || columnDef === void 0 ? void 0 : columnDef.Header) instanceof Function ? (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.Header) === null || _a === void 0 ? void 0 : _a.call(columnDef, {
    column,
    header,
    table
  }) : (_b = columnDef === null || columnDef === void 0 ? void 0 : columnDef.Header) !== null && _b !== void 0 ? _b : columnDef.header;
  return (0, import_jsx_runtime.jsxs)(TableCell_default, Object.assign({ align: columnDefType === "group" ? "center" : "left", colSpan: header.colSpan, onDragEnter: handleDragEnter, ref: (node) => {
    if (node) {
      tableHeadCellRefs.current[column.id] = node;
    }
  } }, tableCellProps, { sx: (theme2) => Object.assign(Object.assign({ flexDirection: layoutMode === "grid" ? "column" : void 0, fontWeight: "bold", overflow: "visible", p: density === "compact" ? "0.5rem" : density === "comfortable" ? columnDefType === "display" ? "0.75rem" : "1rem" : columnDefType === "display" ? "1rem 1.25rem" : "1.5rem", pb: columnDefType === "display" ? 0 : showColumnFilters || density === "compact" ? "0.4rem" : "0.6rem", pt: columnDefType === "group" || density === "compact" ? "0.25rem" : density === "comfortable" ? ".75rem" : "1.25rem", userSelect: enableMultiSort && column.getCanSort() ? "none" : void 0, verticalAlign: "top", zIndex: column.getIsResizing() || (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id ? 3 : column.getIsPinned() && columnDefType !== "group" ? 2 : 1 }, getCommonCellStyles({
    column,
    header,
    table,
    tableCellProps,
    theme: theme2
  })), draggingBorders), children: [header.isPlaceholder ? null : (0, import_jsx_runtime.jsxs)(Box_default, { className: "Mui-TableHeadCell-Content", sx: {
    alignItems: "center",
    display: "flex",
    flexDirection: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === "right" ? "row-reverse" : "row",
    justifyContent: columnDefType === "group" || (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === "center" ? "center" : column.getCanResize() ? "space-between" : "flex-start",
    position: "relative",
    width: "100%"
  }, children: [(0, import_jsx_runtime.jsxs)(Box_default, { className: "Mui-TableHeadCell-Content-Labels", onClick: column.getToggleSortingHandler(), sx: {
    alignItems: "center",
    cursor: column.getCanSort() && columnDefType !== "group" ? "pointer" : void 0,
    display: "flex",
    flexDirection: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === "right" ? "row-reverse" : "row",
    overflow: columnDefType === "data" ? "hidden" : void 0,
    pl: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === "center" ? `${headerPL}rem` : void 0
  }, children: [(0, import_jsx_runtime.jsx)(Box_default, { className: "Mui-TableHeadCell-Content-Wrapper", sx: {
    minWidth: `${Math.min((_d = (_c = columnDef.header) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0, 5)}ch`,
    overflow: columnDefType === "data" ? "hidden" : void 0,
    textOverflow: "ellipsis",
    whiteSpace: ((_g = (_f = columnDef.header) === null || _f === void 0 ? void 0 : _f.length) !== null && _g !== void 0 ? _g : 0) < 20 ? "nowrap" : "normal",
    "&:hover": {
      textOverflow: "clip"
    }
  }, title: columnDefType === "data" ? columnDef.header : void 0, children: headerElement }), column.getCanSort() && (0, import_jsx_runtime.jsx)(MRT_TableHeadCellSortLabel, { header, table, tableCellProps }), column.getCanFilter() && (0, import_jsx_runtime.jsx)(MRT_TableHeadCellFilterLabel, { header, table })] }), columnDefType !== "group" && (0, import_jsx_runtime.jsxs)(Box_default, { className: "Mui-TableHeadCell-Content-Actions", sx: { whiteSpace: "nowrap" }, children: [showDragHandle && (0, import_jsx_runtime.jsx)(MRT_TableHeadCellGrabHandle, { column, table, tableHeadCellRef: {
    current: tableHeadCellRefs.current[column.id]
  } }), showColumnActions && (0, import_jsx_runtime.jsx)(MRT_TableHeadCellColumnActionsButton, { header, table })] }), column.getCanResize() && (0, import_jsx_runtime.jsx)(MRT_TableHeadCellResizeHandle, { header, table })] }), column.getCanFilter() && (0, import_jsx_runtime.jsx)(MRT_TableHeadCellFilterContainer, { header, table })] }));
};
var MRT_TableHeadRow = ({ headerGroup, table, virtualColumns, virtualPaddingLeft, virtualPaddingRight }) => {
  const { options: { layoutMode, muiTableHeadRowProps } } = table;
  const tableRowProps = muiTableHeadRowProps instanceof Function ? muiTableHeadRowProps({ headerGroup, table }) : muiTableHeadRowProps;
  return (0, import_jsx_runtime.jsxs)(TableRow_default, Object.assign({}, tableRowProps, { sx: (theme) => Object.assign({ backgroundColor: lighten(theme.palette.background.default, 0.04), boxShadow: `4px 0 8px ${alpha(theme.palette.common.black, 0.1)}`, display: layoutMode === "grid" ? "flex" : "table-row", top: 0 }, (tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx) instanceof Function ? tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx(theme) : tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx), children: [virtualPaddingLeft ? (0, import_jsx_runtime.jsx)("th", { style: { display: "flex", width: virtualPaddingLeft } }) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : headerGroup.headers).map((headerOrVirtualHeader) => {
    const header = virtualColumns ? headerGroup.headers[headerOrVirtualHeader.index] : headerOrVirtualHeader;
    return (0, import_jsx_runtime.jsx)(MRT_TableHeadCell, { header, table }, header.id);
  }), virtualPaddingRight ? (0, import_jsx_runtime.jsx)("th", { style: { display: "flex", width: virtualPaddingRight } }) : null] }));
};
var MRT_TableHead = ({ table, virtualColumns, virtualPaddingLeft, virtualPaddingRight }) => {
  const { getHeaderGroups, getState, options: { enableStickyHeader, layoutMode, muiTableHeadProps } } = table;
  const { isFullScreen } = getState();
  const tableHeadProps = muiTableHeadProps instanceof Function ? muiTableHeadProps({ table }) : muiTableHeadProps;
  const stickyHeader = enableStickyHeader || isFullScreen;
  return (0, import_jsx_runtime.jsx)(TableHead_default, Object.assign({}, tableHeadProps, { sx: (theme) => Object.assign({ display: layoutMode === "grid" ? "grid" : "table-row-group", opacity: 0.97, position: stickyHeader ? "sticky" : "relative", top: stickyHeader && layoutMode === "grid" ? 0 : void 0, zIndex: stickyHeader ? 2 : void 0 }, (tableHeadProps === null || tableHeadProps === void 0 ? void 0 : tableHeadProps.sx) instanceof Function ? tableHeadProps === null || tableHeadProps === void 0 ? void 0 : tableHeadProps.sx(theme) : tableHeadProps === null || tableHeadProps === void 0 ? void 0 : tableHeadProps.sx), children: getHeaderGroups().map((headerGroup) => (0, import_jsx_runtime.jsx)(MRT_TableHeadRow, { headerGroup, table, virtualColumns, virtualPaddingLeft, virtualPaddingRight }, headerGroup.id)) }));
};
var MRT_EditCellTextField = ({ cell, showLabel, table }) => {
  var _a, _b, _c;
  const { getState, options: { muiTableBodyCellEditTextFieldProps }, refs: { editInputRefs }, setEditingCell, setEditingRow } = table;
  const { column, row } = cell;
  const { columnDef } = column;
  const { editingRow } = getState();
  const [value, setValue] = (0, import_react.useState)(() => cell.getValue());
  const mTableBodyCellEditTextFieldProps = muiTableBodyCellEditTextFieldProps instanceof Function ? muiTableBodyCellEditTextFieldProps({ cell, column, row, table }) : muiTableBodyCellEditTextFieldProps;
  const mcTableBodyCellEditTextFieldProps = columnDef.muiTableBodyCellEditTextFieldProps instanceof Function ? columnDef.muiTableBodyCellEditTextFieldProps({
    cell,
    column,
    row,
    table
  }) : columnDef.muiTableBodyCellEditTextFieldProps;
  const textFieldProps = Object.assign(Object.assign({}, mTableBodyCellEditTextFieldProps), mcTableBodyCellEditTextFieldProps);
  const isSelectEdit = columnDef.editVariant === "select";
  const saveRow = (newValue) => {
    if (editingRow) {
      setEditingRow(Object.assign(Object.assign({}, editingRow), { _valuesCache: Object.assign(Object.assign({}, editingRow._valuesCache), { [column.id]: newValue }) }));
    }
  };
  const handleChange = (event) => {
    var _a2;
    (_a2 = textFieldProps.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(textFieldProps, event);
    setValue(event.target.value);
    if (textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.select) {
      saveRow(event.target.value);
    }
  };
  const handleBlur = (event) => {
    var _a2;
    (_a2 = textFieldProps.onBlur) === null || _a2 === void 0 ? void 0 : _a2.call(textFieldProps, event);
    saveRow(value);
    setEditingCell(null);
  };
  const handleEnterKeyDown = (event) => {
    var _a2, _b2;
    (_a2 = textFieldProps.onKeyDown) === null || _a2 === void 0 ? void 0 : _a2.call(textFieldProps, event);
    if (event.key === "Enter") {
      (_b2 = editInputRefs.current[column.id]) === null || _b2 === void 0 ? void 0 : _b2.blur();
    }
  };
  if (columnDef.Edit) {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (_a = columnDef.Edit) === null || _a === void 0 ? void 0 : _a.call(columnDef, { cell, column, row, table }) });
  }
  return (0, import_jsx_runtime.jsx)(TextField_default, Object.assign({ disabled: (columnDef.enableEditing instanceof Function ? columnDef.enableEditing(row) : columnDef.enableEditing) === false, fullWidth: true, inputRef: (inputRef) => {
    if (inputRef) {
      editInputRefs.current[column.id] = inputRef;
      if (textFieldProps.inputRef) {
        textFieldProps.inputRef = inputRef;
      }
    }
  }, label: showLabel ? column.columnDef.header : void 0, margin: "none", name: column.id, placeholder: columnDef.header, select: isSelectEdit, value, variant: "standard" }, textFieldProps, { onClick: (e) => {
    var _a2;
    e.stopPropagation();
    (_a2 = textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(textFieldProps, e);
  }, onBlur: handleBlur, onChange: handleChange, onKeyDown: handleEnterKeyDown, children: (_b = textFieldProps.children) !== null && _b !== void 0 ? _b : (_c = columnDef === null || columnDef === void 0 ? void 0 : columnDef.editSelectOptions) === null || _c === void 0 ? void 0 : _c.map((option) => {
    let value2;
    let text2;
    if (typeof option !== "object") {
      value2 = option;
      text2 = option;
    } else {
      value2 = option.value;
      text2 = option.text;
    }
    return (0, import_jsx_runtime.jsx)(MenuItem_default, { sx: {
      display: "flex",
      m: 0,
      alignItems: "center",
      gap: "0.5rem"
    }, value: value2, children: text2 }, value2);
  }) }));
};
var MRT_CopyButton = ({ cell, children, table }) => {
  var _a;
  const { options: { localization, muiTableBodyCellCopyButtonProps } } = table;
  const { column, row } = cell;
  const { columnDef } = column;
  const [copied, setCopied] = (0, import_react.useState)(false);
  const handleCopy = (event, text2) => {
    event.stopPropagation();
    navigator.clipboard.writeText(text2);
    setCopied(true);
    setTimeout(() => setCopied(false), 4e3);
  };
  const mTableBodyCellCopyButtonProps = muiTableBodyCellCopyButtonProps instanceof Function ? muiTableBodyCellCopyButtonProps({ cell, column, row, table }) : muiTableBodyCellCopyButtonProps;
  const mcTableBodyCellCopyButtonProps = columnDef.muiTableBodyCellCopyButtonProps instanceof Function ? columnDef.muiTableBodyCellCopyButtonProps({
    cell,
    column,
    row,
    table
  }) : columnDef.muiTableBodyCellCopyButtonProps;
  const buttonProps = Object.assign(Object.assign({}, mTableBodyCellCopyButtonProps), mcTableBodyCellCopyButtonProps);
  return (0, import_jsx_runtime.jsx)(Tooltip_default, { arrow: true, enterDelay: 1e3, enterNextDelay: 1e3, placement: "top", title: (_a = buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.title) !== null && _a !== void 0 ? _a : copied ? localization.copiedToClipboard : localization.clickToCopy, children: (0, import_jsx_runtime.jsx)(Button_default, Object.assign({ onClick: (e) => handleCopy(e, cell.getValue()), size: "small", type: "button", variant: "text" }, buttonProps, { sx: (theme) => Object.assign({ backgroundColor: "transparent", border: "none", color: "inherit", cursor: "copy", fontFamily: "inherit", fontSize: "inherit", letterSpacing: "inherit", m: "-0.25rem", minWidth: "unset", textAlign: "inherit", textTransform: "inherit" }, (buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.sx) instanceof Function ? buttonProps.sx(theme) : buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.sx), title: void 0, children })) });
};
var MRT_TableBodyRowGrabHandle = ({ cell, rowRef, table }) => {
  const { options: { muiTableBodyRowDragHandleProps } } = table;
  const { row } = cell;
  const iconButtonProps = muiTableBodyRowDragHandleProps instanceof Function ? muiTableBodyRowDragHandleProps({ row, table }) : muiTableBodyRowDragHandleProps;
  const handleDragStart = (event) => {
    var _a;
    (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onDragStart) === null || _a === void 0 ? void 0 : _a.call(iconButtonProps, event);
    event.dataTransfer.setDragImage(rowRef.current, 0, 0);
    table.setDraggingRow(row);
  };
  const handleDragEnd = (event) => {
    var _a;
    (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onDragEnd) === null || _a === void 0 ? void 0 : _a.call(iconButtonProps, event);
    table.setDraggingRow(null);
    table.setHoveredRow(null);
  };
  return (0, import_jsx_runtime.jsx)(MRT_GrabHandleButton, { iconButtonProps, onDragStart: handleDragStart, onDragEnd: handleDragEnd, table });
};
var allowedTypes = ["string", "number"];
var MRT_TableBodyCellValue = ({ cell, table }) => {
  var _a, _b, _c;
  const { getState, options: { enableFilterMatchHighlighting } } = table;
  const { column, row } = cell;
  const { columnDef } = column;
  const { globalFilter, globalFilterFn } = getState();
  const filterValue = column.getFilterValue();
  let renderedCellValue = cell.getIsAggregated() && columnDef.AggregatedCell ? columnDef.AggregatedCell({
    cell,
    column,
    row,
    table
  }) : row.getIsGrouped() && !cell.getIsGrouped() ? null : cell.getIsGrouped() && columnDef.GroupedCell ? columnDef.GroupedCell({
    cell,
    column,
    row,
    table
  }) : void 0;
  const isGroupedValue = renderedCellValue !== void 0;
  if (!isGroupedValue) {
    renderedCellValue = cell.renderValue();
  }
  if (enableFilterMatchHighlighting && columnDef.enableFilterMatchHighlighting !== false && renderedCellValue && allowedTypes.includes(typeof renderedCellValue) && (filterValue && allowedTypes.includes(typeof filterValue) && columnDef.filterVariant === "text" || globalFilter && allowedTypes.includes(typeof globalFilter) && column.getCanGlobalFilter())) {
    const chunks = highlightWords === null || highlightWords === void 0 ? void 0 : highlightWords({
      text: renderedCellValue === null || renderedCellValue === void 0 ? void 0 : renderedCellValue.toString(),
      query: ((_a = filterValue !== null && filterValue !== void 0 ? filterValue : globalFilter) !== null && _a !== void 0 ? _a : "").toString(),
      matchExactly: (filterValue ? columnDef._filterFn : globalFilterFn) !== "fuzzy"
    });
    if ((chunks === null || chunks === void 0 ? void 0 : chunks.length) > 1 || ((_b = chunks === null || chunks === void 0 ? void 0 : chunks[0]) === null || _b === void 0 ? void 0 : _b.match)) {
      renderedCellValue = (0, import_jsx_runtime.jsx)("span", { "aria-label": renderedCellValue, role: "note", children: (_c = chunks === null || chunks === void 0 ? void 0 : chunks.map(({ key, match, text: text2 }) => (0, import_jsx_runtime.jsx)(Box_default, { "aria-hidden": "true", component: "span", sx: match ? {
        backgroundColor: (theme) => theme.palette.mode === "dark" ? darken(theme.palette.warning.dark, 0.25) : lighten(theme.palette.warning.light, 0.5),
        borderRadius: "2px",
        color: (theme) => theme.palette.mode === "dark" ? "white" : "black",
        padding: "2px 1px"
      } : void 0, children: text2 }, key))) !== null && _c !== void 0 ? _c : renderedCellValue });
    }
  }
  if (columnDef.Cell && !isGroupedValue) {
    renderedCellValue = columnDef.Cell({
      cell,
      renderedCellValue,
      column,
      row,
      table
    });
  }
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: renderedCellValue });
};
var MRT_TableBodyCell = ({ cell, measureElement: measureElement3, numRows, rowIndex, rowRef, table, virtualCell }) => {
  var _a, _b, _c, _d;
  const theme = useTheme();
  const { getState, options: { editingMode, enableClickToCopy, enableColumnOrdering, enableEditing, enableGrouping, enableRowNumbers, layoutMode, muiTableBodyCellProps, muiTableBodyCellSkeletonProps, rowNumberMode }, refs: { editInputRefs }, setEditingCell, setHoveredColumn } = table;
  const { draggingColumn, draggingRow, editingCell, editingRow, hoveredColumn, hoveredRow, density, isLoading, showSkeletons } = getState();
  const { column, row } = cell;
  const { columnDef } = column;
  const { columnDefType } = columnDef;
  const mTableCellBodyProps = muiTableBodyCellProps instanceof Function ? muiTableBodyCellProps({ cell, column, row, table }) : muiTableBodyCellProps;
  const mcTableCellBodyProps = columnDef.muiTableBodyCellProps instanceof Function ? columnDef.muiTableBodyCellProps({ cell, column, row, table }) : columnDef.muiTableBodyCellProps;
  const tableCellProps = Object.assign(Object.assign({}, mTableCellBodyProps), mcTableCellBodyProps);
  const skeletonProps = muiTableBodyCellSkeletonProps instanceof Function ? muiTableBodyCellSkeletonProps({ cell, column, row, table }) : muiTableBodyCellSkeletonProps;
  const [skeletonWidth, setSkeletonWidth] = (0, import_react.useState)(0);
  (0, import_react.useEffect)(() => setSkeletonWidth(isLoading || showSkeletons ? columnDefType === "display" ? column.getSize() / 2 : Math.round(Math.random() * (column.getSize() - column.getSize() / 3) + column.getSize() / 3) : 100), []);
  const draggingBorders = (0, import_react.useMemo)(() => {
    const isDraggingColumn = (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id;
    const isHoveredColumn = (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id;
    const isDraggingRow = (draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.id) === row.id;
    const isHoveredRow = (hoveredRow === null || hoveredRow === void 0 ? void 0 : hoveredRow.id) === row.id;
    const isFirstColumn = getIsFirstColumn(column, table);
    const isLastColumn = getIsLastColumn(column, table);
    const isLastRow = rowIndex === numRows - 1;
    const borderStyle = isDraggingColumn || isDraggingRow ? `1px dashed ${theme.palette.text.secondary} !important` : isHoveredColumn || isHoveredRow ? `2px dashed ${theme.palette.primary.main} !important` : void 0;
    return borderStyle ? {
      borderLeft: isDraggingColumn || isHoveredColumn || (isDraggingRow || isHoveredRow) && isFirstColumn ? borderStyle : void 0,
      borderRight: isDraggingColumn || isHoveredColumn || (isDraggingRow || isHoveredRow) && isLastColumn ? borderStyle : void 0,
      borderBottom: isDraggingRow || isHoveredRow || isLastRow ? borderStyle : void 0,
      borderTop: isDraggingRow || isHoveredRow ? borderStyle : void 0
    } : void 0;
  }, [draggingColumn, draggingRow, hoveredColumn, hoveredRow, rowIndex]);
  const isEditable = (enableEditing instanceof Function ? enableEditing(row) : enableEditing) && (columnDef.enableEditing instanceof Function ? columnDef.enableEditing(row) : columnDef.enableEditing) !== false;
  const isEditing = isEditable && editingMode !== "modal" && (editingMode === "table" || (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id || (editingCell === null || editingCell === void 0 ? void 0 : editingCell.id) === cell.id) && !row.getIsGrouped();
  const handleDoubleClick = (event) => {
    var _a2;
    (_a2 = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onDoubleClick) === null || _a2 === void 0 ? void 0 : _a2.call(tableCellProps, event);
    if (isEditable && editingMode === "cell") {
      setEditingCell(cell);
      queueMicrotask(() => {
        var _a3;
        const textField = editInputRefs.current[column.id];
        if (textField) {
          textField.focus();
          (_a3 = textField.select) === null || _a3 === void 0 ? void 0 : _a3.call(textField);
        }
      });
    }
  };
  const handleDragEnter = (e) => {
    var _a2;
    (_a2 = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onDragEnter) === null || _a2 === void 0 ? void 0 : _a2.call(tableCellProps, e);
    if (enableGrouping && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === "drop-zone") {
      setHoveredColumn(null);
    }
    if (enableColumnOrdering && draggingColumn) {
      setHoveredColumn(columnDef.enableColumnOrdering !== false ? column : null);
    }
  };
  return (0, import_jsx_runtime.jsx)(TableCell_default, Object.assign({ "data-index": virtualCell === null || virtualCell === void 0 ? void 0 : virtualCell.index, ref: (node) => {
    if (node) {
      measureElement3 === null || measureElement3 === void 0 ? void 0 : measureElement3(node);
    }
  } }, tableCellProps, { onDragEnter: handleDragEnter, onDoubleClick: handleDoubleClick, sx: (theme2) => Object.assign(Object.assign({ alignItems: layoutMode === "grid" ? "center" : void 0, cursor: isEditable && editingMode === "cell" ? "pointer" : "inherit", justifyContent: layoutMode === "grid" ? tableCellProps.align : void 0, overflow: "hidden", p: density === "compact" ? columnDefType === "display" ? "0 0.5rem" : "0.5rem" : density === "comfortable" ? columnDefType === "display" ? "0.5rem 0.75rem" : "1rem" : columnDefType === "display" ? "1rem 1.25rem" : "1.5rem", pl: column.id === "mrt-row-expand" ? `${row.depth + (density === "compact" ? 0.5 : density === "comfortable" ? 0.75 : 1.25)}rem` : void 0, textOverflow: columnDefType !== "display" ? "ellipsis" : void 0, whiteSpace: density === "compact" ? "nowrap" : "normal", zIndex: (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id ? 2 : column.getIsPinned() ? 1 : 0, "&:hover": {
    outline: ["table", "cell"].includes(editingMode !== null && editingMode !== void 0 ? editingMode : "") ? `1px solid ${theme2.palette.text.secondary}` : void 0,
    outlineOffset: "-1px",
    textOverflow: "clip"
  } }, getCommonCellStyles({
    column,
    table,
    theme: theme2,
    tableCellProps
  })), draggingBorders), children: (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [cell.getIsPlaceholder() ? (_b = (_a = columnDef.PlaceholderCell) === null || _a === void 0 ? void 0 : _a.call(columnDef, { cell, column, row, table })) !== null && _b !== void 0 ? _b : null : isLoading || showSkeletons ? (0, import_jsx_runtime.jsx)(Skeleton_default, Object.assign({ animation: "wave", height: 20, width: skeletonWidth }, skeletonProps)) : enableRowNumbers && rowNumberMode === "static" && column.id === "mrt-row-numbers" ? rowIndex + 1 : column.id === "mrt-row-drag" ? (0, import_jsx_runtime.jsx)(MRT_TableBodyRowGrabHandle, { cell, rowRef, table }) : columnDefType === "display" && (column.id === "mrt-row-select" || column.id === "mrt-row-expand" || !row.getIsGrouped()) ? (_c = columnDef.Cell) === null || _c === void 0 ? void 0 : _c.call(columnDef, {
    cell,
    renderedCellValue: cell.renderValue(),
    column,
    row,
    table
  }) : isEditing ? (0, import_jsx_runtime.jsx)(MRT_EditCellTextField, { cell, table }) : (enableClickToCopy || columnDef.enableClickToCopy) && columnDef.enableClickToCopy !== false ? (0, import_jsx_runtime.jsx)(MRT_CopyButton, { cell, table, children: (0, import_jsx_runtime.jsx)(MRT_TableBodyCellValue, { cell, table }) }) : (0, import_jsx_runtime.jsx)(MRT_TableBodyCellValue, { cell, table }), cell.getIsGrouped() && !columnDef.GroupedCell && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [" (", (_d = row.subRows) === null || _d === void 0 ? void 0 : _d.length, ")"] })] }) }));
};
var Memo_MRT_TableBodyCell = (0, import_react.memo)(MRT_TableBodyCell, (prev, next) => next.cell === prev.cell);
var MRT_TableDetailPanel = ({ parentRowRef, row, rowIndex, table, virtualRow }) => {
  const { getVisibleLeafColumns, getState, options: { layoutMode, muiTableBodyRowProps, muiTableDetailPanelProps, renderDetailPanel } } = table;
  const { isLoading } = getState();
  const tableRowProps = muiTableBodyRowProps instanceof Function ? muiTableBodyRowProps({
    isDetailPanel: true,
    row,
    staticRowIndex: rowIndex,
    table
  }) : muiTableBodyRowProps;
  const tableCellProps = muiTableDetailPanelProps instanceof Function ? muiTableDetailPanelProps({ row, table }) : muiTableDetailPanelProps;
  return (0, import_jsx_runtime.jsx)(TableRow_default, Object.assign({ className: "Mui-TableBodyCell-DetailPanel" }, tableRowProps, { sx: (theme) => {
    var _a, _b;
    return Object.assign({ display: layoutMode === "grid" ? "flex" : "table-row", position: virtualRow ? "absolute" : void 0, top: virtualRow ? `${(_b = (_a = parentRowRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) === null || _b === void 0 ? void 0 : _b.height}px` : void 0, transform: virtualRow ? `translateY(${virtualRow === null || virtualRow === void 0 ? void 0 : virtualRow.start}px)` : void 0, width: "100%", zIndex: virtualRow ? 2 : void 0 }, (tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx) instanceof Function ? tableRowProps.sx(theme) : tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx);
  }, children: (0, import_jsx_runtime.jsx)(TableCell_default, Object.assign({ className: "Mui-TableBodyCell-DetailPanel", colSpan: getVisibleLeafColumns().length }, tableCellProps, { sx: (theme) => Object.assign({ backgroundColor: virtualRow ? lighten(theme.palette.background.default, 0.06) : void 0, borderBottom: !row.getIsExpanded() ? "none" : void 0, display: layoutMode === "grid" ? "flex" : "table-cell", pb: row.getIsExpanded() ? "1rem" : 0, pt: row.getIsExpanded() ? "1rem" : 0, transition: "all 150ms ease-in-out", width: `${table.getTotalSize()}px` }, (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx) instanceof Function ? tableCellProps.sx(theme) : tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx), children: renderDetailPanel && (0, import_jsx_runtime.jsx)(Collapse_default, { in: row.getIsExpanded(), mountOnEnter: true, unmountOnExit: true, children: !isLoading && renderDetailPanel({ row, table }) }) })) }));
};
var MRT_TableBodyRow = ({ columnVirtualizer, measureElement: measureElement3, numRows, row, rowIndex, table, virtualColumns, virtualPaddingLeft, virtualPaddingRight, virtualRow }) => {
  const { getState, options: { enableRowOrdering, layoutMode, memoMode, muiTableBodyRowProps, renderDetailPanel }, setHoveredRow } = table;
  const { draggingColumn, draggingRow, editingCell, editingRow, hoveredRow } = getState();
  const tableRowProps = muiTableBodyRowProps instanceof Function ? muiTableBodyRowProps({ row, staticRowIndex: rowIndex, table }) : muiTableBodyRowProps;
  const handleDragEnter = (_e) => {
    if (enableRowOrdering && draggingRow) {
      setHoveredRow(row);
    }
  };
  const rowRef = (0, import_react.useRef)(null);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsxs)(TableRow_default, Object.assign({ "data-index": virtualRow === null || virtualRow === void 0 ? void 0 : virtualRow.index, onDragEnter: handleDragEnter, selected: row.getIsSelected(), ref: (node) => {
    if (node) {
      rowRef.current = node;
      measureElement3 === null || measureElement3 === void 0 ? void 0 : measureElement3(node);
    }
  } }, tableRowProps, { sx: (theme) => Object.assign({ backgroundColor: lighten(theme.palette.background.default, 0.06), boxSizing: "border-box", display: layoutMode === "grid" ? "flex" : "table-row", opacity: (draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.id) === row.id || (hoveredRow === null || hoveredRow === void 0 ? void 0 : hoveredRow.id) === row.id ? 0.5 : 1, position: virtualRow ? "absolute" : void 0, transition: virtualRow ? "none" : "all 150ms ease-in-out", top: virtualRow ? 0 : void 0, width: "100%", "&:hover td": {
    backgroundColor: (tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.hover) !== false ? row.getIsSelected() ? `${alpha(theme.palette.primary.main, 0.2)}` : theme.palette.mode === "dark" ? `${lighten(theme.palette.background.default, 0.12)}` : `${darken(theme.palette.background.default, 0.05)}` : void 0
  } }, (tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx) instanceof Function ? tableRowProps.sx(theme) : tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx), style: Object.assign({ transform: virtualRow ? `translateY(${virtualRow === null || virtualRow === void 0 ? void 0 : virtualRow.start}px)` : void 0 }, tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.style), children: [virtualPaddingLeft ? (0, import_jsx_runtime.jsx)("td", { style: { display: "flex", width: virtualPaddingLeft } }) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : row.getVisibleCells()).map((cellOrVirtualCell) => {
    const cell = columnVirtualizer ? row.getVisibleCells()[cellOrVirtualCell.index] : cellOrVirtualCell;
    const props = {
      cell,
      measureElement: columnVirtualizer === null || columnVirtualizer === void 0 ? void 0 : columnVirtualizer.measureElement,
      numRows,
      rowIndex,
      rowRef,
      table,
      virtualCell: columnVirtualizer ? cellOrVirtualCell : void 0
    };
    return memoMode === "cells" && cell.column.columnDef.columnDefType === "data" && !draggingColumn && !draggingRow && (editingCell === null || editingCell === void 0 ? void 0 : editingCell.id) !== cell.id && (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) !== row.id ? (0, import_jsx_runtime.jsx)(Memo_MRT_TableBodyCell, Object.assign({}, props), cell.id) : (0, import_jsx_runtime.jsx)(MRT_TableBodyCell, Object.assign({}, props), cell.id);
  }), virtualPaddingRight ? (0, import_jsx_runtime.jsx)("td", { style: { display: "flex", width: virtualPaddingRight } }) : null] })), renderDetailPanel && !row.getIsGrouped() && (0, import_jsx_runtime.jsx)(MRT_TableDetailPanel, { parentRowRef: rowRef, row, rowIndex, table, virtualRow })] });
};
var Memo_MRT_TableBodyRow = (0, import_react.memo)(MRT_TableBodyRow, (prev, next) => prev.row === next.row && prev.rowIndex === next.rowIndex);
var MRT_TableBody = ({ columnVirtualizer, table, virtualColumns, virtualPaddingLeft, virtualPaddingRight }) => {
  var _a, _b, _c, _d;
  const { getRowModel, getPrePaginationRowModel, getState, options: { enableGlobalFilterRankedResults, enablePagination, enableRowVirtualization, layoutMode, localization, manualExpanding, manualFiltering, manualGrouping, manualPagination, manualSorting, memoMode, muiTableBodyProps, renderEmptyRowsFallback, rowVirtualizerInstanceRef, rowVirtualizerProps, virtualizerInstanceRef, virtualizerProps }, refs: { tableContainerRef, tablePaperRef } } = table;
  const { columnFilters, density, expanded, globalFilter, globalFilterFn, pagination, sorting } = getState();
  const tableBodyProps = muiTableBodyProps instanceof Function ? muiTableBodyProps({ table }) : muiTableBodyProps;
  const vProps_old = virtualizerProps instanceof Function ? virtualizerProps({ table }) : virtualizerProps;
  const vProps = rowVirtualizerProps instanceof Function ? rowVirtualizerProps({ table }) : rowVirtualizerProps;
  const shouldRankResults = (0, import_react.useMemo)(() => !manualExpanding && !manualFiltering && !manualGrouping && !manualSorting && enableGlobalFilterRankedResults && globalFilter && globalFilterFn === "fuzzy" && expanded !== true && !Object.values(sorting).some(Boolean) && !Object.values(expanded).some(Boolean), [
    enableGlobalFilterRankedResults,
    expanded,
    globalFilter,
    manualExpanding,
    manualFiltering,
    manualGrouping,
    manualSorting,
    sorting
  ]);
  const rows = (0, import_react.useMemo)(() => {
    if (!shouldRankResults)
      return getRowModel().rows;
    const rankedRows = getPrePaginationRowModel().rows.sort((a, b) => rankGlobalFuzzy(a, b));
    if (enablePagination && !manualPagination) {
      const start = pagination.pageIndex * pagination.pageSize;
      return rankedRows.slice(start, start + pagination.pageSize);
    }
    return rankedRows;
  }, [
    shouldRankResults,
    shouldRankResults ? getPrePaginationRowModel().rows : getRowModel().rows,
    pagination.pageIndex,
    pagination.pageSize
  ]);
  const rowVirtualizer = enableRowVirtualization ? useVirtualizer(Object.assign(Object.assign({ count: rows.length, estimateSize: () => density === "compact" ? 37 : density === "comfortable" ? 58 : 73, getScrollElement: () => tableContainerRef.current, measureElement: typeof window !== "undefined" && navigator.userAgent.indexOf("Firefox") === -1 ? (element) => element === null || element === void 0 ? void 0 : element.getBoundingClientRect().height : void 0, overscan: 4 }, vProps_old), vProps)) : void 0;
  if (rowVirtualizerInstanceRef && rowVirtualizer) {
    rowVirtualizerInstanceRef.current = rowVirtualizer;
  }
  if (virtualizerInstanceRef && rowVirtualizer) {
    virtualizerInstanceRef.current = rowVirtualizer;
  }
  const virtualRows = rowVirtualizer ? rowVirtualizer.getVirtualItems() : void 0;
  return (0, import_jsx_runtime.jsx)(TableBody_default, Object.assign({}, tableBodyProps, { sx: (theme) => Object.assign({ display: layoutMode === "grid" ? "grid" : "table-row-group", height: rowVirtualizer ? `${rowVirtualizer.getTotalSize()}px` : "inherit", minHeight: !rows.length ? "100px" : void 0, position: "relative" }, (tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.sx) instanceof Function ? tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.sx(theme) : tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.sx), children: (_a = tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.children) !== null && _a !== void 0 ? _a : !rows.length ? (0, import_jsx_runtime.jsx)("tr", { style: { display: layoutMode === "grid" ? "grid" : "table-row" }, children: (0, import_jsx_runtime.jsx)("td", { colSpan: table.getVisibleLeafColumns().length, style: {
    display: layoutMode === "grid" ? "grid" : "table-cell"
  }, children: (_b = renderEmptyRowsFallback === null || renderEmptyRowsFallback === void 0 ? void 0 : renderEmptyRowsFallback({ table })) !== null && _b !== void 0 ? _b : (0, import_jsx_runtime.jsx)(Typography_default, { sx: {
    color: "text.secondary",
    fontStyle: "italic",
    maxWidth: `min(100vw, ${(_d = (_c = tablePaperRef.current) === null || _c === void 0 ? void 0 : _c.clientWidth) !== null && _d !== void 0 ? _d : 360}px)`,
    py: "2rem",
    textAlign: "center",
    width: "100%"
  }, children: globalFilter || columnFilters.length ? localization.noResultsFound : localization.noRecordsToDisplay }) }) }) : (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (virtualRows !== null && virtualRows !== void 0 ? virtualRows : rows).map((rowOrVirtualRow, rowIndex) => {
    const row = rowVirtualizer ? rows[rowOrVirtualRow.index] : rowOrVirtualRow;
    const props = {
      columnVirtualizer,
      measureElement: rowVirtualizer === null || rowVirtualizer === void 0 ? void 0 : rowVirtualizer.measureElement,
      numRows: rows.length,
      row,
      rowIndex: rowVirtualizer ? rowOrVirtualRow.index : rowIndex,
      table,
      virtualColumns,
      virtualPaddingLeft,
      virtualPaddingRight,
      virtualRow: rowVirtualizer ? rowOrVirtualRow : void 0
    };
    return memoMode === "rows" ? (0, import_jsx_runtime.jsx)(Memo_MRT_TableBodyRow, Object.assign({}, props), row.id) : (0, import_jsx_runtime.jsx)(MRT_TableBodyRow, Object.assign({}, props), row.id);
  }) }) }));
};
var Memo_MRT_TableBody = (0, import_react.memo)(MRT_TableBody, (prev, next) => prev.table.options.data === next.table.options.data);
var MRT_TableFooterCell = ({ footer, table }) => {
  var _a, _b, _c;
  const { getState, options: { layoutMode, muiTableFooterCellProps } } = table;
  const { density } = getState();
  const { column } = footer;
  const { columnDef } = column;
  const { columnDefType } = columnDef;
  const mTableFooterCellProps = muiTableFooterCellProps instanceof Function ? muiTableFooterCellProps({ column, table }) : muiTableFooterCellProps;
  const mcTableFooterCellProps = columnDef.muiTableFooterCellProps instanceof Function ? columnDef.muiTableFooterCellProps({ column, table }) : columnDef.muiTableFooterCellProps;
  const tableCellProps = Object.assign(Object.assign({}, mTableFooterCellProps), mcTableFooterCellProps);
  return (0, import_jsx_runtime.jsx)(TableCell_default, Object.assign({ align: columnDefType === "group" ? "center" : "left", colSpan: footer.colSpan, variant: "head" }, tableCellProps, { sx: (theme) => Object.assign({ display: layoutMode === "grid" ? "grid" : "table-cell", fontWeight: "bold", justifyContent: columnDefType === "group" ? "center" : void 0, p: density === "compact" ? "0.5rem" : density === "comfortable" ? "1rem" : "1.5rem", verticalAlign: "top", zIndex: column.getIsPinned() && columnDefType !== "group" ? 2 : 1 }, getCommonCellStyles({
    column,
    table,
    theme,
    tableCellProps
  })), children: (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: footer.isPlaceholder ? null : (_c = (_b = columnDef.Footer instanceof Function ? (_a = columnDef.Footer) === null || _a === void 0 ? void 0 : _a.call(columnDef, {
    column,
    footer,
    table
  }) : columnDef.Footer) !== null && _b !== void 0 ? _b : columnDef.footer) !== null && _c !== void 0 ? _c : null }) }));
};
var MRT_TableFooterRow = ({ footerGroup, table, virtualColumns, virtualPaddingLeft, virtualPaddingRight }) => {
  var _a;
  const { options: { layoutMode, muiTableFooterRowProps } } = table;
  if (!((_a = footerGroup.headers) === null || _a === void 0 ? void 0 : _a.some((header) => typeof header.column.columnDef.footer === "string" && !!header.column.columnDef.footer || header.column.columnDef.Footer)))
    return null;
  const tableRowProps = muiTableFooterRowProps instanceof Function ? muiTableFooterRowProps({ footerGroup, table }) : muiTableFooterRowProps;
  return (0, import_jsx_runtime.jsxs)(TableRow_default, Object.assign({}, tableRowProps, { sx: (theme) => Object.assign({ backgroundColor: lighten(theme.palette.background.default, 0.04), display: layoutMode === "grid" ? "flex" : "table-row", width: "100%" }, (tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx) instanceof Function ? tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx(theme) : tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx), children: [virtualPaddingLeft ? (0, import_jsx_runtime.jsx)("th", { style: { display: "flex", width: virtualPaddingLeft } }) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : footerGroup.headers).map((footerOrVirtualFooter) => {
    const footer = virtualColumns ? footerGroup.headers[footerOrVirtualFooter.index] : footerOrVirtualFooter;
    return (0, import_jsx_runtime.jsx)(MRT_TableFooterCell, { footer, table }, footer.id);
  }), virtualPaddingRight ? (0, import_jsx_runtime.jsx)("th", { style: { display: "flex", width: virtualPaddingRight } }) : null] }));
};
var MRT_TableFooter = ({ table, virtualColumns, virtualPaddingLeft, virtualPaddingRight }) => {
  const { getFooterGroups, getState, options: { enableStickyFooter, layoutMode, muiTableFooterProps } } = table;
  const { isFullScreen } = getState();
  const tableFooterProps = muiTableFooterProps instanceof Function ? muiTableFooterProps({ table }) : muiTableFooterProps;
  const stickFooter = (isFullScreen || enableStickyFooter) && enableStickyFooter !== false;
  return (0, import_jsx_runtime.jsx)(TableFooter_default, Object.assign({}, tableFooterProps, { sx: (theme) => Object.assign({ bottom: stickFooter ? 0 : void 0, display: layoutMode === "grid" ? "grid" : "table-row-group", opacity: stickFooter ? 0.97 : void 0, outline: stickFooter ? theme.palette.mode === "light" ? `1px solid ${theme.palette.grey[300]}` : `1px solid ${theme.palette.grey[700]}` : void 0, position: stickFooter ? "sticky" : void 0, zIndex: stickFooter ? 1 : void 0 }, (tableFooterProps === null || tableFooterProps === void 0 ? void 0 : tableFooterProps.sx) instanceof Function ? tableFooterProps === null || tableFooterProps === void 0 ? void 0 : tableFooterProps.sx(theme) : tableFooterProps === null || tableFooterProps === void 0 ? void 0 : tableFooterProps.sx), children: getFooterGroups().map((footerGroup) => (0, import_jsx_runtime.jsx)(MRT_TableFooterRow, { footerGroup, table, virtualColumns, virtualPaddingLeft, virtualPaddingRight }, footerGroup.id)) }));
};
var MRT_Table = ({ table }) => {
  var _a, _b, _c, _d;
  const { getFlatHeaders, getState, options: { columns, columnVirtualizerInstanceRef, columnVirtualizerProps, enableColumnResizing, enableColumnVirtualization, enablePinning, enableStickyHeader, enableTableFooter, enableTableHead, layoutMode, memoMode, muiTableProps }, refs: { tableContainerRef } } = table;
  const { columnPinning, columnSizing, columnSizingInfo, columnVisibility, isFullScreen } = getState();
  const tableProps = muiTableProps instanceof Function ? muiTableProps({ table }) : muiTableProps;
  const vProps = columnVirtualizerProps instanceof Function ? columnVirtualizerProps({ table }) : columnVirtualizerProps;
  const columnSizeVars = (0, import_react.useMemo)(() => {
    const headers = getFlatHeaders();
    const colSizes = {};
    for (let i = 0; i < headers.length; i++) {
      const header = headers[i];
      const colSize = header.getSize();
      colSizes[`--header-${parseCSSVarId(header.id)}-size`] = colSize;
      colSizes[`--col-${parseCSSVarId(header.column.id)}-size`] = colSize;
    }
    return colSizes;
  }, [columns, columnSizing, columnSizingInfo, columnVisibility]);
  const averageColumnWidth = (0, import_react.useMemo)(() => {
    var _a2, _b2, _c2, _d2;
    if (!enableColumnVirtualization)
      return 0;
    const columnsWidths = (_d2 = (_c2 = (_b2 = (_a2 = table.getRowModel().rows[0]) === null || _a2 === void 0 ? void 0 : _a2.getCenterVisibleCells()) === null || _b2 === void 0 ? void 0 : _b2.slice(0, 16)) === null || _c2 === void 0 ? void 0 : _c2.map((cell) => cell.column.getSize() * 1.2)) !== null && _d2 !== void 0 ? _d2 : [];
    return columnsWidths.reduce((a, b) => a + b, 0) / columnsWidths.length;
  }, [table.getRowModel().rows, columnPinning, columnVisibility]);
  const [leftPinnedIndexes, rightPinnedIndexes] = (0, import_react.useMemo)(() => enableColumnVirtualization && enablePinning ? [
    table.getLeftLeafColumns().map((c) => c.getPinnedIndex()),
    table.getRightLeafColumns().map((c) => table.getVisibleLeafColumns().length - c.getPinnedIndex() - 1)
  ] : [[], []], [columnPinning, enableColumnVirtualization, enablePinning]);
  const columnVirtualizer = enableColumnVirtualization ? useVirtualizer(Object.assign({ count: table.getVisibleLeafColumns().length, estimateSize: () => averageColumnWidth, getScrollElement: () => tableContainerRef.current, horizontal: true, overscan: 3, rangeExtractor: (0, import_react.useCallback)((range) => [
    .../* @__PURE__ */ new Set([
      ...leftPinnedIndexes,
      ...defaultRangeExtractor(range),
      ...rightPinnedIndexes
    ])
  ], [leftPinnedIndexes, rightPinnedIndexes]) }, vProps)) : void 0;
  if (columnVirtualizerInstanceRef && columnVirtualizer) {
    columnVirtualizerInstanceRef.current = columnVirtualizer;
  }
  const virtualColumns = columnVirtualizer ? columnVirtualizer.getVirtualItems() : void 0;
  let virtualPaddingLeft;
  let virtualPaddingRight;
  if (columnVirtualizer && (virtualColumns === null || virtualColumns === void 0 ? void 0 : virtualColumns.length)) {
    virtualPaddingLeft = (_b = (_a = virtualColumns[leftPinnedIndexes.length]) === null || _a === void 0 ? void 0 : _a.start) !== null && _b !== void 0 ? _b : 0;
    virtualPaddingRight = columnVirtualizer.getTotalSize() - ((_d = (_c = virtualColumns[virtualColumns.length - 1 - rightPinnedIndexes.length]) === null || _c === void 0 ? void 0 : _c.end) !== null && _d !== void 0 ? _d : 0);
  }
  const props = {
    table,
    virtualColumns,
    virtualPaddingLeft,
    virtualPaddingRight
  };
  return (0, import_jsx_runtime.jsxs)(Table_default, Object.assign({ stickyHeader: enableStickyHeader || isFullScreen }, tableProps, { sx: (theme) => Object.assign({ borderCollapse: "separate", display: layoutMode === "grid" ? "grid" : "table", tableLayout: layoutMode !== "grid" && enableColumnResizing ? "fixed" : void 0 }, (tableProps === null || tableProps === void 0 ? void 0 : tableProps.sx) instanceof Function ? tableProps.sx(theme) : tableProps === null || tableProps === void 0 ? void 0 : tableProps.sx), style: Object.assign(Object.assign({}, columnSizeVars), tableProps === null || tableProps === void 0 ? void 0 : tableProps.style), children: [enableTableHead && (0, import_jsx_runtime.jsx)(MRT_TableHead, Object.assign({}, props)), memoMode === "table-body" || columnSizingInfo.isResizingColumn ? (0, import_jsx_runtime.jsx)(Memo_MRT_TableBody, Object.assign({ columnVirtualizer }, props)) : (0, import_jsx_runtime.jsx)(MRT_TableBody, Object.assign({ columnVirtualizer }, props)), enableTableFooter && (0, import_jsx_runtime.jsx)(MRT_TableFooter, Object.assign({}, props))] }));
};
var useIsomorphicLayoutEffect2 = typeof window !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
var MRT_TableContainer = ({ table }) => {
  const { getState, options: { enableStickyHeader, muiTableContainerProps }, refs: { tableContainerRef, bottomToolbarRef, topToolbarRef } } = table;
  const { isFullScreen } = getState();
  const [totalToolbarHeight, setTotalToolbarHeight] = (0, import_react.useState)(0);
  const tableContainerProps = muiTableContainerProps instanceof Function ? muiTableContainerProps({ table }) : muiTableContainerProps;
  useIsomorphicLayoutEffect2(() => {
    var _a, _b, _c, _d;
    const topToolbarHeight = typeof document !== "undefined" ? (_b = (_a = topToolbarRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) !== null && _b !== void 0 ? _b : 0 : 0;
    const bottomToolbarHeight = typeof document !== "undefined" ? (_d = (_c = bottomToolbarRef === null || bottomToolbarRef === void 0 ? void 0 : bottomToolbarRef.current) === null || _c === void 0 ? void 0 : _c.offsetHeight) !== null && _d !== void 0 ? _d : 0 : 0;
    setTotalToolbarHeight(topToolbarHeight + bottomToolbarHeight);
  });
  return (0, import_jsx_runtime.jsx)(TableContainer_default, Object.assign({}, tableContainerProps, { ref: (node) => {
    if (node) {
      tableContainerRef.current = node;
      if (tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.ref) {
        tableContainerProps.ref.current = node;
      }
    }
  }, sx: (theme) => Object.assign({ maxWidth: "100%", maxHeight: enableStickyHeader ? `clamp(350px, calc(100vh - ${totalToolbarHeight}px), 9999px)` : void 0, overflow: "auto" }, (tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.sx) instanceof Function ? tableContainerProps.sx(theme) : tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.sx), style: Object.assign({ maxHeight: isFullScreen ? `calc(100vh - ${totalToolbarHeight}px)` : void 0 }, tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.style), children: (0, import_jsx_runtime.jsx)(MRT_Table, { table }) }));
};
var MRT_TablePaper = ({ table }) => {
  const { getState, options: { enableBottomToolbar, enableTopToolbar, muiTablePaperProps, renderBottomToolbar, renderTopToolbar }, refs: { tablePaperRef } } = table;
  const { isFullScreen } = getState();
  const tablePaperProps = muiTablePaperProps instanceof Function ? muiTablePaperProps({ table }) : muiTablePaperProps;
  return (0, import_jsx_runtime.jsxs)(Paper_default, Object.assign({ elevation: 2 }, tablePaperProps, { ref: (ref) => {
    tablePaperRef.current = ref;
    if (tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.ref) {
      tablePaperProps.ref.current = ref;
    }
  }, sx: (theme) => Object.assign({ transition: "all 150ms ease-in-out" }, (tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.sx) instanceof Function ? tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.sx(theme) : tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.sx), style: Object.assign(Object.assign({}, tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.style), isFullScreen ? {
    height: "100vh",
    margin: 0,
    maxHeight: "100vh",
    maxWidth: "100vw",
    padding: 0,
    width: "100vw"
  } : {}), children: [enableTopToolbar && (renderTopToolbar instanceof Function ? renderTopToolbar({ table }) : renderTopToolbar !== null && renderTopToolbar !== void 0 ? renderTopToolbar : (0, import_jsx_runtime.jsx)(MRT_TopToolbar, { table })), (0, import_jsx_runtime.jsx)(MRT_TableContainer, { table }), enableBottomToolbar && (renderBottomToolbar instanceof Function ? renderBottomToolbar({ table }) : renderBottomToolbar !== null && renderBottomToolbar !== void 0 ? renderBottomToolbar : (0, import_jsx_runtime.jsx)(MRT_BottomToolbar, { table }))] }));
};
var MRT_EditRowModal = ({ open, row, table }) => {
  const { options: { localization } } = table;
  return (0, import_jsx_runtime.jsxs)(Dialog_default, { open, children: [(0, import_jsx_runtime.jsx)(DialogTitle_default, { textAlign: "center", children: localization.edit }), (0, import_jsx_runtime.jsx)(DialogContent_default, { children: (0, import_jsx_runtime.jsx)("form", { onSubmit: (e) => e.preventDefault(), children: (0, import_jsx_runtime.jsx)(Stack_default, { sx: {
    gap: "1.5rem",
    minWidth: { xs: "300px", sm: "360px", md: "400px" },
    pt: "1rem",
    width: "100%"
  }, children: row.getAllCells().filter((cell) => cell.column.columnDef.columnDefType === "data").map((cell) => (0, import_jsx_runtime.jsx)(MRT_EditCellTextField, { cell, showLabel: true, table }, cell.id)) }) }) }), (0, import_jsx_runtime.jsx)(DialogActions_default, { sx: { p: "1.25rem" }, children: (0, import_jsx_runtime.jsx)(MRT_EditActionButtons, { row, table, variant: "text" }) })] });
};
var MRT_TableRoot = (props) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13;
  const bottomToolbarRef = (0, import_react.useRef)(null);
  const editInputRefs = (0, import_react.useRef)({});
  const filterInputRefs = (0, import_react.useRef)({});
  const searchInputRef = (0, import_react.useRef)(null);
  const tableContainerRef = (0, import_react.useRef)(null);
  const tableHeadCellRefs = (0, import_react.useRef)({});
  const tablePaperRef = (0, import_react.useRef)(null);
  const topToolbarRef = (0, import_react.useRef)(null);
  const initialState = (0, import_react.useMemo)(() => {
    var _a2, _b2, _c2;
    const initState = (_a2 = props.initialState) !== null && _a2 !== void 0 ? _a2 : {};
    initState.columnOrder = (_b2 = initState.columnOrder) !== null && _b2 !== void 0 ? _b2 : getDefaultColumnOrderIds(props);
    initState.globalFilterFn = (_c2 = props.globalFilterFn) !== null && _c2 !== void 0 ? _c2 : "fuzzy";
    return initState;
  }, []);
  const [columnFilterFns, setColumnFilterFns] = (0, import_react.useState)(() => Object.assign({}, ...getAllLeafColumnDefs(props.columns).map((col) => {
    var _a2, _b2, _c2, _d2;
    return {
      [getColumnId(col)]: col.filterFn instanceof Function ? (_a2 = col.filterFn.name) !== null && _a2 !== void 0 ? _a2 : "custom" : (_d2 = (_b2 = col.filterFn) !== null && _b2 !== void 0 ? _b2 : (_c2 = initialState === null || initialState === void 0 ? void 0 : initialState.columnFilterFns) === null || _c2 === void 0 ? void 0 : _c2[getColumnId(col)]) !== null && _d2 !== void 0 ? _d2 : getDefaultColumnFilterFn(col)
    };
  })));
  const [columnOrder, setColumnOrder] = (0, import_react.useState)((_a = initialState.columnOrder) !== null && _a !== void 0 ? _a : []);
  const [density, setDensity] = (0, import_react.useState)((_b = initialState === null || initialState === void 0 ? void 0 : initialState.density) !== null && _b !== void 0 ? _b : "comfortable");
  const [draggingColumn, setDraggingColumn] = (0, import_react.useState)((_c = initialState.draggingColumn) !== null && _c !== void 0 ? _c : null);
  const [draggingRow, setDraggingRow] = (0, import_react.useState)((_d = initialState.draggingRow) !== null && _d !== void 0 ? _d : null);
  const [editingCell, setEditingCell] = (0, import_react.useState)((_e = initialState.editingCell) !== null && _e !== void 0 ? _e : null);
  const [editingRow, setEditingRow] = (0, import_react.useState)((_f = initialState.editingRow) !== null && _f !== void 0 ? _f : null);
  const [globalFilterFn, setGlobalFilterFn] = (0, import_react.useState)((_g = initialState.globalFilterFn) !== null && _g !== void 0 ? _g : "fuzzy");
  const [grouping, setGrouping] = (0, import_react.useState)((_h = initialState.grouping) !== null && _h !== void 0 ? _h : []);
  const [hoveredColumn, setHoveredColumn] = (0, import_react.useState)((_j = initialState.hoveredColumn) !== null && _j !== void 0 ? _j : null);
  const [hoveredRow, setHoveredRow] = (0, import_react.useState)((_k = initialState.hoveredRow) !== null && _k !== void 0 ? _k : null);
  const [isFullScreen, setIsFullScreen] = (0, import_react.useState)((_l = initialState === null || initialState === void 0 ? void 0 : initialState.isFullScreen) !== null && _l !== void 0 ? _l : false);
  const [showAlertBanner, setShowAlertBanner] = (0, import_react.useState)((_o = (_m = props.initialState) === null || _m === void 0 ? void 0 : _m.showAlertBanner) !== null && _o !== void 0 ? _o : false);
  const [showColumnFilters, setShowColumnFilters] = (0, import_react.useState)((_p = initialState === null || initialState === void 0 ? void 0 : initialState.showColumnFilters) !== null && _p !== void 0 ? _p : false);
  const [showGlobalFilter, setShowGlobalFilter] = (0, import_react.useState)((_q = initialState === null || initialState === void 0 ? void 0 : initialState.showGlobalFilter) !== null && _q !== void 0 ? _q : false);
  const [showToolbarDropZone, setShowToolbarDropZone] = (0, import_react.useState)((_r = initialState === null || initialState === void 0 ? void 0 : initialState.showToolbarDropZone) !== null && _r !== void 0 ? _r : false);
  const displayColumns = (0, import_react.useMemo)(() => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _j2, _k2, _l2, _m2, _o2, _p2, _q2, _r2, _s2;
    return [
      ((_b2 = (_a2 = props.state) === null || _a2 === void 0 ? void 0 : _a2.columnOrder) !== null && _b2 !== void 0 ? _b2 : columnOrder).includes("mrt-row-drag") && Object.assign(Object.assign(Object.assign({ header: props.localization.move, size: 60 }, props.defaultDisplayColumn), (_c2 = props.displayColumnDefOptions) === null || _c2 === void 0 ? void 0 : _c2["mrt-row-drag"]), { id: "mrt-row-drag" }),
      ((_e2 = (_d2 = props.state) === null || _d2 === void 0 ? void 0 : _d2.columnOrder) !== null && _e2 !== void 0 ? _e2 : columnOrder).includes("mrt-row-actions") && Object.assign(Object.assign(Object.assign({ Cell: ({ cell, row }) => (0, import_jsx_runtime.jsx)(MRT_ToggleRowActionMenuButton, { cell, row, table }), header: props.localization.actions, size: 70 }, props.defaultDisplayColumn), (_f2 = props.displayColumnDefOptions) === null || _f2 === void 0 ? void 0 : _f2["mrt-row-actions"]), { id: "mrt-row-actions" }),
      ((_h2 = (_g2 = props.state) === null || _g2 === void 0 ? void 0 : _g2.columnOrder) !== null && _h2 !== void 0 ? _h2 : columnOrder).includes("mrt-row-expand") && showExpandColumn(props, (_k2 = (_j2 = props.state) === null || _j2 === void 0 ? void 0 : _j2.grouping) !== null && _k2 !== void 0 ? _k2 : grouping) && Object.assign(Object.assign(Object.assign({ Cell: ({ row }) => (0, import_jsx_runtime.jsx)(MRT_ExpandButton, { row, table }), Header: props.enableExpandAll ? () => (0, import_jsx_runtime.jsx)(MRT_ExpandAllButton, { table }) : null, header: props.localization.expand, size: 60 }, props.defaultDisplayColumn), (_l2 = props.displayColumnDefOptions) === null || _l2 === void 0 ? void 0 : _l2["mrt-row-expand"]), { id: "mrt-row-expand" }),
      ((_o2 = (_m2 = props.state) === null || _m2 === void 0 ? void 0 : _m2.columnOrder) !== null && _o2 !== void 0 ? _o2 : columnOrder).includes("mrt-row-select") && Object.assign(Object.assign(Object.assign({ Cell: ({ row }) => (0, import_jsx_runtime.jsx)(MRT_SelectCheckbox, { row, table }), Header: props.enableSelectAll && props.enableMultiRowSelection ? () => (0, import_jsx_runtime.jsx)(MRT_SelectCheckbox, { selectAll: true, table }) : null, header: props.localization.select, size: 60 }, props.defaultDisplayColumn), (_p2 = props.displayColumnDefOptions) === null || _p2 === void 0 ? void 0 : _p2["mrt-row-select"]), { id: "mrt-row-select" }),
      ((_r2 = (_q2 = props.state) === null || _q2 === void 0 ? void 0 : _q2.columnOrder) !== null && _r2 !== void 0 ? _r2 : columnOrder).includes("mrt-row-numbers") && Object.assign(Object.assign(Object.assign({ Cell: ({ row }) => row.index + 1, Header: () => props.localization.rowNumber, header: props.localization.rowNumbers, size: 60 }, props.defaultDisplayColumn), (_s2 = props.displayColumnDefOptions) === null || _s2 === void 0 ? void 0 : _s2["mrt-row-numbers"]), { id: "mrt-row-numbers" })
    ].filter(Boolean);
  }, [
    columnOrder,
    grouping,
    props.displayColumnDefOptions,
    props.editingMode,
    props.enableColumnDragging,
    props.enableColumnFilterModes,
    props.enableColumnOrdering,
    props.enableEditing,
    props.enableExpandAll,
    props.enableExpanding,
    props.enableGrouping,
    props.enableRowActions,
    props.enableRowDragging,
    props.enableRowNumbers,
    props.enableRowOrdering,
    props.enableRowSelection,
    props.enableSelectAll,
    props.localization,
    props.positionActionsColumn,
    props.renderDetailPanel,
    props.renderRowActionMenuItems,
    props.renderRowActions,
    (_s = props.state) === null || _s === void 0 ? void 0 : _s.columnOrder,
    (_t = props.state) === null || _t === void 0 ? void 0 : _t.grouping
  ]);
  const columnDefs = (0, import_react.useMemo)(() => {
    var _a2, _b2, _c2;
    return prepareColumns({
      aggregationFns: props.aggregationFns,
      columnDefs: [...displayColumns, ...props.columns],
      columnFilterFns: (_b2 = (_a2 = props.state) === null || _a2 === void 0 ? void 0 : _a2.columnFilterFns) !== null && _b2 !== void 0 ? _b2 : columnFilterFns,
      defaultDisplayColumn: (_c2 = props.defaultDisplayColumn) !== null && _c2 !== void 0 ? _c2 : {},
      filterFns: props.filterFns,
      sortingFns: props.sortingFns
    });
  }, [
    columnFilterFns,
    displayColumns,
    props.columns,
    (_u = props.state) === null || _u === void 0 ? void 0 : _u.columnFilterFns
  ]);
  const data = (0, import_react.useMemo)(() => {
    var _a2, _b2, _c2, _d2, _e2;
    return (((_a2 = props.state) === null || _a2 === void 0 ? void 0 : _a2.isLoading) || ((_b2 = props.state) === null || _b2 === void 0 ? void 0 : _b2.showSkeletons)) && !props.data.length ? [
      ...Array(((_d2 = (_c2 = props.state) === null || _c2 === void 0 ? void 0 : _c2.pagination) === null || _d2 === void 0 ? void 0 : _d2.pageSize) || ((_e2 = initialState === null || initialState === void 0 ? void 0 : initialState.pagination) === null || _e2 === void 0 ? void 0 : _e2.pageSize) || 10).fill(null)
    ].map(() => Object.assign({}, ...getAllLeafColumnDefs(props.columns).map((col) => ({
      [getColumnId(col)]: null
    })))) : props.data;
  }, [props.data, (_v = props.state) === null || _v === void 0 ? void 0 : _v.isLoading, (_w = props.state) === null || _w === void 0 ? void 0 : _w.showSkeletons]);
  const table = Object.assign(Object.assign({}, useReactTable(Object.assign(Object.assign({ getCoreRowModel: getCoreRowModel(), getExpandedRowModel: props.enableExpanding || props.enableGrouping ? getExpandedRowModel() : void 0, getFacetedMinMaxValues: props.enableFacetedValues ? getFacetedMinMaxValues() : void 0, getFacetedRowModel: props.enableFacetedValues ? getFacetedRowModel() : void 0, getFacetedUniqueValues: props.enableFacetedValues ? getFacetedUniqueValues() : void 0, getFilteredRowModel: props.enableColumnFilters || props.enableGlobalFilter || props.enableFilters ? getFilteredRowModel() : void 0, getGroupedRowModel: props.enableGrouping ? getGroupedRowModel() : void 0, getPaginationRowModel: props.enablePagination ? getPaginationRowModel() : void 0, getSortedRowModel: props.enableSorting ? getSortedRowModel() : void 0, onColumnOrderChange: setColumnOrder, onGroupingChange: setGrouping, getSubRows: (row) => row === null || row === void 0 ? void 0 : row.subRows }, props), {
    //@ts-ignore
    columns: columnDefs,
    data,
    globalFilterFn: (_y = (_x = props.filterFns) === null || _x === void 0 ? void 0 : _x[globalFilterFn]) !== null && _y !== void 0 ? _y : (_z = props.filterFns) === null || _z === void 0 ? void 0 : _z.fuzzy,
    initialState,
    state: Object.assign({
      columnFilterFns,
      columnOrder,
      density,
      draggingColumn,
      draggingRow,
      editingCell,
      editingRow,
      globalFilterFn,
      grouping,
      hoveredColumn,
      hoveredRow,
      isFullScreen,
      showAlertBanner,
      showColumnFilters,
      showGlobalFilter,
      showToolbarDropZone
    }, props.state)
  }))), { refs: {
    bottomToolbarRef,
    editInputRefs,
    filterInputRefs,
    searchInputRef,
    tableContainerRef,
    tableHeadCellRefs,
    tablePaperRef,
    topToolbarRef
  }, setColumnFilterFns: (_0 = props.onColumnFilterFnsChange) !== null && _0 !== void 0 ? _0 : setColumnFilterFns, setDensity: (_1 = props.onDensityChange) !== null && _1 !== void 0 ? _1 : setDensity, setDraggingColumn: (_2 = props.onDraggingColumnChange) !== null && _2 !== void 0 ? _2 : setDraggingColumn, setDraggingRow: (_3 = props.onDraggingRowChange) !== null && _3 !== void 0 ? _3 : setDraggingRow, setEditingCell: (_4 = props.onEditingCellChange) !== null && _4 !== void 0 ? _4 : setEditingCell, setEditingRow: (_5 = props.onEditingRowChange) !== null && _5 !== void 0 ? _5 : setEditingRow, setGlobalFilterFn: (_6 = props.onGlobalFilterFnChange) !== null && _6 !== void 0 ? _6 : setGlobalFilterFn, setHoveredColumn: (_7 = props.onHoveredColumnChange) !== null && _7 !== void 0 ? _7 : setHoveredColumn, setHoveredRow: (_8 = props.onHoveredRowChange) !== null && _8 !== void 0 ? _8 : setHoveredRow, setIsFullScreen: (_9 = props.onIsFullScreenChange) !== null && _9 !== void 0 ? _9 : setIsFullScreen, setShowAlertBanner: (_10 = props.onShowAlertBannerChange) !== null && _10 !== void 0 ? _10 : setShowAlertBanner, setShowColumnFilters: (_11 = props.onShowColumnFiltersChange) !== null && _11 !== void 0 ? _11 : setShowColumnFilters, setShowGlobalFilter: (_12 = props.onShowGlobalFilterChange) !== null && _12 !== void 0 ? _12 : setShowGlobalFilter, setShowToolbarDropZone: (_13 = props.onShowToolbarDropZoneChange) !== null && _13 !== void 0 ? _13 : setShowToolbarDropZone });
  if (props.tableFeatures) {
    props.tableFeatures.forEach((feature) => {
      Object.assign(table, feature(table));
    });
  }
  if (props.tableInstanceRef) {
    props.tableInstanceRef.current = table;
  }
  const initialBodyHeight = (0, import_react.useRef)();
  (0, import_react.useEffect)(() => {
    if (typeof window !== "undefined") {
      initialBodyHeight.current = document.body.style.height;
    }
  }, []);
  (0, import_react.useEffect)(() => {
    if (typeof window !== "undefined") {
      if (table.getState().isFullScreen) {
        document.body.style.height = "100vh";
      } else {
        document.body.style.height = initialBodyHeight.current;
      }
    }
  }, [table.getState().isFullScreen]);
  (0, import_react.useEffect)(() => {
    var _a2;
    const { pageIndex, pageSize } = table.getState().pagination;
    const totalRowCount = (_a2 = props.rowCount) !== null && _a2 !== void 0 ? _a2 : table.getPrePaginationRowModel().rows.length;
    const firstVisibleRowIndex = pageIndex * pageSize;
    if (firstVisibleRowIndex > totalRowCount) {
      table.setPageIndex(Math.floor(totalRowCount / pageSize));
    }
  }, [props.rowCount, table.getPrePaginationRowModel().rows.length]);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(Dialog_default, { PaperComponent: Box_default, TransitionComponent: !props.enableRowVirtualization ? Grow_default : void 0, disablePortal: true, fullScreen: true, keepMounted: false, onClose: () => table.setIsFullScreen(false), open: table.getState().isFullScreen, transitionDuration: 400, children: (0, import_jsx_runtime.jsx)(MRT_TablePaper, { table }) }), !table.getState().isFullScreen && (0, import_jsx_runtime.jsx)(MRT_TablePaper, { table }), editingRow && props.editingMode === "modal" && (0, import_jsx_runtime.jsx)(MRT_EditRowModal, { row: editingRow, table, open: true })] });
};
var MaterialReactTable = (_a) => {
  var _b;
  var { aggregationFns: aggregationFns2, autoResetExpanded = false, columnResizeMode = "onChange", defaultColumn, defaultDisplayColumn, editingMode = "modal", enableBottomToolbar = true, enableColumnActions = true, enableColumnFilters = true, enableColumnOrdering = false, enableColumnResizing = false, enableDensityToggle = true, enableExpandAll = true, enableExpanding, enableFilterMatchHighlighting = true, enableFilters = true, enableFullScreenToggle = true, enableGlobalFilter = true, enableGlobalFilterRankedResults = true, enableGrouping = false, enableHiding = true, enableMultiRowSelection = true, enableMultiSort = true, enablePagination = true, enablePinning = false, enableRowSelection = false, enableSelectAll = true, enableSorting = true, enableStickyHeader = false, enableTableFooter = true, enableTableHead = true, enableToolbarInternalActions = true, enableTopToolbar = true, filterFns: filterFns2, icons, layoutMode = "semantic", localization, manualFiltering, manualGrouping, manualPagination, manualSorting, positionActionsColumn = "first", positionExpandColumn = "first", positionGlobalFilter = "right", positionPagination = "bottom", positionToolbarAlertBanner = "top", positionToolbarDropZone = "top", rowNumberMode = "original", selectAllMode = "page", sortingFns: sortingFns2 } = _a, rest = __rest(_a, ["aggregationFns", "autoResetExpanded", "columnResizeMode", "defaultColumn", "defaultDisplayColumn", "editingMode", "enableBottomToolbar", "enableColumnActions", "enableColumnFilters", "enableColumnOrdering", "enableColumnResizing", "enableDensityToggle", "enableExpandAll", "enableExpanding", "enableFilterMatchHighlighting", "enableFilters", "enableFullScreenToggle", "enableGlobalFilter", "enableGlobalFilterRankedResults", "enableGrouping", "enableHiding", "enableMultiRowSelection", "enableMultiSort", "enablePagination", "enablePinning", "enableRowSelection", "enableSelectAll", "enableSorting", "enableStickyHeader", "enableTableFooter", "enableTableHead", "enableToolbarInternalActions", "enableTopToolbar", "filterFns", "icons", "layoutMode", "localization", "manualFiltering", "manualGrouping", "manualPagination", "manualSorting", "positionActionsColumn", "positionExpandColumn", "positionGlobalFilter", "positionPagination", "positionToolbarAlertBanner", "positionToolbarDropZone", "rowNumberMode", "selectAllMode", "sortingFns"]);
  const _icons = (0, import_react.useMemo)(() => Object.assign(Object.assign({}, MRT_Default_Icons), icons), [icons]);
  const _localization = (0, import_react.useMemo)(() => Object.assign(Object.assign({}, MRT_Localization_EN), localization), [localization]);
  const _aggregationFns = (0, import_react.useMemo)(() => Object.assign(Object.assign({}, MRT_AggregationFns), aggregationFns2), []);
  const _filterFns = (0, import_react.useMemo)(() => Object.assign(Object.assign({}, MRT_FilterFns), filterFns2), []);
  const _sortingFns = (0, import_react.useMemo)(() => Object.assign(Object.assign({}, MRT_SortingFns), sortingFns2), []);
  const _defaultColumn = (0, import_react.useMemo)(() => Object.assign(Object.assign({}, MRT_DefaultColumn), defaultColumn), [defaultColumn]);
  const _defaultDisplayColumn = (0, import_react.useMemo)(() => Object.assign(Object.assign({}, MRT_DefaultDisplayColumn), defaultDisplayColumn), [defaultDisplayColumn]);
  if (rest.enableRowVirtualization || rest.enableColumnVirtualization) {
    layoutMode = "grid";
  }
  if (rest.enableRowVirtualization) {
    enableStickyHeader = true;
  }
  if (enablePagination === false && manualPagination === void 0) {
    manualPagination = true;
  }
  if (!((_b = rest.data) === null || _b === void 0 ? void 0 : _b.length)) {
    manualFiltering = true;
    manualGrouping = true;
    manualPagination = true;
    manualSorting = true;
  }
  return (0, import_jsx_runtime.jsx)(MRT_TableRoot, Object.assign({ aggregationFns: _aggregationFns, autoResetExpanded, columnResizeMode, defaultColumn: _defaultColumn, defaultDisplayColumn: _defaultDisplayColumn, editingMode, enableBottomToolbar, enableColumnActions, enableColumnFilters, enableColumnOrdering, enableColumnResizing, enableDensityToggle, enableExpandAll, enableExpanding, enableFilterMatchHighlighting, enableFilters, enableFullScreenToggle, enableGlobalFilter, enableGlobalFilterRankedResults, enableGrouping, enableHiding, enableMultiRowSelection, enableMultiSort, enablePagination, enablePinning, enableRowSelection, enableSelectAll, enableSorting, enableStickyHeader, enableTableFooter, enableTableHead, enableToolbarInternalActions, enableTopToolbar, filterFns: _filterFns, icons: _icons, layoutMode, localization: _localization, manualFiltering, manualGrouping, manualPagination, manualSorting, positionActionsColumn, positionExpandColumn, positionGlobalFilter, positionPagination, positionToolbarAlertBanner, positionToolbarDropZone, rowNumberMode, selectAllMode, sortingFns: _sortingFns }, rest));
};
export {
  MRT_AggregationFns,
  MRT_BottomToolbar,
  MRT_CopyButton,
  MRT_EditActionButtons,
  MRT_ExpandButton,
  MRT_FilterFns,
  MRT_FilterOptionMenu,
  MRT_FullScreenToggleButton,
  MRT_GlobalFilterTextField,
  MRT_GrabHandleButton,
  MRT_ShowHideColumnsButton,
  MRT_SortingFns,
  MRT_TableHeadCellFilterContainer,
  MRT_TablePagination,
  MRT_ToggleDensePaddingButton,
  MRT_ToggleFiltersButton,
  MRT_ToggleGlobalFilterButton,
  MRT_ToggleRowActionMenuButton,
  MRT_ToolbarAlertBanner,
  MRT_ToolbarDropZone,
  MRT_ToolbarInternalButtons,
  MRT_TopToolbar,
  MaterialReactTable,
  MaterialReactTable as default
};
/*! Bundled license information:

@tanstack/table-core/build/lib/index.mjs:
  (**
   * table-core
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@tanstack/react-table/build/lib/index.mjs:
  (**
   * react-table
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@tanstack/match-sorter-utils/build/lib/index.mjs:
  (**
   * match-sorter-utils
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)
  (**
   * @name match-sorter
   * @license MIT license.
   * @copyright (c) 2099 Kent C. Dodds
   * @author Kent C. Dodds <me@kentcdodds.com> (https://kentcdodds.com)
   *)

@tanstack/react-virtual/build/lib/_virtual/_rollupPluginBabelHelpers.mjs:
  (**
   * react-virtual
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@tanstack/virtual-core/build/lib/_virtual/_rollupPluginBabelHelpers.mjs:
  (**
   * virtual-core
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@tanstack/virtual-core/build/lib/utils.mjs:
  (**
   * virtual-core
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@tanstack/virtual-core/build/lib/index.mjs:
  (**
   * virtual-core
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@tanstack/react-virtual/build/lib/index.mjs:
  (**
   * react-virtual
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)
*/
//# sourceMappingURL=material-react-table.js.map
